<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sudoku of the Day</title>
    <script src="sudoku.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', serif;
            background: linear-gradient(135deg, #f5f3f0 0%, #e8e3db 100%);
            min-height: 100vh;
            color: #2c3e50;
        }

        .paper-container {
            max-width: 800px;
            margin: 20px auto;
            background: #fefefe;
            border-radius: 8px;
            box-shadow: 
                0 4px 6px rgba(0,0,0,0.1),
                0 1px 3px rgba(0,0,0,0.08),
                inset 0 0 0 1px rgba(255,255,255,0.5);
            position: relative;
            overflow: hidden;
        }

        .paper-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 60px;
            bottom: 0;
            width: 2px;
            background: #ff6b6b;
            opacity: 0.3;
        }

        .paper-container::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: 
                repeating-linear-gradient(
                    transparent,
                    transparent 27px,
                    rgba(200,200,200,0.3) 28px
                );
            pointer-events: none;
        }

        .header {
            text-align: center;
            padding: 30px 20px;
            border-bottom: 2px solid #e9ecef;
            background: linear-gradient(to bottom, #fefefe, #f8f9fa);
        }

        .header h1 {
            font-size: 2.5em;
            color: #2c3e50;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 10px;
        }

        .date-display {
            font-size: 1.2em;
            color: #6c757d;
            font-style: italic;
        }

        .content {
            padding: 30px;
            position: relative;
            z-index: 2;
        }

        .skill-assessment, .home-screen, .game-screen {
            display: none;
        }

        .skill-assessment.active, .home-screen.active, .game-screen.active {
            display: block;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .stat-card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #dee2e6;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: #495057;
            display: block;
        }

        .stat-label {
            color: #6c757d;
            font-size: 0.9em;
            margin-top: 5px;
        }

        .level-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin: 30px 0;
        }

        .level-btn {
            padding: 20px;
            background: #fff;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            cursor: pointer;
            text-align: center;
            transition: all 0.3s ease;
            position: relative;
        }

        .level-btn:hover {
            border-color: #007bff;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .level-btn.completed {
            border-color: #28a745;
            background: #d4edda;
        }

        .level-number {
            font-size: 1.5em;
            font-weight: bold;
            color: #495057;
        }

        .level-name {
            font-size: 0.9em;
            color: #6c757d;
            margin-top: 5px;
        }

        .sudoku-container {
            display: flex;
            justify-content: center;
            margin: 20px auto;
        }

        .sudoku-grid {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            border: 3px solid #000;
            border-radius: 6px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .sudoku-cell {
            width: 45px;
            height: 45px;
            background: #fff;
            border: 1px solid #ccc;
            text-align: center;
            font-size: 1.3em;
            font-weight: bold;
            color: #2c3e50;
            outline: none;
            transition: all 0.2s ease;
        }

        .sudoku-cell:focus {
            background: #e3f2fd;
            border-color: #2196F3;
            box-shadow: inset 0 0 0 2px #2196F3;
        }

        /* Right borders for 3x3 box separation */
        .sudoku-cell:nth-child(3n):not(:nth-child(9n)) {
            border-right: 3px solid #000;
        }

        /* Bottom borders for 3x3 box separation */
        .sudoku-cell:nth-child(n+19):nth-child(-n+27),
        .sudoku-cell:nth-child(n+46):nth-child(-n+54) {
            border-bottom: 3px solid #000;
        }

        .sudoku-cell.given {
            background: #f8f9fa;
            color: #000;
            font-weight: bold;
        }

        .sudoku-cell.user-input {
            background: #e8f5e8;
            color: #2e7d32;
        }

        .sudoku-cell.error {
            background: #ffebee;
            color: #d32f2f;
            animation: shake 0.3s ease-in-out;
        }

        .sudoku-cell.hint {
            background: #fff3e0;
            color: #f57c00;
            animation: pulse 0.5s ease-in-out;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-3px); }
            75% { transform: translateX(3px); }
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .game-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 24px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .btn:hover {
            background: #0056b3;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }

        .btn.secondary {
            background: #6c757d;
        }

        .btn.secondary:hover {
            background: #545b62;
        }

        .btn.success {
            background: #28a745;
        }

        .btn.success:hover {
            background: #1e7e34;
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            margin: 20px 0;
            font-size: 1.1em;
        }

        .timer, .score {
            background: #f8f9fa;
            padding: 10px 15px;
            border-radius: 6px;
            border: 1px solid #dee2e6;
        }

        .completion-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .completion-modal.active {
            display: flex;
        }

        .modal-content {
            background: #fff;
            padding: 40px;
            border-radius: 12px;
            text-align: center;
            max-width: 400px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .modal-content h2 {
            color: #28a745;
            margin-bottom: 20px;
            font-size: 2em;
        }

        .final-score {
            font-size: 1.5em;
            color: #007bff;
            margin: 20px 0;
            font-weight: bold;
        }

        @media (max-width: 600px) {
            .sudoku-cell {
                width: 35px;
                height: 35px;
                font-size: 1.1em;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .content {
                padding: 20px;
            }
        }

        @media (max-width: 400px) {
            .sudoku-cell {
                width: 30px;
                height: 30px;
                font-size: 1em;
            }
        }
    </style>
</head>
<body>
    <div class="paper-container">
        <div class="header">
            <h1>📖 Sudoku of the Day</h1>
            <div class="date-display" id="dateDisplay"></div>
        </div>
        
        <div class="content">
            <!-- Skill Assessment Screen -->
            <div class="skill-assessment active" id="skillAssessment">
                <h2 style="text-align: center; margin-bottom: 30px;">Welcome to Sudoku of the Day!</h2>
                <p style="text-align: center; margin-bottom: 30px; font-size: 1.1em; color: #6c757d;">
                    Tell us about your Sudoku experience so we can recommend the right difficulty for you:
                </p>
                <div class="level-grid" id="skillGrid">
                    <!-- Skill levels will be populated by JavaScript -->
                </div>
            </div>

            <!-- Home Screen -->
            <div class="home-screen" id="homeScreen">
                <div class="stats-grid">
                    <div class="stat-card">
                        <span class="stat-value" id="totalCompleted">0</span>
                        <div class="stat-label">Completed</div>
                    </div>
                    <div class="stat-card">
                        <span class="stat-value" id="averageScore">0</span>
                        <div class="stat-label">Avg Score</div>
                    </div>
                    <div class="stat-card">
                        <span class="stat-value" id="bestScore">0</span>
                        <div class="stat-label">Best Score</div>
                    </div>
                    <div class="stat-card">
                        <span class="stat-value" id="currentStreak">0</span>
                        <div class="stat-label">Streak</div>
                    </div>
                </div>
                
                <div class="game-controls">
                    <button class="btn" onclick="startTodaysPuzzle()" id="playTodayBtn">Play Today's Puzzle</button>
                    <button class="btn secondary" onclick="showSettings()">Settings</button>
                </div>
                
                <div style="text-align: center; margin-top: 20px;">
                    <p style="color: #6c757d;">Your skill level: <strong id="userSkillDisplay">Not set</strong></p>
                    <p style="color: #6c757d; font-size: 0.9em; margin-top: 5px;">Playing at: <strong id="currentDifficultyDisplay">Medium</strong> difficulty</p>
                    <button class="btn secondary" onclick="changeSkillLevel()" style="margin-top: 10px; padding: 8px 16px; font-size: 0.9em;">Change Skill Level</button>
                </div>
            </div>

            <!-- Game Screen -->
            <div class="game-screen" id="gameScreen">
                <div class="game-info">
                    <div class="timer">⏱️ <span id="timeDisplay">00:00</span></div>
                    <div class="score">⭐ <span id="scoreDisplay">1000</span></div>
                </div>
                
                <div style="text-align: center; margin-bottom: 10px; color: #6c757d; font-size: 0.9em;">
                    Puzzle Complexity: <span id="complexityDisplay">Calculating...</span> pts/min
                </div>
                
                <div class="sudoku-container">
                    <div class="sudoku-grid" id="sudokuGrid">
                        <!-- Grid will be populated by JavaScript -->
                    </div>
                </div>
                
                <div class="game-controls">
                    <button class="btn" onclick="getHint()">💡 Hint</button>
                    <button class="btn secondary" onclick="checkSolution()">✓ Check</button>
                    <button class="btn secondary" onclick="showHome()">Back to Home</button>
                </div>
                
                <div style="text-align: center; margin-top: 20px;">
                    <p>Level: <span id="currentLevel">1</span> | Mistakes: <span id="mistakeCount">0</span> | Hints: <span id="hintCount">0</span></p>
                </div>
            </div>
        </div>
    </div>

    <!-- Completion Modal -->
    <div class="completion-modal" id="completionModal">
        <div class="modal-content">
            <h2>🎉 Congratulations!</h2>
            <p>You completed today's puzzle!</p>
            <div class="final-score">Final Score: <span id="finalScore">0</span></div>
            <p>Time: <span id="finalTime">00:00</span></p>
            <div style="margin-top: 20px;">
                <button class="btn success" onclick="closeModal()">Awesome!</button>
            </div>
        </div>
    </div>

    <script>
        class SudokuOfTheDay {
            constructor() {
                this.sudoku = new Sudoku();
                this.currentPuzzle = null;
                this.originalPuzzle = null;
                this.solutionPath = null;
                this.currentLevel = 0;
                this.startTime = null;
                this.gameTimer = null;
                this.mistakes = 0;
                this.hintsUsed = 0;
                this.pointsPerMinute = 1000; // Will be calculated when puzzle is generated
                this.currentScore = 1000;
                
                this.levelNames = [
                    'Beginner', 'Easy', 'Medium', 
                    'Hard', 'Expert', 'Master'
                ];
                
                this.skillLevels = [
                    {
                        name: "Haven't played yet",
                        description: "I'm completely new to Sudoku",
                        recommended: 0 // Beginner
                    },
                    {
                        name: "Just started",
                        description: "I've tried a few puzzles but still learning",
                        recommended: 1 // Easy
                    },
                    {
                        name: "Getting comfortable",
                        description: "I can solve easy puzzles without much trouble",
                        recommended: 2 // Medium
                    },
                    {
                        name: "Pretty confident",
                        description: "I regularly solve medium difficulty puzzles",
                        recommended: 3 // Hard
                    },
                    {
                        name: "Very experienced",
                        description: "I can handle most challenging puzzles",
                        recommended: 4 // Expert
                    },
                    {
                        name: "Sudoku master",
                        description: "I live and breathe Sudoku!",
                        recommended: 5 // Master
                    }
                ];
                
                this.userSkillLevel = null;
                
                // Don't initialize immediately, wait for DOM
            }
            
            init() {
                console.log('=== INIT START ===');
                console.log('Current timestamp:', new Date().toISOString());
                console.log('Document readyState:', document.readyState);
                console.log('localStorage available:', typeof(Storage) !== "undefined");
                
                this.updateDateDisplay();
                
                // Load user skill level with extensive debugging
                console.log('=== LOADING SKILL LEVEL ===');
                this.userSkillLevel = this.getUserSkillLevel();
                console.log('Final userSkillLevel value:', this.userSkillLevel);
                console.log('Type of userSkillLevel:', typeof this.userSkillLevel);
                console.log('Is null?', this.userSkillLevel === null);
                console.log('Is undefined?', this.userSkillLevel === undefined);
                
                // Let's also check what's actually in localStorage right now
                console.log('=== LOCALSTORAGE INSPECTION ===');
                try {
                    console.log('localStorage length:', localStorage.length);
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        const value = localStorage.getItem(key);
                        console.log(`localStorage[${key}] = "${value}"`);
                    }
                } catch (e) {
                    console.error('Error inspecting localStorage:', e);
                }
                
                if (this.userSkillLevel !== null) {
                    console.log('=== SHOWING HOME SCREEN ===');
                    console.log('User skill level found:', this.userSkillLevel);
                    console.log('Recommended difficulty:', this.skillLevels[this.userSkillLevel].recommended);
                    this.showHome();
                } else {
                    console.log('=== SHOWING SKILL ASSESSMENT ===');
                    console.log('No skill level found, showing assessment');
                    this.showSkillAssessment();
                }
                
                this.loadStats();
                this.checkTodayCompletion();
                console.log('=== INIT COMPLETE ===');
            }
            
            getUserSkillLevel() {
                console.log('=== getUserSkillLevel() called ===');
                console.log('Checking localStorage for userSkillLevel...');
                
                // For GitHub Pages, localStorage should work fine
                try {
                    const saved = localStorage.getItem('userSkillLevel');
                    console.log('Raw value from localStorage:', saved);
                    console.log('Type of raw value:', typeof saved);
                    console.log('Value === null?', saved === null);
                    console.log('Value === "null"?', saved === "null");
                    console.log('Value === undefined?', saved === undefined);
                    
                    if (saved !== null && saved !== undefined && saved !== "null") {
                        const level = parseInt(saved);
                        console.log('Parsed to integer:', level);
                        console.log('parseInt result type:', typeof level);
                        console.log('isNaN check:', isNaN(level));
                        console.log('Range check (0-5):', level >= 0 && level <= 5);
                        
                        if (!isNaN(level) && level >= 0 && level <= 5) {
                            console.log('✅ Valid skill level found:', level);
                            return level;
                        } else {
                            console.log('❌ Invalid skill level, parsed value out of range');
                        }
                    } else {
                        console.log('❌ No valid value in localStorage');
                    }
                } catch (e) {
                    console.error('❌ Error accessing localStorage:', e);
                }
                
                console.log('❌ Returning null - no valid skill level found');
                return null;
            }
            
            saveUserSkillLevel(skillIndex) {
                console.log('=== saveUserSkillLevel() called ===');
                console.log('Input skillIndex:', skillIndex);
                console.log('Type of skillIndex:', typeof skillIndex);
                
                try {
                    const stringValue = skillIndex.toString();
                    console.log('Converting to string:', stringValue);
                    
                    // Test localStorage before saving
                    console.log('Testing localStorage write/read...');
                    localStorage.setItem('test', 'testvalue');
                    const testRead = localStorage.getItem('test');
                    console.log('Test write/read result:', testRead);
                    localStorage.removeItem('test');
                    
                    localStorage.setItem('userSkillLevel', stringValue);
                    console.log('✅ localStorage.setItem() called successfully');
                    
                    // Immediate verification
                    const verification = localStorage.getItem('userSkillLevel');
                    console.log('Immediate verification read:', verification);
                    console.log('Verification matches input?', verification === stringValue);
                    
                    // Test parsing the stored value
                    const testParse = parseInt(verification);
                    console.log('Test parse of stored value:', testParse);
                    console.log('Test parse matches original?', testParse === skillIndex);
                    
                    // Check localStorage length after saving
                    console.log('localStorage length after save:', localStorage.length);
                    
                    // List all localStorage keys
                    console.log('All localStorage keys after save:');
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        const value = localStorage.getItem(key);
                        console.log(`  ${key}: ${value}`);
                    }
                    
                } catch (e) {
                    console.error('❌ Error saving to localStorage:', e);
                }
            }
            
            updateDateDisplay() {
                const today = new Date();
                const options = { 
                    weekday: 'long', 
                    year: 'numeric', 
                    month: 'long', 
                    day: 'numeric' 
                };
                document.getElementById('dateDisplay').textContent = 
                    today.toLocaleDateString('en-US', options);
            }
            
            loadStats() {
                const stats = this.getStats();
                document.getElementById('totalCompleted').textContent = stats.totalCompleted;
                document.getElementById('averageScore').textContent = 
                    stats.totalCompleted > 0 ? Math.round(stats.totalScore / stats.totalCompleted) : 0;
                document.getElementById('bestScore').textContent = stats.bestScore;
                document.getElementById('currentStreak').textContent = stats.currentStreak;
            }
            
            getStats() {
                const defaultStats = {
                    totalCompleted: 0,
                    totalScore: 0,
                    bestScore: 0,
                    currentStreak: 0,
                    lastCompletedDate: null
                };
                
                try {
                    return JSON.parse(sessionStorage.getItem('sudokuStats') || JSON.stringify(defaultStats));
                } catch (e) {
                    return defaultStats;
                }
            }
            
            saveStats(stats) {
                try {
                    sessionStorage.setItem('sudokuStats', JSON.stringify(stats));
                } catch (e) {
                    // If sessionStorage fails, we'll just lose the stats for this session
                    console.log('Could not save stats');
                }
            }
            
            showSkillAssessment() {
                const skillGrid = document.getElementById('skillGrid');
                skillGrid.innerHTML = '';
                
                this.skillLevels.forEach((skill, index) => {
                    const button = document.createElement('div');
                    button.className = 'level-btn';
                    button.onclick = () => this.setUserSkillLevel(index);
                    
                    button.innerHTML = `
                        <div class="level-number">${index + 1}</div>
                        <div class="level-name">${skill.name}</div>
                        <div style="font-size: 0.8em; color: #6c757d; margin-top: 5px;">${skill.description}</div>
                    `;
                    
                    skillGrid.appendChild(button);
                });
                
                this.showScreen('skillAssessment');
            }
            
            setUserSkillLevel(skillIndex) {
                this.userSkillLevel = skillIndex;
                this.updateUserSkillDisplay();
                this.showHome();
            }
            
            updateUserSkillDisplay() {
                if (this.userSkillLevel !== null) {
                    document.getElementById('userSkillDisplay').textContent = 
                        this.skillLevels[this.userSkillLevel].name;
                    
                    const userLevelIndex = this.skillLevels[this.userSkillLevel].recommended;
                    document.getElementById('currentDifficultyDisplay').textContent = 
                        this.levelNames[userLevelIndex];
                }
            }
            
            startTodaysPuzzle() {
                // Check if today's puzzle is already completed
                if (this.isTodayCompleted()) {
                    const today = new Date().toDateString();
                    const scoreKey = `score_${today}`;
                    const savedScore = sessionStorage.getItem(scoreKey);
                    
                    alert(`You have already completed today's puzzle!\n\nYour score: ${savedScore || 'Unknown'}\n\nCome back tomorrow for a new puzzle!`);
                    return;
                }
                
                if (this.userSkillLevel !== null) {
                    const recommendedLevel = this.skillLevels[this.userSkillLevel].recommended;
                    this.startGame(recommendedLevel);
                } else {
                    // Fallback to medium if somehow skill level isn't set
                    this.startGame(2);
                }
            }
            
            showHome() {
                this.updateUserSkillDisplay();
                this.updatePlayButton();
                this.showScreen('homeScreen');
            }
            
            updatePlayButton() {
                const playBtn = document.getElementById('playTodayBtn');
                if (this.isTodayCompleted()) {
                    playBtn.textContent = '✅ Today\'s Puzzle Complete';
                    playBtn.classList.add('success');
                    playBtn.classList.remove('btn');
                } else {
                    playBtn.textContent = 'Play Today\'s Puzzle';
                    playBtn.classList.add('btn');
                    playBtn.classList.remove('success');
                }
            }
            
            showScreen(screenId) {
                console.log('=== showScreen() called ===');
                console.log('Switching to screen:', screenId);
                
                document.querySelectorAll('.skill-assessment, .home-screen, .level-select, .game-screen').forEach(screen => {
                    const wasActive = screen.classList.contains('active');
                    screen.classList.remove('active');
                    if (wasActive) {
                        console.log('Hiding screen:', screen.className);
                    }
                });
                
                const targetScreen = document.getElementById(screenId);
                if (targetScreen) {
                    targetScreen.classList.add('active');
                    console.log('✅ Showing screen:', screenId);
                } else {
                    console.error('❌ Screen not found:', screenId);
                }
            }
            
            isTodayCompleted() {
                const today = new Date().toDateString();
                const completedKey = `completed_${today}`;
                try {
                    return sessionStorage.getItem(completedKey) === 'true';
                } catch (e) {
                    return false;
                }
            }
            
            markTodayCompleted(score) {
                const today = new Date().toDateString();
                const completedKey = `completed_${today}`;
                const scoreKey = `score_${today}`;
                try {
                    sessionStorage.setItem(completedKey, 'true');
                    sessionStorage.setItem(scoreKey, score.toString());
                } catch (e) {
                    console.log('Could not save completion status');
                }
            }
            
            isLevelCompletedToday(level) {
                // This method is no longer used since we only track one completion per day
                return this.isTodayCompleted();
            }
            
            markLevelCompleted(level, score) {
                // Updated to use the new single completion per day system
                this.markTodayCompleted(score);
            }
            
            checkTodayCompletion() {
                // Check if today's puzzle was completed
                if (this.isTodayCompleted()) {
                    // Update completion streak
                    this.updateStreak();
                }
            }
            
            updateStreak() {
                const stats = this.getStats();
                const today = new Date().toDateString();
                const yesterday = new Date(Date.now() - 86400000).toDateString();
                
                if (stats.lastCompletedDate === yesterday) {
                    stats.currentStreak += 1;
                } else if (stats.lastCompletedDate !== today) {
                    stats.currentStreak = 1;
                }
                
                stats.lastCompletedDate = today;
                this.saveStats(stats);
            }
            
            calculatePointsPerMinute(solutionPath) {
                if (!solutionPath || solutionPath.length === 0) {
                    return 1000; // Fallback for unsolvable puzzles
                }
                
                let totalPoints = 0;
                let consecutiveGuesses = 0;
                
                for (const step of solutionPath) {
                    const [technique, position, value] = step;
                    
                    switch (technique) {
                        case "HIDDEN SINGLE (BOX)":
                            totalPoints += 100; // Easiest - only check 9 cells in box
                            consecutiveGuesses = 0;
                            break;
                            
                        case "HIDDEN SINGLE (LINE)":
                            totalPoints += 150; // Medium - check row/column (9 cells) but requires line thinking
                            consecutiveGuesses = 0;
                            break;
                            
                        case "NAKED SINGLE":
                            totalPoints += 200; // Hardest - requires elimination across row, column AND box
                            consecutiveGuesses = 0;
                            break;
                            
                        case "GUESS":
                            consecutiveGuesses++;
                            // Exponential increase for consecutive guesses
                            const guessPoints = 500 * Math.pow(1.5, consecutiveGuesses - 1);
                            totalPoints += guessPoints;
                            break;
                            
                        default:
                            // Any other advanced techniques
                            totalPoints += 300;
                            consecutiveGuesses = 0;
                            break;
                    }
                }
                
                // Ensure minimum points per minute
                return Math.max(totalPoints, 500);
            }
            
            startGame(level) {
                this.currentLevel = level;
                this.mistakes = 0;
                this.hintsUsed = 0;
                
                // Generate today's puzzle for this level using the real Sudoku class
                const today = new Date();
                this.currentPuzzle = this.sudoku.generateDailySudoku(level, today, "matrix");
                this.originalPuzzle = this.currentPuzzle.map(row => [...row]);
                
                // Generate solution path for scoring
                this.solutionPath = this.sudoku.solvePath(this.currentPuzzle, 0);
                
                // Calculate points per minute based on puzzle complexity
                this.pointsPerMinute = this.calculatePointsPerMinute(this.solutionPath);
                
                this.createSudokuGrid();
                this.startTimer();
                this.updateGameInfo();
                
                this.showScreen('gameScreen');
            }
            

            
            createSudokuGrid() {
                const grid = document.getElementById('sudokuGrid');
                grid.innerHTML = '';
                
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        const cell = document.createElement('input');
                        cell.type = 'text';
                        cell.className = 'sudoku-cell';
                        cell.maxLength = 1;
                        cell.dataset.row = row;
                        cell.dataset.col = col;
                        
                        const value = this.currentPuzzle[row][col];
                        if (value !== 0) {
                            cell.value = value;
                            cell.classList.add('given');
                            cell.readOnly = true;
                        } else {
                            cell.addEventListener('input', (e) => this.handleCellInput(e));
                            cell.addEventListener('keydown', (e) => this.handleKeyDown(e));
                        }
                        
                        grid.appendChild(cell);
                    }
                }
            }
            
            handleCellInput(event) {
                const cell = event.target;
                const value = cell.value;
                
                // Only allow numbers 1-9
                if (!/^[1-9]$/.test(value)) {
                    cell.value = '';
                    return;
                }
                
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                this.currentPuzzle[row][col] = parseInt(value);
                
                // Check if the move is valid
                if (this.isValidMove(row, col, parseInt(value))) {
                    cell.classList.remove('error');
                    cell.classList.add('user-input');
                } else {
                    cell.classList.add('error');
                    this.mistakes++;
                    this.updateScore();
                }
                
                this.updateGameInfo();
                
                // Check if puzzle is complete
                if (this.isPuzzleComplete()) {
                    this.completeGame();
                }
            }
            
            handleKeyDown(event) {
                const cell = event.target;
                
                // Allow backspace/delete to clear cell
                if (event.key === 'Backspace' || event.key === 'Delete') {
                    const row = parseInt(cell.dataset.row);
                    const col = parseInt(cell.dataset.col);
                    this.currentPuzzle[row][col] = 0;
                    cell.classList.remove('user-input', 'error', 'hint');
                }
                
                // Navigation with arrow keys
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                let newRow = row, newCol = col;
                
                switch(event.key) {
                    case 'ArrowUp':
                        newRow = Math.max(0, row - 1);
                        break;
                    case 'ArrowDown':
                        newRow = Math.min(8, row + 1);
                        break;
                    case 'ArrowLeft':
                        newCol = Math.max(0, col - 1);
                        break;
                    case 'ArrowRight':
                        newCol = Math.min(8, col + 1);
                        break;
                }
                
                if (newRow !== row || newCol !== col) {
                    event.preventDefault();
                    const newCell = document.querySelector(`[data-row="${newRow}"][data-col="${newCol}"]`);
                    if (newCell && !newCell.readOnly) {
                        newCell.focus();
                    }
                }
            }
            
            isValidMove(row, col, value) {
                // Create a temporary grid for validation
                const tempGrid = this.currentPuzzle.map(r => [...r]);
                tempGrid[row][col] = 0; // Temporarily clear the cell
                
                // Check row
                for (let c = 0; c < 9; c++) {
                    if (tempGrid[row][c] === value) return false;
                }
                
                // Check column
                for (let r = 0; r < 9; r++) {
                    if (tempGrid[r][col] === value) return false;
                }
                
                // Check 3x3 box
                const boxRow = Math.floor(row / 3) * 3;
                const boxCol = Math.floor(col / 3) * 3;
                for (let r = boxRow; r < boxRow + 3; r++) {
                    for (let c = boxCol; c < boxCol + 3; c++) {
                        if (tempGrid[r][c] === value) return false;
                    }
                }
                
                return true;
            }
            
            getHint() {
                const hint = this.sudoku.hint(this.currentPuzzle, 0);
                if (hint) {
                    const [technique, [row, col], value] = hint;
                    const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                    if (cell && !cell.readOnly) {
                        cell.value = value;
                        cell.classList.add('hint');
                        this.currentPuzzle[row][col] = value;
                        this.hintsUsed++;
                        this.updateScore();
                        this.updateGameInfo();
                        
                        if (this.isPuzzleComplete()) {
                            this.completeGame();
                        }
                    }
                }
            }
            
            checkSolution() {
                let hasErrors = false;
                const cells = document.querySelectorAll('.sudoku-cell');
                
                cells.forEach(cell => {
                    if (!cell.readOnly && cell.value) {
                        const row = parseInt(cell.dataset.row);
                        const col = parseInt(cell.dataset.col);
                        const value = parseInt(cell.value);
                        
                        if (!this.isValidMove(row, col, value)) {
                            cell.classList.add('error');
                            hasErrors = true;
                        } else {
                            cell.classList.remove('error');
                        }
                    }
                });
                
                if (hasErrors) {
                    alert('There are errors in your solution. Check the highlighted cells.');
                } else {
                    alert('Looking good so far! Keep going!');
                }
            }
            
            isPuzzleComplete() {
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        if (this.currentPuzzle[row][col] === 0) {
                            return false;
                        }
                    }
                }
                return true;
            }
            
            completeGame() {
                this.stopTimer();
                const finalScore = Math.max(0, this.currentScore);
                
                // Update stats
                const stats = this.getStats();
                stats.totalCompleted++;
                stats.totalScore += finalScore;
                if (finalScore > stats.bestScore) {
                    stats.bestScore = finalScore;
                }
                this.saveStats(stats);
                
                // Mark level as completed
                this.markLevelCompleted(this.currentLevel, finalScore);
                
                // Show completion modal
                document.getElementById('finalScore').textContent = Math.round(finalScore);
                document.getElementById('finalTime').textContent = this.getTimeString();
                document.getElementById('completionModal').classList.add('active');
                
                this.loadStats();
            }
            
            startTimer() {
                this.startTime = Date.now();
                this.gameTimer = setInterval(() => {
                    this.updateTimer();
                    this.updateScore();
                }, 1000);
            }
            
            stopTimer() {
                if (this.gameTimer) {
                    clearInterval(this.gameTimer);
                    this.gameTimer = null;
                }
            }
            
            updateTimer() {
                const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
                document.getElementById('timeDisplay').textContent = this.formatTime(elapsed);
            }
            
            formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }
            
            getTimeString() {
                const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
                return this.formatTime(elapsed);
            }
            
            updateScore() {
                const elapsedMinutes = (Date.now() - this.startTime) / 60000; // Convert to minutes
                
                if (elapsedMinutes <= 0) {
                    this.currentScore = this.pointsPerMinute;
                    document.getElementById('scoreDisplay').textContent = Math.round(this.currentScore);
                    return;
                }
                
                // Base score: points per minute divided by actual minutes
                const baseScore = this.pointsPerMinute / elapsedMinutes;
                
                // Apply penalties
                const mistakePenalty = Math.pow(0.9, this.mistakes);
                const hintPenalty = Math.pow(0.8, this.hintsUsed);
                
                // Final score calculation
                this.currentScore = baseScore * mistakePenalty * hintPenalty;
                
                document.getElementById('scoreDisplay').textContent = Math.round(this.currentScore);
            }
            
            updateGameInfo() {
                document.getElementById('currentLevel').textContent = this.currentLevel + 1;
                document.getElementById('mistakeCount').textContent = this.mistakes;
                document.getElementById('hintCount').textContent = this.hintsUsed;
                document.getElementById('complexityDisplay').textContent = Math.round(this.pointsPerMinute);
            }
        }
        
        // Screen navigation functions
        function showHome() {
            if (game) {
                game.showHome();
            }
        }
        
        function startTodaysPuzzle() {
            if (game) {
                game.startTodaysPuzzle();
            }
        }
        
        function changeSkillLevel() {
            if (game) {
                game.showSkillAssessment();
            }
        }
        
        function closeModal() {
            document.getElementById('completionModal').classList.remove('active');
            showHome();
        }
        
        function showSettings() {
            alert('Settings feature coming soon!\n\nYou can change your skill level from the home screen.');
        }
        
        function getHint() {
            if (game) {
                game.getHint();
            }
        }
        
        function checkSolution() {
            if (game) {
                game.checkSolution();
            }
        }
        
        // Initialize the game
        let game;
        
        // Add some global debugging
        console.log('=== SCRIPT LOADING ===');
        console.log('Script timestamp:', new Date().toISOString());
        console.log('User agent:', navigator.userAgent);
        console.log('localStorage supported:', typeof(Storage) !== "undefined");
        console.log('Current URL:', window.location.href);
        console.log('Current domain:', window.location.hostname);
        console.log('Protocol:', window.location.protocol);
        
        // Test localStorage immediately on script load
        console.log('=== IMMEDIATE LOCALSTORAGE TEST ===');
        try {
            const testKey = 'immediateTest_' + Date.now();
            const testValue = 'testValue123';
            localStorage.setItem(testKey, testValue);
            const readBack = localStorage.getItem(testKey);
            console.log('Immediate localStorage test - saved:', testValue, 'read:', readBack);
            console.log('Immediate test success:', readBack === testValue);
            localStorage.removeItem(testKey);
        } catch (e) {
            console.error('Immediate localStorage test failed:', e);
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            console.log('=== DOMContentLoaded EVENT ===');
            console.log('Event timestamp:', new Date().toISOString());
            console.log('Creating game instance...');
            game = new SudokuOfTheDay();
            console.log('Game instance created, calling init...');
            game.init();
        });
        
        // Also try immediate initialization in case DOMContentLoaded already fired
        if (document.readyState === 'loading') {
            console.log('Document still loading, waiting for DOMContentLoaded...');
        } else {
            console.log('=== IMMEDIATE INITIALIZATION ===');
            console.log('Document already loaded, initializing immediately...');
            console.log('Document readyState:', document.readyState);
            setTimeout(() => {
                console.log('Creating game instance immediately...');
                game = new SudokuOfTheDay();
                console.log('Game instance created, calling init...');
                game.init();
            }, 10); // Small delay to ensure everything is ready
        }
        
        // Add a listener for when localStorage changes (if another tab modifies it)
        window.addEventListener('storage', (e) => {
            console.log('=== STORAGE EVENT ===');
            console.log('Storage changed:', e.key, 'from', e.oldValue, 'to', e.newValue);
        });
    </script>
</body>
</html>
