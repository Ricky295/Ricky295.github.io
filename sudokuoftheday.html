Okay, I've analyzed the provided HTML/CSS/JavaScript code. The issue you're describing – the Sudoku grid not appearing perfectly square and potentially having extra space below – is likely due to a combination of factors related to how the grid cell heights are calculated and rendered, especially with the default font size and the candidate mode's smaller font.

Here's the modified HTML code. The key changes are:
1.  **Ensured Explicit Square Dimensions:** Set explicit `width` and `height` on the `.cell` class to make them perfectly square (38px by 38px).
2.  **Adjusted Line Height:** Used `line-height` equal to the cell height to vertically center the main number.
3.  **Candidate Mode Adjustments:** Ensured the candidate grid and cells fill the parent cell and adjusted padding/margins.
4.  **Minor Padding Adjustment:** Slightly reduced padding in the grid container to better fit the explicitly sized cells.

These changes should make the grid visually square and prevent the extra height issue caused by the default line height of the numbers.

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Daily Sudoku</title>
    <script src="sudoku.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Times New Roman', serif;
            background: #f5f2e8;
            color: #2c2c2c;
            min-height: 100vh;
            background-image: 
                radial-gradient(circle at 20px 50px, #ddd 1px, transparent 1px),
                radial-gradient(circle at 40px 20px, #ddd 1px, transparent 1px);
            background-size: 80px 80px;
            transition: all 0.3s ease;
        }
        body.night-mode {
            background: #1a1a1a;
            color: #e0e0e0;
            background-image: 
                radial-gradient(circle at 20px 50px, #333 1px, transparent 1px),
                radial-gradient(circle at 40px 20px, #333 1px, transparent 1px);
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: white;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
            min-height: 100vh;
            position: relative;
            transition: all 0.3s ease;
        }
        body.night-mode .container {
            background: #2d2d2d;
            box-shadow: 0 0 20px rgba(0,0,0,0.3);
        }
        .paper-texture {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                repeating-linear-gradient(
                    0deg,
                    transparent,
                    transparent 24px,
                    #e8e8e8 24px,
                    #e8e8e8 26px
                );
            pointer-events: none;
            opacity: 0.3;
            transition: all 0.3s ease;
        }
        body.night-mode .paper-texture {
            background: 
                repeating-linear-gradient(
                    0deg,
                    transparent,
                    transparent 24px,
                    #404040 24px,
                    #404040 26px
                );
            opacity: 0.2;
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
            position: relative;
            z-index: 1;
        }
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
            transition: color 0.3s ease;
        }
        body.night-mode .header h1 {
            color: #e0e0e0;
        }
        .difficulty-selector {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 10px;
            margin: 20px 0;
            position: relative;
            z-index: 1;
        }
        .difficulty-btn {
            padding: 10px 15px;
            border: 2px solid #333;
            background: white;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
            transition: all 0.3s;
            position: relative;
        }
        body.night-mode .difficulty-btn {
            border-color: #666;
            background: #404040;
            color: #e0e0e0;
        }
        .difficulty-btn:hover {
            background: #f0f0f0;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        body.night-mode .difficulty-btn:hover {
            background: #505050;
        }
        .difficulty-btn.active {
            background: #333;
            color: white;
        }
        body.night-mode .difficulty-btn.active {
            background: #666;
            color: white;
        }
        /* Medal borders */
        .difficulty-btn.bronze { border-color: #cd7f32; border-width: 4px; }
        .difficulty-btn.silver { border-color: #c0c0c0; border-width: 4px; }
        .difficulty-btn.gold { border-color: #ffd700; border-width: 4px; }
        .difficulty-btn.platinum { border-color: #e5e4e2; border-width: 4px; box-shadow: 0 0 10px rgba(229, 228, 226, 0.5); }
        .game-area {
            display: flex;
            gap: 30px;
            justify-content: center;
            position: relative;
            z-index: 1;
            flex-wrap: wrap;
        }
        .sudoku-grid {
            display: grid;
            grid-template-columns: repeat(9, 40px);
            grid-template-rows: repeat(9, 40px);
            gap: 1px;
            background: #333;
            border: 3px solid #333;
            padding: 1px; /* Reduced padding slightly */
        }
        body.night-mode .sudoku-grid {
            background: #555;
            border-color: #555;
        }
        .cell {
            /* Explicitly set width and height to make them square */
            width: 38px; 
            height: 38px; 
            background: white;
            color: #333;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s;
            user-select: none;
            position: relative;
            /* Use line-height equal to height for vertical centering */
            line-height: 38px; 
            overflow: hidden; /* Prevent overflow if content is slightly larger */
        }
        body.night-mode .cell {
            background: #404040;
            color: #e0e0e0;
        }
        .cell.candidate-mode {
            font-size: 10px;
            padding: 0; /* Reset padding for candidate mode */
            align-items: stretch; /* Allow children to fill the cell */
            justify-content: stretch;
            line-height: normal; /* Reset line-height for candidate mode */
        }
        .candidates-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            width: 100%;
            height: 100%;
            gap: 1px;
        }
        .candidate-cell {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            font-weight: normal;
            color: #666;
            padding: 0; /* Remove padding */
            margin: 0; /* Remove margin */
        }
        body.night-mode .candidate-cell {
            color: #999;
        }
        .candidate-cell.active {
            color: #333;
            font-weight: bold;
        }
        body.night-mode .candidate-cell.active {
            color: #e0e0e0;
            font-weight: bold;
        }
        .cell:hover {
            background: #e8f4fd;
        }
        body.night-mode .cell:hover {
            background: #505050;
        }
        .cell.selected {
            background: #b3d9ff !important;
        }
        body.night-mode .cell.selected {
            background: #4a4a7a !important;
        }
        .cell.given {
            background: #f0f0f0;
            color: #333;
            cursor: default;
        }
        body.night-mode .cell.given {
            background: #505050;
            color: #e0e0e0;
        }
        .cell.error {
            background: #ffebee !important;
            color: #d32f2f;
        }
        body.night-mode .cell.error {
            background: #4d1f1f !important;
            color: #ff6b6b;
        }
        .cell.hint {
            background: #e8f5e8 !important;
            color: #2e7d32;
        }
        body.night-mode .cell.hint {
            background: #1f4d1f !important;
            color: #4caf50;
        }
        /* Thick borders for 3x3 boxes - using correct nth-child formulas */
        .cell:nth-child(3n):not(.cell:nth-child(9n)) { border-right: 2px solid #333; }
        .cell:nth-child(6n):not(.cell:nth-child(9n)) { border-right: 2px solid #333; }
        .cell:nth-child(n+19):nth-child(-n+27) { border-bottom: 2px solid #333; }
        .cell:nth-child(n+46):nth-child(-n+54) { border-bottom: 2px solid #333; }
        body.night-mode .cell:nth-child(3n):not(.cell:nth-child(9n)) { border-right-color: #777; }
        body.night-mode .cell:nth-child(6n):not(.cell:nth-child(9n)) { border-right-color: #777; }
        body.night-mode .cell:nth-child(n+19):nth-child(-n+27) { border-bottom-color: #777; }
        body.night-mode .cell:nth-child(n+46):nth-child(-n+54) { border-bottom-color: #777; }
        .game-controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            min-width: 200px;
        }
        .number-pad {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
        }
        .number-btn {
            padding: 12px;
            border: 2px solid #333;
            background: white;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.2s;
        }
        body.night-mode .number-btn {
            border-color: #666;
            background: #404040;
            color: #e0e0e0;
        }
        .number-btn:hover {
            background: #f0f0f0;
            transform: scale(1.05);
        }
        body.night-mode .number-btn:hover {
            background: #505050;
        }
        .action-btn {
            padding: 12px;
            border: 2px solid #333;
            background: white;
            cursor: pointer;
            font-weight: bold;
            margin-bottom: 5px;
            transition: all 0.2s;
        }
        body.night-mode .action-btn {
            border-color: #666;
            background: #404040;
            color: #e0e0e0;
        }
        .action-btn:hover {
            background: #f0f0f0;
            transform: translateY(-1px);
        }
        body.night-mode .action-btn:hover {
            background: #505050;
        }
        .action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .stats {
            background: rgba(255,255,255,0.8);
            padding: 15px;
            border: 2px solid #333;
            margin-top: 20px;
            transition: all 0.3s ease;
            position: relative;
            z-index: 1;
        }
        body.night-mode .stats {
            background: rgba(45, 45, 45, 0.9);
            border-color: #666;
            color: #e0e0e0;
        }
        .stats h3 {
            margin-bottom: 10px;
            text-align: center;
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
        }
        .modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px;
            border: 3px solid #333;
            max-width: 500px;
            text-align: center;
            font-family: 'Courier New', monospace;
        }
        body.night-mode .modal-content {
            background: #2d2d2d;
            color: #e0e0e0;
            border-color: #666;
        }
        .modal-content h2 {
            margin-bottom: 20px;
            font-size: 2em;
        }
        .score-breakdown {
            text-align: left;
            margin: 20px 0;
            font-size: 16px;
            line-height: 1.8;
        }
        .breakdown-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding: 5px 0;
        }
        .breakdown-label {
            font-weight: bold;
            width: 80px;
        }
        .breakdown-time,
        .breakdown-count {
            flex: 1;
            text-align: left;
            margin-left: 20px;
        }
        .breakdown-score {
            font-weight: bold;
            min-width: 80px;
            text-align: right;
        }
        .breakdown-score.positive {
            color: #2e7d32;
        }
        .breakdown-score.negative {
            color: #d32f2f;
        }
        body.night-mode .breakdown-score.positive {
            color: #4caf50;
        }
        body.night-mode .breakdown-score.negative {
            color: #f44336;
        }
        .final-score-row {
            border-top: 2px solid #333;
            margin-top: 15px;
            padding-top: 10px;
            font-size: 18px;
            font-weight: bold;
        }
        body.night-mode .final-score-row {
            border-top-color: #666;
        }
        .breakdown-final {
            flex: 1;
            text-align: left;
            margin-left: 20px;
            font-size: 20px;
        }
        .breakdown-medal {
            font-size: 14px;
            color: #666;
            min-width: 80px;
            text-align: right;
        }
        body.night-mode .breakdown-medal {
            color: #999;
        }
        .modal-content button {
            padding: 10px 20px;
            border: 2px solid #333;
            background: white;
            cursor: pointer;
            font-weight: bold;
            margin: 5px;
        }
        body.night-mode .modal-content button {
            border-color: #666;
            background: #404040;
            color: #e0e0e0;
        }
        @media (max-width: 768px) {
            .game-area {
                flex-direction: column;
                align-items: center;
            }
            .sudoku-grid {
                grid-template-columns: repeat(9, 35px);
                grid-template-rows: repeat(9, 35px);
            }
            .cell {
                width: 33px; /* Adjust for smaller screens */
                height: 33px;
                font-size: 16px;
                line-height: 33px; /* Match height */
            }
            .cell.candidate-mode {
                font-size: 8px; /* Adjust candidate font size */
            }
            .candidate-cell {
                font-size: 7px; /* Adjust candidate cell font size */
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="paper-texture"></div>
        <div class="header">
            <h1>Daily Sudoku</h1>
            <div class="difficulty-selector">
                <button class="difficulty-btn" data-difficulty="0">Easy</button>
                <button class="difficulty-btn" data-difficulty="1">Medium</button>
                <button class="difficulty-btn" data-difficulty="2">Hard</button>
                <button class="difficulty-btn" data-difficulty="3">Vicious</button>
                <button class="difficulty-btn" data-difficulty="4">Fiendish</button>
                <button class="difficulty-btn" data-difficulty="5">Diabolical</button>
                <button class="action-btn" id="night-mode-btn">🌙 Night</button>
            </div>
        </div>
        <div class="game-area">
            <div class="sudoku-grid" id="sudoku-grid"></div>
            <div class="game-controls">
                <div class="number-pad">
                    <button class="number-btn" data-number="1">1</button>
                    <button class="number-btn" data-number="2">2</button>
                    <button class="number-btn" data-number="3">3</button>
                    <button class="number-btn" data-number="4">4</button>
                    <button class="number-btn" data-number="5">5</button>
                    <button class="number-btn" data-number="6">6</button>
                    <button class="number-btn" data-number="7">7</button>
                    <button class="number-btn" data-number="8">8</button>
                    <button class="number-btn" data-number="9">9</button>
                </div>
                <button class="action-btn" id="clear-btn">Clear</button>
                <button class="action-btn" id="hint-btn">Hint</button>
                <button class="action-btn" id="candidate-mode-btn">Candidates</button>
                <button class="action-btn" id="new-game-btn">New Game</button>
            </div>
        </div>
        <div class="stats">
            <h3>Game Statistics</h3>
            <div class="stat-row">
                <span>Time:</span>
                <span id="timer">00:00</span>
            </div>
            <div class="stat-row">
                <span>Hints Used:</span>
                <span id="hints-count">0</span>
            </div>
            <div class="stat-row">
                <span>Mistakes:</span>
                <span id="mistakes-count">0</span>
            </div>
            <div class="stat-row">
                <span>Score:</span>
                <span id="current-score">0</span>
            </div>
            <div class="stat-row">
                <span>Best Score:</span>
                <span id="best-score">0</span>
            </div>
        </div>
    </div>
    <div class="modal" id="complete-modal">
        <div class="modal-content">
            <h2>CONGRATULATIONS!</h2>
            <div class="score-breakdown">
                <div class="breakdown-row">
                    <span class="breakdown-label">Time:</span>
                    <span class="breakdown-time" id="final-time"></span>
                    <span class="breakdown-score positive" id="time-score">+0</span>
                </div>
                <div class="breakdown-row">
                    <span class="breakdown-label">Hints:</span>
                    <span class="breakdown-count" id="final-hints">0</span>
                    <span class="breakdown-score negative" id="hint-penalty">-0</span>
                </div>
                <div class="breakdown-row">
                    <span class="breakdown-label">Mistakes:</span>
                    <span class="breakdown-count" id="final-mistakes">0</span>
                    <span class="breakdown-score negative" id="mistake-penalty">-0</span>
                </div>
                <div class="breakdown-row final-score-row">
                    <span class="breakdown-label">Score:</span>
                    <span class="breakdown-final" id="final-score">0</span>
                    <span class="breakdown-medal" id="medal-text"></span>
                </div>
            </div>
            <button onclick="closeModal()">Continue</button>
        </div>
    </div>
    <script>
        class SudokuGame {
            constructor() {
                this.sudoku = new Sudoku();
                this.currentPuzzle = null;
                this.solution = null;
                this.currentGrid = null;
                this.candidates = null; // 9x9 array of sets
                this.selectedCell = null;
                this.startTime = null;
                this.timerInterval = null;
                this.hintsUsed = 0;
                this.mistakes = 0;
                this.currentDifficulty = 0;
                this.puzzleRating = 0;
                this.candidateMode = false;
                this.nightMode = false;
                this.initializeGame();
                this.bindEvents();
                this.loadProgress();
                this.updateMedalBorders();
                this.loadNightMode();
            }
            initializeGame() {
                this.createGrid();
                this.generateNewPuzzle();
            }
            createGrid() {
                const grid = document.getElementById('sudoku-grid');
                grid.innerHTML = '';
                for (let i = 0; i < 81; i++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.index = i;
                    cell.addEventListener('click', () => this.selectCell(i));
                    grid.appendChild(cell);
                }
            }
            generateNewPuzzle() {
                const today = new Date();
                this.currentPuzzle = this.sudoku.generateDailySudoku(this.currentDifficulty, today, "matrix");
                // Get solution
                this.solution = this.sudoku.deepCopy(this.currentPuzzle);
                this.sudoku.solveMatrix(this.solution);
                // Calculate puzzle rating
                this.calculatePuzzleRating();
                // Initialize current grid and candidates
                this.currentGrid = this.sudoku.deepCopy(this.currentPuzzle);
                this.initializeCandidates();
                this.renderGrid();
                this.startTimer();
                this.resetStats();
            }
            initializeCandidates() {
                this.candidates = [];
                for (let row = 0; row < 9; row++) {
                    this.candidates[row] = [];
                    for (let col = 0; col < 9; col++) {
                        this.candidates[row][col] = new Set();
                    }
                }
            }
            calculateCandidatesForCell(row, col) {
                if (this.currentGrid[row][col] !== 0) {
                    return new Set();
                }
                const candidates = new Set([1, 2, 3, 4, 5, 6, 7, 8, 9]);
                // Remove candidates from row
                for (let c = 0; c < 9; c++) {
                    if (this.currentGrid[row][c] !== 0) {
                        candidates.delete(this.currentGrid[row][c]);
                    }
                }
                // Remove candidates from column
                for (let r = 0; r < 9; r++) {
                    if (this.currentGrid[r][col] !== 0) {
                        candidates.delete(this.currentGrid[r][col]);
                    }
                }
                // Remove candidates from 3x3 box
                const boxRow = 3 * Math.floor(row / 3);
                const boxCol = 3 * Math.floor(col / 3);
                for (let r = boxRow; r < boxRow + 3; r++) {
                    for (let c = boxCol; c < boxCol + 3; c++) {
                        if (this.currentGrid[r][c] !== 0) {
                            candidates.delete(this.currentGrid[r][c]);
                        }
                    }
                }
                return candidates;
            }
            toggleCandidateMode() {
                this.candidateMode = !this.candidateMode;
                const btn = document.getElementById('candidate-mode-btn');
                btn.textContent = this.candidateMode ? 'Exit Candidates' : 'Candidates';
                btn.style.background = this.candidateMode ? '#e0e0e0' : 'white';
            }
            calculatePuzzleRating() {
                const solvePath = this.sudoku.solvePath(this.currentPuzzle, 0);
                if (!solvePath) {
                    this.puzzleRating = 10000; // Default rating
                    return;
                }
                let rating = 0;
                let consecutiveGuesses = 0;
                for (const [technique, pos, value] of solvePath) {
                    if (technique === "HIDDEN SINGLE (BOX)") {
                        rating += 10000;
                        consecutiveGuesses = 0;
                    } else if (technique === "HIDDEN SINGLE (LINE)") {
                        rating += 15000;
                        consecutiveGuesses = 0;
                    } else if (technique === "NAKED SINGLE") {
                        rating += 20000;
                        consecutiveGuesses = 0;
                    } else if (technique === "GUESS") {
                        consecutiveGuesses++;
                        rating += 50000 * Math.pow(1.5, consecutiveGuesses - 1);
                    }
                }
                this.puzzleRating = Math.floor(rating);
            }
            renderGrid() {
                const cells = document.querySelectorAll('.cell');
                cells.forEach((cell, index) => {
                    const row = Math.floor(index / 9);
                    const col = index % 9;
                    const value = this.currentGrid[row][col];
                    cell.className = 'cell';
                    if (value !== 0) {
                        // Cell has a number
                        cell.textContent = value;
                        cell.classList.remove('candidate-mode');
                        if (this.currentPuzzle[row][col] !== 0) {
                            cell.classList.add('given');
                        }
                    } else {
                        // Empty cell - show candidates if any
                        const cellCandidates = this.candidates[row][col];
                        if (cellCandidates.size > 0) {
                            cell.classList.add('candidate-mode');
                            cell.innerHTML = this.renderCandidates(cellCandidates);
                        } else {
                            cell.textContent = '';
                            cell.classList.remove('candidate-mode');
                        }
                    }
                });
            }
            renderCandidates(candidates) {
                let html = '<div class="candidates-grid">';
                for (let num = 1; num <= 9; num++) {
                    const isActive = candidates.has(num);
                    html += `<div class="candidate-cell ${isActive ? 'active' : ''}">${isActive ? num : ''}</div>`;
                }
                html += '</div>';
                return html;
            }
            selectCell(index) {
                const cells = document.querySelectorAll('.cell');
                cells.forEach(cell => cell.classList.remove('selected'));
                this.selectedCell = index;
                cells[index].classList.add('selected');
            }
            placeNumber(number) {
                if (this.selectedCell === null) return;
                const row = Math.floor(this.selectedCell / 9);
                const col = this.selectedCell % 9;
                if (this.currentPuzzle[row][col] !== 0) return; // Can't change given numbers
                const cell = document.querySelectorAll('.cell')[this.selectedCell];
                cell.classList.remove('error', 'hint');
                if (this.candidateMode) {
                    // Toggle candidate
                    if (this.candidates[row][col].has(number)) {
                        this.candidates[row][col].delete(number);
                    } else {
                        this.candidates[row][col].add(number);
                    }
                } else {
                    // Place number
                    this.currentGrid[row][col] = number;
                    this.candidates[row][col].clear(); // Clear candidates when placing number
                    // Update candidates in related cells
                    if (number !== 0) {
                        this.updateRelatedCandidates(row, col, number);
                        if (number !== this.solution[row][col]) {
                            cell.classList.add('error');
                            this.mistakes++;
                            this.updateStats();
                        } else {
                            this.checkCompletion();
                        }
                    }
                }
                this.renderGrid();
            }
            toggleNightMode() {
                this.nightMode = !this.nightMode;
                document.body.classList.toggle('night-mode', this.nightMode);
                const btn = document.getElementById('night-mode-btn');
                btn.textContent = this.nightMode ? '☀️ Day' : '🌙 Night';
                // Save preference
                localStorage.setItem('night-mode', this.nightMode.toString());
            }
            loadNightMode() {
                const savedMode = localStorage.getItem('night-mode');
                if (savedMode === 'true') {
                    this.nightMode = true;
                    document.body.classList.add('night-mode');
                    const btn = document.getElementById('night-mode-btn');
                    btn.textContent = '☀️ Day';
                }
            }
            updateRelatedCandidates(row, col, number) {
                // Remove candidate from row
                for (let c = 0; c < 9; c++) {
                    this.candidates[row][c].delete(number);
                }
                // Remove candidate from column
                for (let r = 0; r < 9; r++) {
                    this.candidates[r][col].delete(number);
                }
                // Remove candidate from 3x3 box
                const boxRow = 3 * Math.floor(row / 3);
                const boxCol = 3 * Math.floor(col / 3);
                for (let r = boxRow; r < boxRow + 3; r++) {
                    for (let c = boxCol; c < boxCol + 3; c++) {
                        this.candidates[r][c].delete(number);
                    }
                }
            }
            clearCell() {
                if (this.selectedCell === null) return;
                const row = Math.floor(this.selectedCell / 9);
                const col = this.selectedCell % 9;
                if (this.currentPuzzle[row][col] !== 0) return;
                if (this.candidateMode) {
                    // Clear all candidates
                    this.candidates[row][col].clear();
                } else {
                    // Clear number
                    this.currentGrid[row][col] = 0;
                    this.candidates[row][col].clear();
                }
                this.renderGrid();
            }
            giveHint() {
                const hint = this.sudoku.hint(this.currentGrid, 0);
                if (!hint) {
                    alert("No more hints available. Try solving manually!");
                    return;
                }
                const [technique, [row, col], value] = hint;
                const index = row * 9 + col;
                // Show explanation before applying the hint
                const explanation = this.getHintExplanation(technique, row, col, value);
                alert(`Hint: ${explanation}`);
                this.currentGrid[row][col] = value;
                const cell = document.querySelectorAll('.cell')[index];
                cell.textContent = value;
                cell.classList.add('hint');
                this.hintsUsed++;
                this.updateStats();
                this.checkCompletion();
                this.renderGrid();
            }
            getHintExplanation(technique, row, col, value) {
                const cellName = `R${row + 1}C${col + 1}`;
                switch (technique) {
                    case "HIDDEN SINGLE (BOX)":
                        return `By cross-hatching, we can see that ${value} can only be in ${cellName} in its respective 3×3 box.`;
                    case "HIDDEN SINGLE (LINE)":
                        // Simple heuristic: check if more positions available in column than row
                        let rowCandidates = 0, colCandidates = 0;
                        for (let c = 0; c < 9; c++) {
                            if (this.currentGrid[row][c] === 0) rowCandidates++;
                        }
                        for (let r = 0; r < 9; r++) {
                            if (this.currentGrid[r][col] === 0) colCandidates++;
                        }
                        const lineType = rowCandidates <= colCandidates ? "row" : "column";
                        return `${value} can only be in ${cellName} in its ${lineType}.`;
                    case "NAKED SINGLE":
                        return `${cellName} can only be a ${value}.`;
                    case "GUESS":
                        return `After trying several times, we conclude that ${cellName} can only be a ${value}.`;
                    default:
                        return `Place ${value} in ${cellName}.`;
                }
            }
            checkCompletion() {
                for (let r = 0; r < 9; r++) {
                    for (let c = 0; c < 9; c++) {
                        if (this.currentGrid[r][c] === 0) return false;
                    }
                }
                this.completeGame();
                return true;
            }
            completeGame() {
                this.stopTimer();
                const elapsed = (Date.now() - this.startTime) / 1000;
                const minutes = elapsed / 60;
                const finalScore = this.calculateScore(minutes);
                // Calculate individual components
                const baseScore = this.puzzleRating / minutes;
                const hintPenalty = Math.pow(0.8, this.hintsUsed);
                const mistakePenalty = Math.pow(0.9, this.mistakes);
                const hintLoss = Math.floor(baseScore * (1 - hintPenalty));
                const mistakeLoss = Math.floor(baseScore * hintPenalty * (1 - mistakePenalty));
                // Format time display
                const mins = Math.floor(elapsed / 60);
                const secs = Math.floor(elapsed % 60);
                const timeStr = `${mins}m ${secs.toString().padStart(2, '0')}s`;
                // Update modal content
                document.getElementById('final-time').textContent = timeStr;
                document.getElementById('time-score').textContent = `+${Math.floor(baseScore).toLocaleString()}`;
                document.getElementById('final-hints').textContent = this.hintsUsed.toString();
                document.getElementById('hint-penalty').textContent = this.hintsUsed > 0 ? `-${hintLoss.toLocaleString()}` : `-0`;
                document.getElementById('final-mistakes').textContent = this.mistakes.toString();
                document.getElementById('mistake-penalty').textContent = this.mistakes > 0 ? `-${mistakeLoss.toLocaleString()}` : `-0`;
                document.getElementById('final-score').textContent = finalScore.toLocaleString();
                const medalText = this.getMedalText(finalScore);
                document.getElementById('medal-text').textContent = medalText ? `(${medalText.toLowerCase().replace(/[🏆🥇🥈🥉]/g, '').trim()})` : '';
                this.updateBestScore(finalScore);
                this.updateMedalBorders();
                document.getElementById('complete-modal').style.display = 'block';
            }
            calculateScore(minutes) {
                const baseScore = this.puzzleRating / minutes;
                const hintPenalty = Math.pow(0.8, this.hintsUsed);
                const mistakePenalty = Math.pow(0.9, this.mistakes);
                return Math.floor(baseScore * hintPenalty * mistakePenalty);
            }
            getMedalText(score) {
                if (score >= 200000) return "🏆 Platinum Medal!";
                if (score >= 100000) return "🥇 Gold Medal!";
                if (score >= 50000) return "🥈 Silver Medal!";
                if (score >= 25000) return "🥉 Bronze Medal!";
                return "";
            }
            updateBestScore(score) {
                const key = `best-score-${this.currentDifficulty}`;
                const currentBest = parseInt(localStorage.getItem(key) || '0');
                if (score > currentBest) {
                    localStorage.setItem(key, score.toString());
                    this.updateStats();
                }
            }
            updateMedalBorders() {
                const buttons = document.querySelectorAll('.difficulty-btn');
                buttons.forEach((btn, index) => {
                    const score = parseInt(localStorage.getItem(`best-score-${index}`) || '0');
                    btn.classList.remove('bronze', 'silver', 'gold', 'platinum');
                    if (score >= 200000) btn.classList.add('platinum');
                    else if (score >= 100000) btn.classList.add('gold');
                    else if (score >= 50000) btn.classList.add('silver');
                    else if (score >= 25000) btn.classList.add('bronze');
                });
            }
            startTimer() {
                this.startTime = Date.now();
                this.timerInterval = setInterval(() => {
                    const elapsed = Date.now() - this.startTime;
                    const minutes = Math.floor(elapsed / 60000);
                    const seconds = Math.floor((elapsed % 60000) / 1000);
                    document.getElementById('timer').textContent = 
                        `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                    // Update score every 100ms for smooth animation
                    this.updateScoreDisplay();
                }, 100);
            }
            updateScoreDisplay() {
                const elapsed = this.startTime ? (Date.now() - this.startTime) / 1000 : 0;
                const minutes = Math.max(elapsed / 60, 0.1);
                const currentScore = this.calculateScore(minutes);
                document.getElementById('current-score').textContent = currentScore.toLocaleString();
            }
            stopTimer() {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                    this.timerInterval = null;
                }
            }
            resetStats() {
                this.hintsUsed = 0;
                this.mistakes = 0;
                this.updateStats();
            }
            updateStats() {
                document.getElementById('hints-count').textContent = this.hintsUsed;
                document.getElementById('mistakes-count').textContent = this.mistakes;
                // Score is now updated by the timer for smooth animation
                this.updateScoreDisplay();
                const bestScore = localStorage.getItem(`best-score-${this.currentDifficulty}`) || '0';
                document.getElementById('best-score').textContent = parseInt(bestScore).toLocaleString();
            }
            changeDifficulty(difficulty) {
                this.currentDifficulty = difficulty;
                this.stopTimer();
                document.querySelectorAll('.difficulty-btn').forEach(btn => btn.classList.remove('active'));
                document.querySelector(`[data-difficulty="${difficulty}"]`).classList.add('active');
                this.generateNewPuzzle();
            }
            loadProgress() {
                const saveData = localStorage.getItem('sudoku-save');
                if (!saveData) return;
                try {
                    const data = JSON.parse(saveData);
                    // Check if it's today's puzzle
                    if (data.date !== new Date().toDateString()) return;
                    this.currentGrid = data.currentGrid;
                    this.currentPuzzle = data.currentPuzzle;
                    this.solution = data.solution;
                    this.startTime = data.startTime;
                    this.hintsUsed = data.hintsUsed;
                    this.mistakes = data.mistakes;
                    this.currentDifficulty = data.difficulty;
                    this.puzzleRating = data.puzzleRating;
                    this.candidateMode = data.candidateMode || false;
                    // Restore candidates
                    if (data.candidates) {
                        this.candidates = data.candidates.map(row => 
                            row.map(cell => new Set(cell))
                        );
                    } else {
                        this.initializeCandidates();
                    }
                    document.querySelector(`[data-difficulty="${this.currentDifficulty}"]`).classList.add('active');
                    // Update candidate mode button
                    const btn = document.getElementById('candidate-mode-btn');
                    btn.textContent = this.candidateMode ? 'Exit Candidates' : 'Candidates';
                    btn.style.background = this.candidateMode ? '#e0e0e0' : 'white';
                    this.renderGrid();
                    this.startTimer();
                    this.updateStats();
                } catch (e) {
                    console.log('Could not load saved progress');
                    this.initializeCandidates();
                }
            }
            bindEvents() {
                // Number pad
                document.querySelectorAll('.number-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        this.placeNumber(parseInt(btn.dataset.number));
                    });
                });
                // Action buttons
                document.getElementById('clear-btn').addEventListener('click', () => this.clearCell());
                document.getElementById('hint-btn').addEventListener('click', () => this.giveHint());
                document.getElementById('candidate-mode-btn').addEventListener('click', () => this.toggleCandidateMode());
                document.getElementById('night-mode-btn').addEventListener('click', () => this.toggleNightMode());
                document.getElementById('new-game-btn').addEventListener('click', () => this.generateNewPuzzle());
                // Difficulty buttons
                document.querySelectorAll('.difficulty-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        this.changeDifficulty(parseInt(btn.dataset.difficulty));
                    });
                });
                // Keyboard events
                document.addEventListener('keydown', (e) => {
                    if (e.key >= '1' && e.key <= '9') {
                        this.placeNumber(parseInt(e.key));
                    } else if (e.key === '0' || e.key === 'Backspace' || e.key === 'Delete') {
                        this.clearCell();
                    } else if (e.key === 'c' || e.key === 'C') {
                        this.toggleCandidateMode();
                    } else if (e.key === 'n' || e.key === 'N') {
                        this.toggleNightMode();
                    }
                });
            }
        }
        function closeModal() {
            document.getElementById('complete-modal').style.display = 'none';
        }
        // Initialize the game when the page loads
        window.addEventListener('load', () => {
            new SudokuGame();
        });
    </script>
</body>
</html>
```
