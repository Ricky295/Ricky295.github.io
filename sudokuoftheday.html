<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Sudoku of the Day</title>
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    font-family: 'Comic Sans MS', 'Comic Sans', cursive;
    background: #fef9ec;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px;
    background-image: repeating-linear-gradient(
      0deg, transparent, transparent 39px, #f0e8d0 39px, #f0e8d0 40px
    ), repeating-linear-gradient(
      90deg, transparent, transparent 39px, #f0e8d0 39px, #f0e8d0 40px
    );
  }

  header {
    text-align: center;
    margin-bottom: 24px;
  }

  .title {
    font-size: 2.6rem;
    color: #c0392b;
    text-shadow: 3px 3px 0px #f39c12;
    letter-spacing: 2px;
  }

  .subtitle {
    font-size: 1rem;
    color: #7f8c8d;
    margin-top: 4px;
  }

  .date-badge {
    display: inline-block;
    background: #c0392b;
    color: white;
    padding: 5px 18px;
    border-radius: 20px;
    font-size: 0.95rem;
    margin-top: 8px;
    border: 3px solid #922b21;
  }

  .game-area {
    display: flex;
    gap: 28px;
    align-items: flex-start;
    flex-wrap: wrap;
    justify-content: center;
  }

  .board-wrap {
    position: relative;
  }

  #board {
    border-collapse: collapse;
    border: 4px solid #2c3e50;
    border-radius: 4px;
    overflow: hidden;
    background: white;
    box-shadow: 6px 6px 0px #c0392b;
  }

  #board td {
    width: 52px;
    height: 52px;
    border: 1px solid #bdc3c7;
    text-align: center;
    vertical-align: middle;
    font-family: 'Comic Sans MS', 'Comic Sans', cursive;
    font-size: 1.4rem;
    cursor: pointer;
    position: relative;
    transition: background 0.1s;
  }

  /* Thick box borders */
  #board td:nth-child(3n) { border-right: 3px solid #2c3e50; }
  #board tr:nth-child(3n) td { border-bottom: 3px solid #2c3e50; }
  #board td:nth-child(1) { border-left: none; }
  #board tr:first-child td { border-top: none; }

  #board td.given {
    color: #2c3e50;
    font-weight: bold;
    background: #f2f2f2;
  }

  #board td.user-filled {
    color: #c0392b;
  }

  #board td.selected {
    background: #fde8c8 !important;
  }

  #board td.highlight {
    background: #fef5e7;
  }

  #board td.error {
    color: #e74c3c;
    background: #fde8e8 !important;
  }

  #board td.hint-cell {
    background: #d5f5e3 !important;
    color: #1e8449;
  }

  #board td input {
    width: 100%; height: 100%;
    border: none; background: transparent;
    text-align: center;
    font-family: 'Comic Sans MS', 'Comic Sans', cursive;
    font-size: 1.4rem;
    color: inherit;
    cursor: pointer;
    outline: none;
  }

  .notes-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    grid-template-rows: repeat(3, 1fr);
    width: 100%; height: 100%;
    padding: 2px;
    position: absolute;
    top: 0; left: 0;
    pointer-events: none;
  }
  .note-num {
    font-size: 0.55rem;
    color: #7f8c8d;
    display: flex;
    align-items: center;
    justify-content: center;
    line-height: 1;
    font-family: 'Comic Sans MS', cursive;
  }

  /* Sidebar */
  .sidebar {
    display: flex;
    flex-direction: column;
    gap: 14px;
    min-width: 180px;
  }

  .status-box {
    background: white;
    border: 3px solid #2c3e50;
    border-radius: 10px;
    padding: 14px;
    box-shadow: 4px 4px 0 #f39c12;
    text-align: center;
  }

  .status-box h3 {
    font-size: 1rem;
    color: #7f8c8d;
    margin-bottom: 8px;
  }

  #timer {
    font-size: 2rem;
    color: #2c3e50;
    font-weight: bold;
  }

  .difficulty-stars {
    font-size: 1.3rem;
    margin-top: 4px;
  }

  .btn {
    display: block;
    width: 100%;
    padding: 10px 14px;
    border: 3px solid #2c3e50;
    border-radius: 10px;
    font-family: 'Comic Sans MS', 'Comic Sans', cursive;
    font-size: 1rem;
    cursor: pointer;
    transition: transform 0.1s, box-shadow 0.1s;
    box-shadow: 4px 4px 0 #2c3e50;
    font-weight: bold;
  }
  .btn:active { transform: translate(2px,2px); box-shadow: 2px 2px 0 #2c3e50; }

  .btn-hint  { background: #27ae60; color: white; }
  .btn-check { background: #f39c12; color: white; }
  .btn-clear { background: #ecf0f1; color: #2c3e50; }
  .btn-notes { background: #8e44ad; color: white; }
  .btn-notes.active { background: #6c3483; }
  .btn-erase { background: #e74c3c; color: white; }

  .numpad {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 6px;
    background: white;
    border: 3px solid #2c3e50;
    border-radius: 10px;
    padding: 10px;
    box-shadow: 4px 4px 0 #f39c12;
  }

  .num-btn {
    padding: 10px 0;
    border: 2px solid #bdc3c7;
    border-radius: 8px;
    font-family: 'Comic Sans MS', 'Comic Sans', cursive;
    font-size: 1.2rem;
    cursor: pointer;
    background: #f8f9fa;
    transition: background 0.1s;
    font-weight: bold;
    color: #2c3e50;
  }
  .num-btn:hover { background: #fde8c8; border-color: #f39c12; }
  .num-btn.used { opacity: 0.35; }

  .message {
    display: none;
    background: white;
    border: 3px solid #27ae60;
    border-radius: 10px;
    padding: 12px;
    box-shadow: 4px 4px 0 #27ae60;
    text-align: center;
    color: #1e8449;
    font-size: 1rem;
  }
  .message.error { border-color: #e74c3c; color: #e74c3c; box-shadow: 4px 4px 0 #e74c3c; }
  .message.show { display: block; }

  .hint-box {
    background: white;
    border: 3px solid #8e44ad;
    border-radius: 10px;
    padding: 10px;
    box-shadow: 4px 4px 0 #8e44ad;
    font-size: 0.85rem;
    color: #6c3483;
    display: none;
  }
  .hint-box.show { display: block; }

  #loading {
    font-size: 1.5rem;
    color: #c0392b;
    margin: 40px 0;
    animation: pulse 1s infinite;
  }
  @keyframes pulse { 0%,100%{opacity:1} 50%{opacity:0.4} }

  .congrats {
    display: none;
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.6);
    z-index: 100;
    align-items: center;
    justify-content: center;
  }
  .congrats.show { display: flex; }
  .congrats-box {
    background: white;
    border: 5px solid #f39c12;
    border-radius: 20px;
    padding: 40px;
    text-align: center;
    box-shadow: 10px 10px 0 #c0392b;
    max-width: 340px;
  }
  .congrats-box h2 { font-size: 2rem; color: #c0392b; margin-bottom: 10px; }
  .congrats-box p { color: #7f8c8d; margin-bottom: 20px; }
  .confetti { font-size: 2.5rem; margin-bottom: 10px; }
</style>
</head>
<body>

<header>
  <div class="title">‚òÄÔ∏è Sudoku of the Day ‚òÄÔ∏è</div>
  <div class="subtitle">a new puzzle every day, in comic sans, obviously</div>
  <div class="date-badge" id="dateBadge">Loading...</div>
</header>

<div id="loading">Generating today's puzzle... üé≤</div>

<div class="game-area" id="gameArea" style="display:none">
  <div class="board-wrap">
    <table id="board"></table>
  </div>

  <div class="sidebar">
    <div class="status-box">
      <h3>‚è± Time</h3>
      <div id="timer">0:00</div>
      <div class="difficulty-stars" id="diffStars"></div>
    </div>

    <button class="btn btn-notes" id="notesBtn" onclick="toggleNotes()">üìù Notes Mode: OFF</button>
    <button class="btn btn-hint" onclick="getHint()">üí° Hint</button>
    <button class="btn btn-check" onclick="checkBoard()">‚úÖ Check</button>
    <button class="btn btn-erase" onclick="eraseCell()">üßπ Erase</button>
    <button class="btn btn-clear" onclick="clearErrors()">‚ùå Clear Marks</button>

    <div class="numpad" id="numpad"></div>

    <div class="message" id="message"></div>
    <div class="hint-box" id="hintBox"></div>
  </div>
</div>

<div class="congrats" id="congrats">
  <div class="congrats-box">
    <div class="confetti">üéâüéäü•≥</div>
    <h2>You did it!!</h2>
    <p>Puzzle solved in <strong id="finalTime"></strong>!</p>
    <p style="font-size:0.8rem;color:#bdc3c7">Come back tomorrow for a new one üòä</p>
    <button class="btn btn-hint" style="margin-top:10px" onclick="document.getElementById('congrats').classList.remove('show')">Close</button>
  </div>
</div>

<script>
// ---- Embed newsudoku.js ----
${/* inline the whole lib */`
function convertToMatrix(s){if(s.length!==81)throw new Error("81 chars");const m=[];for(let i=0;i<9;i++){const r=s.substring(i*9,(i+1)*9);m.push(Array.from(r,c=>parseInt(c)))}return m}
function range1To9(){return[1,2,3,4,5,6,7,8,9]}
function shuffle(a){for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]]}return a}
function deepCopyBoard(b){return b.map(r=>[...r])}
function getPossibleValues(board,row,col){if(board[row][col]!==0)return[];const used=new Set();for(let c=0;c<9;c++)used.add(board[row][c]);for(let r=0;r<9;r++)used.add(board[r][col]);const sr=Math.floor(row/3)*3,sc=Math.floor(col/3)*3;for(let r=sr;r<sr+3;r++)for(let c=sc;c<sc+3;c++)used.add(board[r][c]);const p=[];for(let n=1;n<=9;n++)if(!used.has(n))p.push(n);return p}
function solveGridRandomBacktracking(grid){for(let r=0;r<9;r++)for(let c=0;c<9;c++)if(grid[r][c]===0){const nums=shuffle(range1To9());for(const num of nums){let ok=true;if(grid[r].includes(num))ok=false;if(ok)for(let i=0;i<9;i++)if(grid[i][c]===num){ok=false;break}if(ok){const sr=Math.floor(r/3)*3,sc=Math.floor(c/3)*3;outer:for(let rb=sr;rb<sr+3;rb++)for(let cb=sc;cb<sc+3;cb++)if(grid[rb][cb]===num){ok=false;break outer}}if(ok){grid[r][c]=num;if(solveGridRandomBacktracking(grid))return true;grid[r][c]=0}}return false}return true}
function generateSolutionRandom(){const s=Array(9).fill(null).map(()=>Array(9).fill(0));solveGridRandomBacktracking(s);return s}
function eliminatePossibilities(poss,r,c,val,puzzle){let contra=false;for(let i=0;i<9;i++){if(poss[r][i].has(val)){poss[r][i].delete(val);if(poss[r][i].size===0&&puzzle[r][i]===0)contra=true}if(poss[i][c].has(val)){poss[i][c].delete(val);if(poss[i][c].size===0&&puzzle[i][c]===0)contra=true}}const sr=Math.floor(r/3)*3,sc=Math.floor(c/3)*3;for(let rb=sr;rb<sr+3;rb++)for(let cb=sc;cb<sc+3;cb++)if(poss[rb][cb].has(val)){poss[rb][cb].delete(val);if(poss[rb][cb].size===0&&puzzle[rb][cb]===0)contra=true}return contra}
function findHiddenSingles(puzzle,poss,type,idx){const upd=[];const unitPoss={};for(let n=1;n<=9;n++)unitPoss[n]=[];let coords=[];if(type==='row')coords=Array(9).fill(null).map((_,c)=>[idx,c]);else if(type==='col')coords=Array(9).fill(null).map((_,r)=>[r,idx]);else{const sr=Math.floor(idx/3)*3,sc=(idx%3)*3;for(let r=sr;r<sr+3;r++)for(let c=sc;c<sc+3;c++)coords.push([r,c])}for(const[r,c]of coords)if(puzzle[r][c]===0)for(const n of poss[r][c])unitPoss[n].push([r,c]);for(const[n,locs]of Object.entries(unitPoss))if(locs.length===1){const[r,c]=locs[0];if(puzzle[r][c]===0)upd.push([r,c,parseInt(n)])}return upd}
function findNakedSingles(puzzle,poss){const upd=[];for(let r=0;r<9;r++)for(let c=0;c<9;c++)if(puzzle[r][c]===0&&poss[r][c].size===1)upd.push([r,c,[...poss[r][c]][0]]);return upd}
function findAndApplyUpdates(type,puzzle,poss,empty){let updates=[];if(type==='BoxHS')for(let b=0;b<9;b++)updates=updates.concat(findHiddenSingles(puzzle,poss,'box',b));else if(type==='LineHS')for(let i=0;i<9;i++)updates=updates.concat(findHiddenSingles(puzzle,poss,'row',i),findHiddenSingles(puzzle,poss,'col',i));else updates=findNakedSingles(puzzle,poss);if(updates.length===0)return[empty,false];const seen=new Set();const uniq=[];for(const[r,c,v]of updates){const k=r+','+c+','+v;if(!seen.has(k)){seen.add(k);uniq.push([r,c,v])}}let contra=false;for(const[r,c,v]of uniq)if(puzzle[r][c]===0){puzzle[r][c]=v;empty--;if(eliminatePossibilities(poss,r,c,v,puzzle))contra=true;poss[r][c]=new Set()}return[empty,contra]}
function solveWithSingles(sudoku,retDiff=false){const puzzle=deepCopyBoard(sudoku);const init=puzzle.flat().filter(x=>x===0).length;let highest=0;if(init===0)return retDiff?0.0:puzzle;const poss=Array(9).fill(null).map(()=>Array(9).fill(null).map(()=>new Set()));let empty=0;for(let r=0;r<9;r++)for(let c=0;c<9;c++){if(puzzle[r][c]===0){poss[r][c]=new Set(getPossibleValues(puzzle,r,c));if(poss[r][c].size===0)return retDiff?-0.2:sudoku;empty++}else poss[r][c]=new Set()}let steps=0,contra=false;while(empty>0){const prev=empty;[empty,contra]=findAndApplyUpdates('BoxHS',puzzle,poss,empty);if(empty<prev){steps++;if(contra)break;continue}highest=Math.max(1,highest);const p2=empty;[empty,contra]=findAndApplyUpdates('LineHS',puzzle,poss,empty);if(empty<p2){steps++;if(contra)break;continue}highest=2;const p3=empty;[empty,contra]=findAndApplyUpdates('NakedSingle',puzzle,poss,empty);if(empty<p3){steps++;if(contra)break;continue}break}if(contra)return retDiff?-0.2:sudoku;if(empty===0){const d=init>0?steps/init:0;return retDiff?(d+highest)/3:puzzle}return retDiff?-0.1:sudoku}
function generateSudoku(minD,maxD,targetClues=25,maxAttempts=100){for(let att=0;att<maxAttempts;att++){const sol=generateSolutionRandom();const puzzle=deepCopyBoard(sol);const pos=[];for(let r=0;r<9;r++)for(let c=0;c<9;c++)pos.push([r,c]);shuffle(pos);let clues=81;for(const[r,c]of pos){if(clues<=targetClues)break;const orig=puzzle[r][c];puzzle[r][c]=0;const d=solveWithSingles(puzzle,true);if(d<0)puzzle[r][c]=orig;else{clues--;if(clues<=targetClues&&d>=minD&&d<=maxD)return puzzle}}const fd=solveWithSingles(puzzle,true);if(fd>=minD&&fd<=maxD&&clues<=targetClues+5)return puzzle}const sol=generateSolutionRandom();const puzzle=deepCopyBoard(sol);const pos=[];for(let r=0;r<9;r++)for(let c=0;c<9;c++)pos.push([r,c]);shuffle(pos);let clues=81;for(const[r,c]of pos){if(clues<=targetClues)break;const orig=puzzle[r][c];puzzle[r][c]=0;const d=solveWithSingles(puzzle,true);if(d<0)puzzle[r][c]=orig;else clues--}return puzzle}
function seededRandom(seed){let s=seed;return function(){s=Math.sin(s)*10000;return s-Math.floor(s)}}
function hashCode(str){let h=0;for(let i=0;i<str.length;i++){const c=str.charCodeAt(i);h=((h<<5)-h)+c;h=h&h}return Math.abs(h)}
function generateDailySudoku(date){const ds=date.toISOString().split('T')[0];const seed=hashCode(ds);const orig=Math.random;Math.random=seededRandom(seed);const puzzle=generateSudoku(0.3,0.7,30);Math.random=orig;return puzzle}
function getSortedHiddenSingleUpdate(puzzle,poss,type){for(const num of range1To9())for(let idx=0;idx<9;idx++){let coords=[];if(type==='row')coords=Array(9).fill(null).map((_,c)=>[idx,c]);else if(type==='col')coords=Array(9).fill(null).map((_,r)=>[r,idx]);else{const sr=Math.floor(idx/3)*3,sc=(idx%3)*3;for(let r=sr;r<sr+3;r++)for(let c=sc;c<sc+3;c++)coords.push([r,c])}const locs=[];for(const[r,c]of coords)if(puzzle[r][c]===0&&poss[r][c].has(num))locs.push([r,c]);if(locs.length===1){const[r,c]=locs[0];return[r,c,num]}}return null}
function hint(sudoku){const puzzle=deepCopyBoard(sudoku);const poss=Array(9).fill(null).map(()=>Array(9).fill(null).map(()=>new Set()));const empty=[];for(let r=0;r<9;r++)for(let c=0;c<9;c++){if(puzzle[r][c]===0){poss[r][c]=new Set(getPossibleValues(puzzle,r,c));if(poss[r][c].size===0)return["Contradiction",[r,c],0];empty.push([r,c])}}if(empty.length===0)return["Solved",[-1,-1],0];let u=getSortedHiddenSingleUpdate(puzzle,poss,'box');if(u)return["Box HS",[u[0],u[1]],u[2]];u=getSortedHiddenSingleUpdate(puzzle,poss,'row');if(u)return["Line HS",[u[0],u[1]],u[2]];u=getSortedHiddenSingleUpdate(puzzle,poss,'col');if(u)return["Line HS",[u[0],u[1]],u[2]];const ns=findNakedSingles(puzzle,poss);if(ns.length>0)return["Naked Single",[ns[0][0],ns[0][1]],ns[0][2]];return["Stuck",[-1,-1],0]}
`}

// ---- Game State ----
let puzzle = null;      // given clues (0 = empty)
let board = null;       // current user board
let solution = null;    // solved board
let notes = Array(9).fill(null).map(()=>Array(9).fill(null).map(()=>new Set()));
let selected = null;    // [r,c]
let notesMode = false;
let timerInterval = null;
let seconds = 0;
let solved = false;
let hintCount = 0;

// ---- Init ----
window.onload = () => {
  const today = new Date();
  document.getElementById('dateBadge').textContent =
    today.toLocaleDateString('en-US', {weekday:'long', year:'numeric', month:'long', day:'numeric'});

  setTimeout(() => {
    puzzle = generateDailySudoku(today);
    board = deepCopyBoard(puzzle);
    solution = solveWithSingles(puzzle);

    // Estimate difficulty for display
    const diff = solveWithSingles(puzzle, true);
    let stars = '‚≠ê';
    if (diff > 0.5) stars = '‚≠ê‚≠ê';
    if (diff > 0.7) stars = '‚≠ê‚≠ê‚≠ê';
    document.getElementById('diffStars').textContent = stars;

    document.getElementById('loading').style.display = 'none';
    document.getElementById('gameArea').style.display = 'flex';

    renderBoard();
    buildNumpad();
    startTimer();
  }, 50);
};

// ---- Timer ----
function startTimer() {
  timerInterval = setInterval(() => {
    if (solved) return;
    seconds++;
    const m = Math.floor(seconds/60);
    const s = seconds % 60;
    document.getElementById('timer').textContent = m + ':' + String(s).padStart(2,'0');
  }, 1000);
}

// ---- Render ----
function renderBoard() {
  const tbl = document.getElementById('board');
  tbl.innerHTML = '';
  for (let r = 0; r < 9; r++) {
    const tr = document.createElement('tr');
    for (let c = 0; c < 9; c++) {
      const td = document.createElement('td');
      td.dataset.r = r; td.dataset.c = c;

      const isGiven = puzzle[r][c] !== 0;
      if (isGiven) {
        td.textContent = puzzle[r][c];
        td.classList.add('given');
      } else if (board[r][c] !== 0) {
        td.textContent = board[r][c];
        td.classList.add('user-filled');
      } else {
        // Maybe notes
        const cellNotes = notes[r][c];
        if (cellNotes.size > 0) {
          const grid = document.createElement('div');
          grid.className = 'notes-grid';
          for (let n = 1; n <= 9; n++) {
            const span = document.createElement('span');
            span.className = 'note-num';
            span.textContent = cellNotes.has(n) ? n : '';
            grid.appendChild(span);
          }
          td.appendChild(grid);
        }
      }

      if (selected && selected[0]===r && selected[1]===c) td.classList.add('selected');
      else if (selected) {
        const [sr,sc] = selected;
        if (r===sr || c===sc || (Math.floor(r/3)===Math.floor(sr/3)&&Math.floor(c/3)===Math.floor(sc/3)))
          td.classList.add('highlight');
      }

      td.addEventListener('click', () => selectCell(r, c));
      tr.appendChild(td);
    }
    tbl.appendChild(tr);
  }
}

function selectCell(r, c) {
  selected = [r, c];
  document.getElementById('hintBox').classList.remove('show');
  renderBoard();
}

// ---- Input ----
document.addEventListener('keydown', e => {
  if (!selected || solved) return;
  const [r, c] = selected;
  if (puzzle[r][c] !== 0) return;

  if (e.key >= '1' && e.key <= '9') placeNum(r, c, parseInt(e.key));
  else if (e.key === 'Backspace' || e.key === 'Delete' || e.key === '0') erase(r, c);
  else if (e.key === 'ArrowUp' && r>0) selected=[r-1,c], renderBoard();
  else if (e.key === 'ArrowDown' && r<8) selected=[r+1,c], renderBoard();
  else if (e.key === 'ArrowLeft' && c>0) selected=[r,c-1], renderBoard();
  else if (e.key === 'ArrowRight' && c<8) selected=[r,c+1], renderBoard();
});

function placeNum(r, c, num) {
  if (puzzle[r][c] !== 0) return;
  if (notesMode) {
    if (board[r][c] !== 0) return;
    if (notes[r][c].has(num)) notes[r][c].delete(num);
    else notes[r][c].add(num);
  } else {
    board[r][c] = num;
    notes[r][c].clear();
    // Remove num from notes of peers
    for (let i=0;i<9;i++){
      notes[r][i].delete(num);
      notes[i][c].delete(num);
    }
    const sr=Math.floor(r/3)*3,sc=Math.floor(c/3)*3;
    for(let rb=sr;rb<sr+3;rb++)for(let cb=sc;cb<sc+3;cb++)notes[rb][cb].delete(num);
  }
  clearMsg();
  renderBoard();
  updateNumpad();
  if (!notesMode) checkWin();
}

function erase(r, c) {
  if (puzzle[r][c] !== 0) return;
  board[r][c] = 0;
  notes[r][c].clear();
  renderBoard();
  updateNumpad();
}

// ---- Buttons ----
function eraseCell() {
  if (!selected) return;
  erase(selected[0], selected[1]);
}

function toggleNotes() {
  notesMode = !notesMode;
  const btn = document.getElementById('notesBtn');
  btn.textContent = 'üìù Notes Mode: ' + (notesMode ? 'ON' : 'OFF');
  btn.classList.toggle('active', notesMode);
}

function clearErrors() {
  // Remove wrong user entries
  for (let r=0;r<9;r++) for(let c=0;c<9;c++)
    if(puzzle[r][c]===0 && board[r][c]!==0 && board[r][c]!==solution[r][c])
      board[r][c]=0;
  renderBoard(); updateNumpad();
  showMsg('Wrong entries cleared! üßπ', false);
}

function checkBoard() {
  let errors = 0;
  for (let r=0;r<9;r++) for(let c=0;c<9;c++)
    if(puzzle[r][c]===0 && board[r][c]!==0 && board[r][c]!==solution[r][c]) errors++;
  if (errors === 0) showMsg('Looking good so far! ‚ú®', false);
  else showMsg(`Found ${errors} mistake${errors>1?'s':''}! üò¨`, true);
}

function getHint() {
  // Build current board for hint
  const current = deepCopyBoard(board);
  const h = hint(current);
  const [tech, [r,c], val] = h;

  if (tech === 'Solved') { showMsg('Puzzle is already solved!', false); return; }
  if (tech === 'Stuck' || tech === 'Contradiction') { showMsg("Hmm, something's wrong ü§î", true); return; }

  hintCount++;
  // Show hint cell
  selected = [r, c];
  renderBoard();

  // Highlight hint cell
  const td = document.querySelector(`td[data-r="${r}"][data-c="${c}"]`);
  if (td) td.classList.add('hint-cell');

  const techNames = {'Box HS': 'Box Hidden Single', 'Line HS': 'Line Hidden Single', 'Naked Single': 'Naked Single', 'Guess': 'Educated Guess'};
  const hintBox = document.getElementById('hintBox');
  hintBox.textContent = `üí° Technique: ${techNames[tech]||tech} ‚Üí Place ${val} at row ${r+1}, col ${c+1}`;
  hintBox.classList.add('show');
}

// ---- Numpad ----
function buildNumpad() {
  const np = document.getElementById('numpad');
  np.innerHTML = '';
  for (let n=1;n<=9;n++) {
    const btn = document.createElement('button');
    btn.className = 'num-btn';
    btn.textContent = n;
    btn.id = 'nb'+n;
    btn.onclick = () => { if(selected&&!solved)placeNum(selected[0],selected[1],n); };
    np.appendChild(btn);
  }
}

function updateNumpad() {
  // Grey out fully placed numbers
  for (let n=1;n<=9;n++) {
    let count=0;
    for(let r=0;r<9;r++)for(let c=0;c<9;c++)if(board[r][c]===n)count++;
    const btn = document.getElementById('nb'+n);
    if(btn) btn.classList.toggle('used', count>=9);
  }
}

// ---- Win Check ----
function checkWin() {
  for(let r=0;r<9;r++)for(let c=0;c<9;c++)if(board[r][c]===0||board[r][c]!==solution[r][c])return;
  solved = true;
  clearInterval(timerInterval);
  const m=Math.floor(seconds/60),s=seconds%60;
  document.getElementById('finalTime').textContent = m+'m '+s+'s';
  setTimeout(()=>document.getElementById('congrats').classList.add('show'),400);
}

// ---- Messages ----
function showMsg(txt, isError) {
  const el = document.getElementById('message');
  el.textContent = txt;
  el.className = 'message show' + (isError?' error':'');
}
function clearMsg() { document.getElementById('message').classList.remove('show'); }
</script>
</body>
</html>
