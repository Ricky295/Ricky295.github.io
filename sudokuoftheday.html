<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sudoku of the Day</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', serif;
            background: linear-gradient(135deg, #f5f3f0 0%, #e8e3db 100%);
            min-height: 100vh;
            color: #2c3e50;
        }

        .paper-container {
            max-width: 800px;
            margin: 20px auto;
            background: #fefefe;
            border-radius: 8px;
            box-shadow: 
                0 4px 6px rgba(0,0,0,0.1),
                0 1px 3px rgba(0,0,0,0.08),
                inset 0 0 0 1px rgba(255,255,255,0.5);
            position: relative;
            overflow: hidden;
        }

        .paper-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 60px;
            bottom: 0;
            width: 2px;
            background: #ff6b6b;
            opacity: 0.3;
        }

        .paper-container::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: 
                repeating-linear-gradient(
                    transparent,
                    transparent 27px,
                    rgba(200,200,200,0.3) 28px
                );
            pointer-events: none;
        }

        .header {
            text-align: center;
            padding: 30px 20px;
            border-bottom: 2px solid #e9ecef;
            background: linear-gradient(to bottom, #fefefe, #f8f9fa);
        }

        .header h1 {
            font-size: 2.5em;
            color: #2c3e50;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 10px;
        }

        .date-display {
            font-size: 1.2em;
            color: #6c757d;
            font-style: italic;
        }

        .content {
            padding: 30px;
            position: relative;
            z-index: 2;
        }

        .skill-assessment, .home-screen, .game-screen {
            display: none;
        }

        .skill-assessment.active, .home-screen.active, .game-screen.active {
            display: block;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .stat-card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #dee2e6;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: #495057;
            display: block;
        }

        .stat-label {
            color: #6c757d;
            font-size: 0.9em;
            margin-top: 5px;
        }

        .level-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin: 30px 0;
        }

        .level-btn {
            padding: 20px;
            background: #fff;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            cursor: pointer;
            text-align: center;
            transition: all 0.3s ease;
            position: relative;
        }

        .level-btn:hover {
            border-color: #007bff;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .level-btn.completed {
            border-color: #28a745;
            background: #d4edda;
        }

        .level-number {
            font-size: 1.5em;
            font-weight: bold;
            color: #495057;
        }

        .level-name {
            font-size: 0.9em;
            color: #6c757d;
            margin-top: 5px;
        }

        .sudoku-container {
            display: flex;
            justify-content: center;
            margin: 20px auto;
        }

        .sudoku-grid {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            border: 3px solid #000;
            border-radius: 6px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .sudoku-cell {
            width: 45px;
            height: 45px;
            background: #fff;
            border: 1px solid #ccc;
            text-align: center;
            font-size: 1.3em;
            font-weight: bold;
            color: #2c3e50;
            outline: none;
            transition: all 0.2s ease;
        }

        .sudoku-cell:focus {
            background: #e3f2fd;
            border-color: #2196F3;
            box-shadow: inset 0 0 0 2px #2196F3;
        }

        /* Right borders for 3x3 box separation */
        .sudoku-cell:nth-child(3n):not(:nth-child(9n)) {
            border-right: 3px solid #000;
        }

        /* Bottom borders for 3x3 box separation */
        .sudoku-cell:nth-child(n+19):nth-child(-n+27),
        .sudoku-cell:nth-child(n+46):nth-child(-n+54) {
            border-bottom: 3px solid #000;
        }

        .sudoku-cell.given {
            background: #f8f9fa;
            color: #000;
            font-weight: bold;
        }

        .sudoku-cell.user-input {
            background: #e8f5e8;
            color: #2e7d32;
        }

        .sudoku-cell.error {
            background: #ffebee;
            color: #d32f2f;
            animation: shake 0.3s ease-in-out;
        }

        .sudoku-cell.hint {
            background: #fff3e0;
            color: #f57c00;
            animation: pulse 0.5s ease-in-out;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-3px); }
            75% { transform: translateX(3px); }
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .game-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 24px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .btn:hover {
            background: #0056b3;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }

        .btn.secondary {
            background: #6c757d;
        }

        .btn.secondary:hover {
            background: #545b62;
        }

        .btn.success {
            background: #28a745;
        }

        .btn.success:hover {
            background: #1e7e34;
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            margin: 20px 0;
            font-size: 1.1em;
        }

        .timer, .score {
            background: #f8f9fa;
            padding: 10px 15px;
            border-radius: 6px;
            border: 1px solid #dee2e6;
        }

        .completion-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .completion-modal.active {
            display: flex;
        }

        .modal-content {
            background: #fff;
            padding: 40px;
            border-radius: 12px;
            text-align: center;
            max-width: 400px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .modal-content h2 {
            color: #28a745;
            margin-bottom: 20px;
            font-size: 2em;
        }

        .final-score {
            font-size: 1.5em;
            color: #007bff;
            margin: 20px 0;
            font-weight: bold;
        }

        @media (max-width: 600px) {
            .sudoku-cell {
                width: 35px;
                height: 35px;
                font-size: 1.1em;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .content {
                padding: 20px;
            }
        }

        @media (max-width: 400px) {
            .sudoku-cell {
                width: 30px;
                height: 30px;
                font-size: 1em;
            }
        }
    </style>
</head>
<body>
    <div class="paper-container">
        <div class="header">
            <h1>📖 Sudoku of the Day</h1>
            <div class="date-display" id="dateDisplay"></div>
        </div>
        
        <div class="content">
            <!-- Skill Assessment Screen -->
            <div class="skill-assessment active" id="skillAssessment">
                <h2 style="text-align: center; margin-bottom: 30px;">Welcome to Sudoku of the Day!</h2>
                <p style="text-align: center; margin-bottom: 30px; font-size: 1.1em; color: #6c757d;">
                    Tell us about your Sudoku experience so we can recommend the right difficulty for you:
                </p>
                <div class="level-grid" id="skillGrid">
                    <!-- Skill levels will be populated by JavaScript -->
                </div>
            </div>

            <!-- Home Screen -->
            <div class="home-screen" id="homeScreen">
                <div class="stats-grid">
                    <div class="stat-card">
                        <span class="stat-value" id="totalCompleted">0</span>
                        <div class="stat-label">Completed</div>
                    </div>
                    <div class="stat-card">
                        <span class="stat-value" id="averageScore">0</span>
                        <div class="stat-label">Avg Score</div>
                    </div>
                    <div class="stat-card">
                        <span class="stat-value" id="bestScore">0</span>
                        <div class="stat-label">Best Score</div>
                    </div>
                    <div class="stat-card">
                        <span class="stat-value" id="currentStreak">0</span>
                        <div class="stat-label">Streak</div>
                    </div>
                </div>
                
                <div class="game-controls">
                    <button class="btn" onclick="startTodaysPuzzle()" id="playTodayBtn">Play Today's Puzzle</button>
                    <button class="btn secondary" onclick="showSettings()">Settings</button>
                </div>
                
                <div style="text-align: center; margin-top: 20px;">
                    <p style="color: #6c757d;">Your skill level: <strong id="userSkillDisplay">Not set</strong></p>
                    <p style="color: #6c757d; font-size: 0.9em; margin-top: 5px;">Playing at: <strong id="currentDifficultyDisplay">Medium</strong> difficulty</p>
                    <button class="btn secondary" onclick="changeSkillLevel()" style="margin-top: 10px; padding: 8px 16px; font-size: 0.9em;">Change Skill Level</button>
                </div>
            </div>

            <!-- Game Screen -->
            <div class="game-screen" id="gameScreen">
                <div class="game-info">
                    <div class="timer">⏱️ <span id="timeDisplay">00:00</span></div>
                    <div class="score">⭐ <span id="scoreDisplay">1000</span></div>
                </div>
                
                <div style="text-align: center; margin-bottom: 10px; color: #6c757d; font-size: 0.9em;">
                    Puzzle Complexity: <span id="complexityDisplay">Calculating...</span> pts/min
                </div>
                
                <div class="sudoku-container">
                    <div class="sudoku-grid" id="sudokuGrid">
                        <!-- Grid will be populated by JavaScript -->
                    </div>
                </div>
                
                <div class="game-controls">
                    <button class="btn" onclick="getHint()">💡 Hint</button>
                    <button class="btn secondary" onclick="checkSolution()">✓ Check</button>
                    <button class="btn secondary" onclick="showHome()">Back to Home</button>
                </div>
                
                <div style="text-align: center; margin-top: 20px;">
                    <p>Level: <span id="currentLevel">1</span> | Mistakes: <span id="mistakeCount">0</span> | Hints: <span id="hintCount">0</span></p>
                </div>
            </div>
        </div>
    </div>

    <!-- Completion Modal -->
    <div class="completion-modal" id="completionModal">
        <div class="modal-content">
            <h2>🎉 Congratulations!</h2>
            <p>You completed today's puzzle!</p>
            <div class="final-score">Final Score: <span id="finalScore">0</span></div>
            <p>Time: <span id="finalTime">00:00</span></p>
            <div style="margin-top: 20px;">
                <button class="btn success" onclick="closeModal()">Awesome!</button>
            </div>
        </div>
    </div>

    <script src="sudoku.js"></script>
    <script>
        // Debug helper
        function debug(...args) {
            console.log(`[DEBUG ${new Date().toLocaleTimeString()}]`, ...args);
        }
        
        function debugError(...args) {
            console.error(`[ERROR ${new Date().toLocaleTimeString()}]`, ...args);
        }
        
        // Test if Sudoku class loaded
        debug('=== INITIALIZATION CHECK ===');
        debug('Sudoku class available?', typeof Sudoku !== 'undefined');
        debug('Window object keys:', Object.keys(window).filter(k => k.includes('Sudoku')));
        debug('Document ready state:', document.readyState);
        
        if (typeof Sudoku !== 'undefined') {
            debug('✅ Sudoku class found, testing instantiation...');
            try {
                const testSudoku = new Sudoku();
                debug('✅ Sudoku instantiation successful');
                debug('Sudoku methods:', Object.getOwnPropertyNames(Object.getPrototypeOf(testSudoku)));
            } catch (e) {
                debugError('❌ Sudoku instantiation failed:', e);
            }
        } else {
            debugError('❌ Sudoku class not found! Check if sudoku.js loaded properly.');
            debugError('Available global objects:', Object.keys(window).slice(0, 20));
        }

        class SudokuOfTheDay {
            constructor() {
                debug('=== CONSTRUCTOR START ===');
                
                try {
                    if (typeof Sudoku === 'undefined') {
                        debugError('❌ Sudoku class not available in constructor');
                        // Create a mock Sudoku for testing
                        this.sudoku = {
                            generateDailySudoku: () => {
                                debug('Using mock Sudoku - generating simple puzzle');
                                return [
                                    [5,3,0,0,7,0,0,0,0],
                                    [6,0,0,1,9,5,0,0,0],
                                    [0,9,8,0,0,0,0,6,0],
                                    [8,0,0,0,6,0,0,0,3],
                                    [4,0,0,8,0,3,0,0,1],
                                    [7,0,0,0,2,0,0,0,6],
                                    [0,6,0,0,0,0,2,8,0],
                                    [0,0,0,4,1,9,0,0,5],
                                    [0,0,0,0,8,0,0,7,9]
                                ];
                            },
                            hint: () => null,
                            solvePath: () => []
                        };
                    } else {
                        debug('✅ Sudoku class available, creating instance');
                        this.sudoku = new Sudoku();
                        debug('✅ Sudoku instance created successfully');
                    }
                } catch (e) {
                    debugError('❌ Error creating Sudoku instance:', e);
                    this.sudoku = null;
                }
                this.currentPuzzle = null;
                this.originalPuzzle = null;
                this.solutionPath = null;
                this.currentLevel = 0;
                this.startTime = null;
                this.gameTimer = null;
                this.mistakes = 0;
                this.hintsUsed = 0;
                this.pointsPerMinute = 1000;
                this.currentScore = 1000;
                
                this.levelNames = [
                    'Beginner', 'Easy', 'Medium', 
                    'Hard', 'Expert', 'Master'
                ];
                
                this.skillLevels = [
                    {
                        name: "Haven't played yet",
                        description: "I'm completely new to Sudoku",
                        recommended: 0
                    },
                    {
                        name: "Just started",
                        description: "I've tried a few puzzles but still learning",
                        recommended: 1
                    },
                    {
                        name: "Getting comfortable",
                        description: "I can solve easy puzzles without much trouble",
                        recommended: 2
                    },
                    {
                        name: "Pretty confident",
                        description: "I regularly solve medium difficulty puzzles",
                        recommended: 3
                    },
                    {
                        name: "Very experienced",
                        description: "I can handle most challenging puzzles",
                        recommended: 4
                    },
                    {
                        name: "Sudoku master",
                        description: "I live and breathe Sudoku!",
                        recommended: 5
                    }
                ];
                
                this.userSkillLevel = null;
                this.stats = {
                    totalCompleted: 0,
                    totalScore: 0,
                    bestScore: 0,
                    currentStreak: 0,
                    lastCompletedDate: null
                };
                
                debug('✅ Constructor completed successfully');
                debug('Initial state:', {
                    sudokuAvailable: this.sudoku !== null,
                    userSkillLevel: this.userSkillLevel,
                    skillLevelsCount: this.skillLevels.length
                });
            }
            
            init() {
                debug('=== INIT START ===');
                debug('DOM elements check:');
                debug('- dateDisplay:', !!document.getElementById('dateDisplay'));
                debug('- skillGrid:', !!document.getElementById('skillGrid'));
                debug('- homeScreen:', !!document.getElementById('homeScreen'));
                debug('- skillAssessment:', !!document.getElementById('skillAssessment'));
                
                try {
                    this.updateDateDisplay();
                    debug('✅ Date display updated');
                } catch (e) {
                    debugError('❌ Error updating date display:', e);
                }
                
                this.userSkillLevel = this.getUserSkillLevel();
                debug('User skill level:', this.userSkillLevel);
                
                if (this.userSkillLevel !== null) {
                    debug('Showing home screen...');
                    this.showHome();
                } else {
                    debug('Showing skill assessment...');
                    this.showSkillAssessment();
                }
                
                try {
                    this.loadStats();
                    this.checkTodayCompletion();
                    debug('✅ Init completed successfully');
                } catch (e) {
                    debugError('❌ Error in init completion:', e);
                }
            }
            
            // Use in-memory storage instead of localStorage for better compatibility
            getUserSkillLevel() {
                return this.userSkillLevel;
            }
            
            saveUserSkillLevel(skillIndex) {
                this.userSkillLevel = skillIndex;
                this.updateUserSkillDisplay();
            }
            
            updateDateDisplay() {
                const today = new Date();
                const options = { 
                    weekday: 'long', 
                    year: 'numeric', 
                    month: 'long', 
                    day: 'numeric' 
                };
                document.getElementById('dateDisplay').textContent = 
                    today.toLocaleDateString('en-US', options);
            }
            
            loadStats() {
                document.getElementById('totalCompleted').textContent = this.stats.totalCompleted;
                document.getElementById('averageScore').textContent = 
                    this.stats.totalCompleted > 0 ? Math.round(this.stats.totalScore / this.stats.totalCompleted) : 0;
                document.getElementById('bestScore').textContent = this.stats.bestScore;
                document.getElementById('currentStreak').textContent = this.stats.currentStreak;
            }
            
            showSkillAssessment() {
                debug('=== SHOW SKILL ASSESSMENT ===');
                
                try {
                    const skillGrid = document.getElementById('skillGrid');
                    debug('skillGrid element:', skillGrid);
                    
                    if (!skillGrid) {
                        debugError('❌ skillGrid element not found!');
                        return;
                    }
                    
                    debug('Clearing skill grid...');
                    skillGrid.innerHTML = '';
                    debug('skillGrid cleared');
                    
                    debug('Creating skill buttons, count:', this.skillLevels.length);
                    
                    this.skillLevels.forEach((skill, index) => {
                        debug(`Creating skill button ${index}:`, skill.name);
                        
                        const button = document.createElement('div');
                        button.className = 'level-btn';
                        
                        // Add detailed click logging
                        button.onclick = (event) => {
                            debug('=== SKILL BUTTON CLICKED ===');
                            debug('Button clicked, index:', index);
                            debug('Skill:', skill.name);
                            debug('Event:', event);
                            debug('Target:', event.target);
                            
                            try {
                                debug('Calling setUserSkillLevel...');
                                this.setUserSkillLevel(index);
                                debug('✅ setUserSkillLevel completed');
                            } catch (error) {
                                debugError('❌ Error in setUserSkillLevel:', error);
                            }
                        };
                        
                        button.innerHTML = `
                            <div class="level-number">${index + 1}</div>
                            <div class="level-name">${skill.name}</div>
                            <div style="font-size: 0.8em; color: #6c757d; margin-top: 5px;">${skill.description}</div>
                        `;
                        
                        debug(`Adding button ${index} to grid`);
                        skillGrid.appendChild(button);
                        debug(`✅ Button ${index} added, grid children count:`, skillGrid.children.length);
                    });
                    
                    debug('All buttons created, total:', skillGrid.children.length);
                    debug('Calling showScreen...');
                    this.showScreen('skillAssessment');
                    debug('✅ showSkillAssessment completed');
                    
                } catch (error) {
                    debugError('❌ Error in showSkillAssessment:', error);
                    debugError('Stack:', error.stack);
                }
            }
            
            setUserSkillLevel(skillIndex) {
                this.saveUserSkillLevel(skillIndex);
                this.showHome();
            }
            
            updateUserSkillDisplay() {
                if (this.userSkillLevel !== null) {
                    document.getElementById('userSkillDisplay').textContent = 
                        this.skillLevels[this.userSkillLevel].name;
                    
                    const userLevelIndex = this.skillLevels[this.userSkillLevel].recommended;
                    document.getElementById('currentDifficultyDisplay').textContent = 
                        this.levelNames[userLevelIndex];
                }
            }
            
            startTodaysPuzzle() {
                if (this.stats.lastCompletedDate === new Date().toDateString()) {
                    alert(`You have already completed today's puzzle!\n\nYour score: ${this.stats.bestScore}\n\nCome back tomorrow for a new puzzle!`);
                    return;
                }
                
                if (this.userSkillLevel !== null) {
                    const recommendedLevel = this.skillLevels[this.userSkillLevel].recommended;
                    this.startGame(recommendedLevel);
                } else {
                    this.startGame(2);
                }
            }
            
            showHome() {
                this.updateUserSkillDisplay();
                this.updatePlayButton();
                this.showScreen('homeScreen');
            }
            
            updatePlayButton() {
                const playBtn = document.getElementById('playTodayBtn');
                if (this.stats.lastCompletedDate === new Date().toDateString()) {
                    playBtn.textContent = '✅ Today\'s Puzzle Complete';
                    playBtn.classList.add('success');
                } else {
                    playBtn.textContent = 'Play Today\'s Puzzle';
                    playBtn.classList.remove('success');
                    playBtn.classList.add('btn');
                }
            }
            
            // Use in-memory storage instead of localStorage for better compatibility
            getUserSkillLevel() {
                debug('=== GET USER SKILL LEVEL ===');
                debug('Current userSkillLevel:', this.userSkillLevel);
                return this.userSkillLevel;
            }
            
            showScreen(screenId) {
                debug('=== SHOW SCREEN ===');
                debug('Switching to screen:', screenId);
                
                const screens = document.querySelectorAll('.skill-assessment, .home-screen, .game-screen');
                debug('Found screens:', screens.length);
                
                screens.forEach(screen => {
                    const wasActive = screen.classList.contains('active');
                    screen.classList.remove('active');
                    if (wasActive) {
                        debug('Hiding screen:', screen.id || screen.className);
                    }
                });
                
                const targetScreen = document.getElementById(screenId);
                debug('Target screen:', targetScreen);
                
                if (targetScreen) {
                    targetScreen.classList.add('active');
                    debug('✅ Showing screen:', screenId);
                    debug('Screen is visible:', targetScreen.offsetHeight > 0);
                } else {
                    debugError('❌ Screen not found:', screenId);
                }
            }
            
            checkTodayCompletion() {
                if (this.stats.lastCompletedDate === new Date().toDateString()) {
                    this.updateStreak();
                }
            }
            
            updateStreak() {
                const today = new Date().toDateString();
                const yesterday = new Date(Date.now() - 86400000).toDateString();
                
                if (this.stats.lastCompletedDate === yesterday) {
                    this.stats.currentStreak += 1;
                } else if (this.stats.lastCompletedDate !== today) {
                    this.stats.currentStreak = 1;
                }
                
                this.stats.lastCompletedDate = today;
            }
            
            calculatePointsPerMinute(solutionPath) {
                if (!solutionPath || solutionPath.length === 0) {
                    return 1000;
                }
                
                let totalPoints = 0;
                let consecutiveGuesses = 0;
                
                for (const step of solutionPath) {
                    const [technique] = step;
                    
                    switch (technique) {
                        case "HIDDEN SINGLE (BOX)":
                            totalPoints += 100;
                            consecutiveGuesses = 0;
                            break;
                        case "HIDDEN SINGLE (LINE)":
                            totalPoints += 150;
                            consecutiveGuesses = 0;
                            break;
                        case "NAKED SINGLE":
                            totalPoints += 200;
                            consecutiveGuesses = 0;
                            break;
                        case "GUESS":
                            consecutiveGuesses++;
                            const guessPoints = 500 * Math.pow(1.5, consecutiveGuesses - 1);
                            totalPoints += guessPoints;
                            break;
                        default:
                            totalPoints += 300;
                            consecutiveGuesses = 0;
                            break;
                    }
                }
                
                return Math.max(totalPoints, 500);
            }
            
            startGame(level) {
                this.currentLevel = level;
                this.mistakes = 0;
                this.hintsUsed = 0;
                
                const today = new Date();
                this.currentPuzzle = this.sudoku.generateDailySudoku(level, today, "matrix");
                this.originalPuzzle = this.currentPuzzle.map(row => [...row]);
                
                this.solutionPath = this.sudoku.solvePath(this.currentPuzzle, 0);
                this.pointsPerMinute = this.calculatePointsPerMinute(this.solutionPath);
                
                this.createSudokuGrid();
                this.startTimer();
                this.updateGameInfo();
                
                this.showScreen('gameScreen');
            }
            
            createSudokuGrid() {
                const grid = document.getElementById('sudokuGrid');
                grid.innerHTML = '';
                
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        const cell = document.createElement('input');
                        cell.type = 'text';
                        cell.className = 'sudoku-cell';
                        cell.maxLength = 1;
                        cell.dataset.row = row;
                        cell.dataset.col = col;
                        
                        const value = this.currentPuzzle[row][col];
                        if (value !== 0) {
                            cell.value = value;
                            cell.classList.add('given');
                            cell.readOnly = true;
                        } else {
                            cell.addEventListener('input', (e) => this.handleCellInput(e));
                            cell.addEventListener('keydown', (e) => this.handleKeyDown(e));
                        }
                        
                        grid.appendChild(cell);
                    }
                }
            }
            
            handleCellInput(event) {
                const cell = event.target;
                const value = cell.value;
                
                if (!/^[1-9]$/.test(value)) {
                    cell.value = '';
                    return;
                }
                
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                this.currentPuzzle[row][col] = parseInt(value);
                
                if (this.isValidMove(row, col, parseInt(value))) {
                    cell.classList.remove('error');
                    cell.classList.add('user-input');
                } else {
                    cell.classList.add('error');
                    this.mistakes++;
                    this.updateScore();
                }
                
                this.updateGameInfo();
                
                if (this.isPuzzleComplete()) {
                    this.completeGame();
                }
            }
            
            handleKeyDown(event) {
                const cell = event.target;
                
                if (event.key === 'Backspace' || event.key === 'Delete') {
                    const row = parseInt(cell.dataset.row);
                    const col = parseInt(cell.dataset.col);
                    this.currentPuzzle[row][col] = 0;
                    cell.classList.remove('user-input', 'error', 'hint');
                }
                
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                let newRow = row, newCol = col;
                
                switch(event.key) {
                    case 'ArrowUp':
                        newRow = Math.max(0, row - 1);
                        break;
                    case 'ArrowDown':
                        newRow = Math.min(8, row + 1);
                        break;
                    case 'ArrowLeft':
                        newCol = Math.max(0, col - 1);
                        break;
                    case 'ArrowRight':
                        newCol = Math.min(8, col + 1);
                        break;
                }
                
                if (newRow !== row || newCol !== col) {
                    event.preventDefault();
                    const newCell = document.querySelector(`[data-row="${newRow}"][data-col="${newCol}"]`);
                    if (newCell && !newCell.readOnly) {
                        newCell.focus();
                    }
                }
            }
            
            isValidMove(row, col, value) {
                const tempGrid = this.currentPuzzle.map(r => [...r]);
                tempGrid[row][col] = 0;
                
                for (let c = 0; c < 9; c++) {
                    if (tempGrid[row][c] === value) return false;
                }
                
                for (let r = 0; r < 9; r++) {
                    if (tempGrid[r][col] === value) return false;
                }
                
                const boxRow = Math.floor(row / 3) * 3;
                const boxCol = Math.floor(col / 3) * 3;
                for (let r = boxRow; r < boxRow + 3; r++) {
                    for (let c = boxCol; c < boxCol + 3; c++) {
                        if (tempGrid[r][c] === value) return false;
                    }
                }
                
                return true;
            }
            
            getHint() {
                const hint = this.sudoku.hint(this.currentPuzzle, 0);
                if (hint) {
                    const [technique, [row, col], value] = hint;
                    const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                    if (cell && !cell.readOnly) {
                        cell.value = value;
                        cell.classList.add('hint');
                        this.currentPuzzle[row][col] = value;
                        this.hintsUsed++;
                        this.updateScore();
                        this.updateGameInfo();
                        
                        if (this.isPuzzleComplete()) {
                            this.completeGame();
                        }
                    }
                }
            }
            
            checkSolution() {
                let hasErrors = false;
                const cells = document.querySelectorAll('.sudoku-cell');
                
                cells.forEach(cell => {
                    if (!cell.readOnly && cell.value) {
                        const row = parseInt(cell.dataset.row);
                        const col = parseInt(cell.dataset.col);
                        const value = parseInt(cell.value);
                        
                        if (!this.isValidMove(row, col, value)) {
                            cell.classList.add('error');
                            hasErrors = true;
                        } else {
                            cell.classList.remove('error');
                        }
                    }
                });
                
                if (hasErrors) {
                    alert('There are errors in your solution. Check the highlighted cells.');
                } else {
                    alert('Looking good so far! Keep going!');
                }
            }
            
            isPuzzleComplete() {
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        if (this.currentPuzzle[row][col] === 0) {
                            return false;
                        }
                    }
                }
                return true;
            }
            
            completeGame() {
                this.stopTimer();
                const finalScore = Math.max(0, this.currentScore);
                
                this.stats.totalCompleted++;
                this.stats.totalScore += finalScore;
                if (finalScore > this.stats.bestScore) {
                    this.stats.bestScore = finalScore;
                }
                this.stats.lastCompletedDate = new Date().toDateString();
                
                document.getElementById('finalScore').textContent = Math.round(finalScore);
                document.getElementById('finalTime').textContent = this.getTimeString();
                document.getElementById('completionModal').classList.add('active');
                
                this.loadStats();
            }
            
            startTimer() {
                this.startTime = Date.now();
                this.gameTimer = setInterval(() => {
                    this.updateTimer();
                    this.updateScore();
                }, 1000);
            }
            
            stopTimer() {
                if (this.gameTimer) {
                    clearInterval(this.gameTimer);
                    this.gameTimer = null;
                }
            }
            
            updateTimer() {
                const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
                document.getElementById('timeDisplay').textContent = this.formatTime(elapsed);
            }
            
            formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }
            
            getTimeString() {
                const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
                return this.formatTime(elapsed);
            }
            
            updateScore() {
                const elapsedMinutes = (Date.now() - this.startTime) / 60000;
                
                if (elapsedMinutes <= 0) {
                    this.currentScore = this.pointsPerMinute;
                    document.getElementById('scoreDisplay').textContent = Math.round(this.currentScore);
                    return;
                }
                
                const baseScore = this.pointsPerMinute / elapsedMinutes;
                const mistakePenalty = Math.pow(0.9, this.mistakes);
                const hintPenalty = Math.pow(0.8, this.hintsUsed);
                
                this.currentScore = baseScore * mistakePenalty * hintPenalty;
                document.getElementById('scoreDisplay').textContent = Math.round(this.currentScore);
            }
            
            updateGameInfo() {
                document.getElementById('currentLevel').textContent = this.currentLevel + 1;
                document.getElementById('mistakeCount').textContent = this.mistakes;
                document.getElementById('hintCount').textContent = this.hintsUsed;
                document.getElementById('complexityDisplay').textContent = Math.round(this.pointsPerMinute);
            }
        }
        
        // Screen navigation functions
        function showHome() {
            if (game) game.showHome();
        }
        
        function startTodaysPuzzle() {
            if (game) game.startTodaysPuzzle();
        }
        
        function changeSkillLevel() {
            if (game) game.showSkillAssessment();
        }
        
        function closeModal() {
            document.getElementById('completionModal').classList.remove('active');
            showHome();
        }
        
        function showSettings() {
            alert('Settings feature coming soon!\n\nYou can change your skill level from the home screen.');
        }
        
        function getHint() {
            if (game) game.getHint();
        }
        
        function checkSolution() {
            if (game) game.checkSolution();
        }
        
        // Initialize the game with extensive debugging
        let game;
        
        debug('=== SCRIPT LOADING ===');
        debug('Script timestamp:', new Date().toISOString());
        debug('Document ready state:', document.readyState);
        debug('User agent:', navigator.userAgent);
        
        function initializeGame() {
            debug('=== INITIALIZE GAME ===');
            
            try {
                if (game) {
                    debug('⚠️ Game already exists, reinitializing...');
                }
                
                debug('Creating SudokuOfTheDay instance...');
                game = new SudokuOfTheDay();
                debug('✅ Game instance created');
                
                debug('Calling game.init()...');
                game.init();
                debug('✅ Game initialization completed');
                
                // Test if skill assessment is visible
                const skillAssessment = document.getElementById('skillAssessment');
                debug('Skill assessment visible?', skillAssessment && skillAssessment.classList.contains('active'));
                debug('Skill assessment height:', skillAssessment ? skillAssessment.offsetHeight : 'N/A');
                
            } catch (error) {
                debugError('❌ Fatal error during game initialization:', error);
                debugError('Stack:', error.stack);
                
                // Show error to user
                const content = document.querySelector('.content');
                if (content) {
                    content.innerHTML = `
                        <div style="text-align: center; padding: 40px; color: #d32f2f;">
                            <h2>⚠️ Initialization Error</h2>
                            <p>There was an error starting the game. Check the console for details.</p>
                            <p style="margin-top: 20px;"><button onclick="location.reload()" class="btn">Reload Page</button></p>
                        </div>
                    `;
                }
            }
        }
        
        // Try multiple initialization methods
        if (document.readyState === 'loading') {
            debug('Document still loading, waiting for DOMContentLoaded...');
            document.addEventListener('DOMContentLoaded', initializeGame);
        } else {
            debug('Document already loaded, initializing immediately...');
            setTimeout(initializeGame, 10);
        }
        
        // Backup initialization
        window.addEventListener('load', () => {
            debug('=== WINDOW LOAD EVENT ===');
            if (!game) {
                debug('Game not initialized yet, trying backup initialization...');
                setTimeout(initializeGame, 100);
            } else {
                debug('Game already initialized');
            }
        });
        
        // Manual initialization function for debugging
        window.debugInit = () => {
            debug('=== MANUAL DEBUG INIT ===');
            initializeGame();
        };
        
        // Add some global debugging helpers
        window.debugGame = () => {
            if (game) {
                debug('Game state:', {
                    userSkillLevel: game.userSkillLevel,
                    skillLevelsCount: game.skillLevels.length,
                    sudokuAvailable: !!game.sudoku,
                    stats: game.stats
                });
            } else {
                debug('No game instance available');
            }
        };
    </script>
