<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mathdoku Print</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
  :root {
    --bg: #0e0e10; --surface: #18181b; --surface2: #222226;
    --border: #2e2e34; --accent: #f97316; --accent2: #fb923c;
    --text: #f4f4f5; --muted: #71717a; --danger: #ef4444;
  }
  body { background: var(--bg); color: var(--text); font-family: 'Segoe UI', system-ui, sans-serif; min-height: 100vh; padding: 16px; }
  h1 { font-size: 1.6rem; font-weight: 900; letter-spacing: -0.04em; }
  h1 span { color: var(--accent); }
  .sub { color: var(--muted); font-size: .8rem; margin-top: 2px; }
  header { display: flex; justify-content: space-between; align-items: flex-start; flex-wrap: wrap; gap: 12px; margin-bottom: 24px; }

  .layout { display: grid; grid-template-columns: 1fr; gap: 20px; }
  @media(min-width: 1100px) { .layout { grid-template-columns: 1fr 380px; } }

  .card { background: var(--surface); border: 1px solid var(--border); border-radius: 16px; padding: 20px; }
  .card-title { font-size: .7rem; font-weight: 800; text-transform: uppercase; letter-spacing: .1em; color: var(--muted); margin-bottom: 14px; }

  .btn { background: var(--surface2); border: 1px solid var(--border); color: var(--text); padding: 8px 16px; border-radius: 8px; font-size: .82rem; font-weight: 700; cursor: pointer; transition: background .15s, transform .1s; user-select: none; }
  .btn:hover { background: #2e2e36; }
  .btn:active { transform: scale(.97); }
  .btn-accent { background: var(--accent); border-color: var(--accent); color: #fff; }
  .btn-accent:hover { background: var(--accent2); }
  .btn-danger { border-color: #3f1818; color: var(--danger); }
  .btn-danger:hover { background: #1f1010; }
  .btn-full { width: 100%; padding: 12px; }
  .btn:disabled { opacity: .4; cursor: not-allowed; pointer-events: none; }

  .option-row { display: flex; flex-direction: column; gap: 6px; margin-bottom: 14px; }
  .option-row label { font-size: .68rem; font-weight: 700; text-transform: uppercase; letter-spacing: .08em; color: var(--muted); }
  .option-row input, .option-row select {
    background: var(--surface2); border: 1px solid var(--border); color: var(--text);
    padding: 9px 12px; border-radius: 8px; font-size: .88rem; font-weight: 700; outline: none; width: 100%;
  }
  .option-row input:focus, .option-row select:focus { border-color: var(--accent); }

  .seg { display: flex; gap: 4px; flex-wrap: wrap; }
  .seg-btn { flex: 1; background: var(--surface2); border: 1px solid var(--border); color: var(--muted); padding: 8px 4px; border-radius: 8px; font-size: .78rem; font-weight: 800; cursor: pointer; transition: all .15s; text-align: center; min-width: 32px; }
  .seg-btn.active { background: var(--accent); border-color: var(--accent); color: #fff; }
  .seg-btn.disabled { opacity: .3; cursor: not-allowed; pointer-events: none; }

  #queueList { display: flex; flex-direction: column; gap: 8px; min-height: 60px; }
  .q-item { background: var(--surface2); border: 1px solid var(--border); border-radius: 10px; padding: 12px 14px; display: flex; justify-content: space-between; align-items: center; gap: 10px; }
  .q-item-info .q-name { font-size: .85rem; font-weight: 800; }
  .q-item-info .q-meta { font-size: .7rem; color: var(--muted); margin-top: 2px; }
  .q-rm { background: none; border: none; color: var(--muted); cursor: pointer; font-size: 1rem; padding: 2px 6px; border-radius: 4px; }
  .q-rm:hover { color: var(--danger); }

  .add-row { display: flex; gap: 8px; margin-top: 12px; }
  .add-row input { flex: 1; background: var(--surface2); border: 1px solid var(--border); color: var(--text); padding: 9px 12px; border-radius: 8px; font-size: .82rem; font-weight: 700; outline: none; }
  .add-row input:focus { border-color: var(--accent); }

  .gen-inline { display: none; flex-direction: column; gap: 8px; margin-top: 10px; background: var(--surface2); border: 1px solid var(--border); border-radius: 10px; padding: 12px; }
  .gen-inline.open { display: flex; }
  .gen-status { display: flex; align-items: center; gap: 8px; font-size: .8rem; font-weight: 700; color: var(--muted); }
  .gen-info { display: flex; justify-content: space-between; font-size: .72rem; font-weight: 700; color: var(--muted); }
  .gen-info b { color: var(--text); }
  .spinner { width: 16px; height: 16px; border: 2px solid var(--border); border-top-color: var(--accent); border-radius: 50%; animation: spin .7s linear infinite; flex-shrink: 0; }
  @keyframes spin { to { transform: rotate(360deg); } }

  .fmt-opts { display: none; padding-top: 10px; }
  .fmt-opts.open { display: block; }

  #preview { background: #fff; border-radius: 12px; overflow: hidden; padding: 12px; }

  @media print {
    body { background: #fff; padding: 0; }
    header, .layout { display: none !important; }
    #printArea { display: block !important; }
  }
  #printArea { display: none; }
</style>
</head>
<body>
<header>
  <div><h1>MATHDOKU<span>.PRINT</span></h1><p class="sub">Build · Configure · Export</p></div>
  <a href="play.html" class="btn">← Back to Play</a>
</header>

<div id="printArea"></div>

<div class="layout">
  <div style="display:flex;flex-direction:column;gap:16px;">
    <div class="card">
      <div class="card-title">Puzzle Queue</div>
      <div id="queueList"><p id="emptyQ" style="color:var(--muted);font-size:.8rem;text-align:center;padding:20px 0;">No puzzles yet.</p></div>

      <div style="margin-top:16px;">
        <div class="card-title" style="margin-bottom:8px;">Add via String</div>
        <div class="add-row">
          <input id="strInput" type="text" placeholder="Paste puzzle string…">
          <button class="btn btn-accent" onclick="addFromString()">Add</button>
        </div>
      </div>

      <div style="margin-top:16px;">
        <div class="card-title" style="margin-bottom:8px;">Add via Generate</div>
        <div class="option-row" style="margin-bottom:8px;">
          <label>Grid Size</label>
          <div class="seg" id="gSzSegs">
            <div class="seg-btn active" data-val="4">4×4</div><div class="seg-btn" data-val="5">5×5</div>
            <div class="seg-btn" data-val="6">6×6</div><div class="seg-btn" data-val="7">7×7</div>
            <div class="seg-btn" data-val="8">8×8</div><div class="seg-btn" data-val="9">9×9</div>
          </div>
        </div>
        <div class="option-row" style="margin-bottom:8px;">
          <label>Difficulty</label>
          <div class="seg" id="gDfSegs">
            <div class="seg-btn active" data-val="any">Any</div><div class="seg-btn" data-val="Easy">Easy</div>
            <div class="seg-btn" data-val="Medium">Med</div><div class="seg-btn" data-val="Hard">Hard</div>
            <div class="seg-btn" data-val="Vicious">Vic</div><div class="seg-btn" data-val="Devilish">Dev</div>
            <div class="seg-btn" data-val="Diabolical">Dia</div><div class="seg-btn" data-val="Beyond Diabolical">BD</div>
          </div>
        </div>
        <div class="option-row" style="margin-bottom:10px;">
          <label>Uniqueness</label>
          <div class="seg" id="gUnSegs">
            <div class="seg-btn active" data-val="guaranteed">Guaranteed</div>
            <div class="seg-btn" data-val="any">Allow non-unique</div>
            <div class="seg-btn" data-val="only">Only non-unique</div>
          </div>
        </div>
        <button class="btn btn-accent" id="genBtn" onclick="startGen()" style="width:100%;">▶ Generate &amp; Add</button>
        <div class="gen-inline" id="genInline">
          <div class="gen-status"><div class="spinner"></div><span>Generating…</span></div>
          <div class="gen-info"><span>Attempts: <b id="genAtt">0</b></span><span>Best: <b id="genBst">—</b></span></div>
          <button class="btn" id="genAccBtn" style="display:none;" onclick="acceptGen()">Accept Best</button>
          <button class="btn btn-danger" onclick="stopGen()">✕ Cancel</button>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="card-title">Preview</div>
      <div id="preview"><p style="color:#999;font-size:.8rem;text-align:center;padding:24px 0;">Add puzzles to preview.</p></div>
    </div>
  </div>

  <div style="display:flex;flex-direction:column;gap:16px;">
    <div class="card">
      <div class="card-title">Sheet Settings</div>
      <div class="option-row">
        <label>Sheet Title</label>
        <input id="sheetTitle" type="text" placeholder="Optional…" oninput="updatePreview()">
      </div>
      <div class="option-row">
        <label>Layout</label>
        <div class="seg" id="layoutSegs">
          <div class="seg-btn active" data-val="1">1pp</div>
          <div class="seg-btn" data-val="2">2pp</div>
          <div class="seg-btn" data-val="4">4pp</div>
        </div>
      </div>
      <div class="option-row">
        <label>Solution</label>
        <div class="seg" id="solSegs">
          <div class="seg-btn active" data-val="none">None</div>
          <div class="seg-btn" data-val="below">Below each</div>
          <div class="seg-btn" data-val="page">Sep. page</div>
        </div>
      </div>
      <div class="option-row">
        <label>Puzzle Number</label>
        <div class="seg" id="numSegs">
          <div class="seg-btn active" data-val="yes">Yes</div>
          <div class="seg-btn" data-val="no">No</div>
        </div>
      </div>
      <div class="option-row" style="margin-bottom:0;">
        <label>Difficulty Label</label>
        <div class="seg" id="diffSegs">
          <div class="seg-btn active" data-val="none">None</div>
          <div class="seg-btn" data-val="name">Name</div>
          <div class="seg-btn" data-val="both">Name + Score</div>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="card-title">Export</div>
      <div class="option-row">
        <label>Format</label>
        <div class="seg" id="fmtSegs">
          <div class="seg-btn active" data-val="pdf">PDF</div>
          <div class="seg-btn" data-val="pdf-qr">PDF+QR</div>
          <div class="seg-btn" data-val="png">PNG</div>
          <div class="seg-btn" data-val="qr">QR</div>
        </div>
      </div>

      <div class="fmt-opts open" id="optPdf"></div>
      <div class="fmt-opts" id="optPdfQr">
        <div class="option-row" style="margin-bottom:0;">
          <label>QR Size</label>
          <div class="seg" id="qrSzSegs">
            <div class="seg-btn" data-val="80">Small</div>
            <div class="seg-btn active" data-val="140">Medium</div>
            <div class="seg-btn" data-val="200">Large</div>
          </div>
        </div>
      </div>
      <div class="fmt-opts" id="optPng">
        <div class="option-row">
          <label>Width (px)</label>
          <input id="pngPx" type="number" value="1200" min="400" max="4000" step="100">
        </div>
        <div class="option-row" style="margin-bottom:0;">
          <label>ZIP</label>
          <div class="seg" id="pngZipSegs">
            <div class="seg-btn" data-val="no">No</div>
            <div class="seg-btn active" data-val="auto">Auto</div>
            <div class="seg-btn" data-val="yes">Yes</div>
          </div>
        </div>
      </div>
      <div class="fmt-opts" id="optQr">
        <div class="option-row">
          <label>Width (px)</label>
          <input id="qrPx" type="number" value="400" min="100" max="1000" step="50">
        </div>
        <div class="option-row" style="margin-bottom:0;">
          <label>ZIP</label>
          <div class="seg" id="qrZipSegs">
            <div class="seg-btn" data-val="no">No</div>
            <div class="seg-btn active" data-val="auto">Auto</div>
            <div class="seg-btn" data-val="yes">Yes</div>
          </div>
        </div>
      </div>

      <button class="btn btn-accent btn-full" id="exportBtn" onclick="doExport()" style="margin-top:14px;" disabled>Export</button>
    </div>
  </div>
</div>

<script src="solver.js"></script>
<script>
const $ = id => document.getElementById(id);
const sleep = ms => new Promise(r => setTimeout(r, ms));

function segVal(id) { return $(id)?.querySelector('.seg-btn.active')?.dataset.val; }
document.querySelectorAll('.seg').forEach(seg => {
  seg.addEventListener('click', e => {
    const btn = e.target.closest('.seg-btn');
    if (!btn || btn.classList.contains('disabled')) return;
    seg.querySelectorAll('.seg-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    const id = seg.id;
    if (id === 'fmtSegs') syncFmtOpts();
    if (['layoutSegs','solSegs','numSegs','diffSegs'].includes(id)) updatePreview();
    if (id === 'gSzSegs') applyGenRestrict(parseInt(btn.dataset.val));
  });
});

function syncFmtOpts() {
  const fmt = segVal('fmtSegs');
  ['pdf','pdf-qr','png','qr'].forEach(f => {
    const el = $('opt' + {pdf:'Pdf','pdf-qr':'PdfQr',png:'Png',qr:'Qr'}[f]);
    if (el) el.classList.toggle('open', fmt === f);
  });
}

function applyGenRestrict(size) {
  const btns = [...$('gDfSegs').querySelectorAll('.seg-btn')];
  btns.forEach(b => b.classList.remove('disabled'));
  if (size === 9) {
    btns.forEach(b => { if (b.dataset.val !== 'any') b.classList.add('disabled'); });
    if (segVal('gDfSegs') !== 'any') { btns.forEach(b => b.classList.remove('active')); $('gDfSegs').querySelector('[data-val="any"]').classList.add('active'); }
  } else if (size === 8) {
    const bd = $('gDfSegs').querySelector('[data-val="Beyond Diabolical"]');
    bd.classList.add('disabled');
    if (segVal('gDfSegs') === 'Beyond Diabolical') { btns.forEach(b => b.classList.remove('active')); $('gDfSegs').querySelector('[data-val="any"]').classList.add('active'); }
  }
}

// ── Queue ─────────────────────────────────────────────────────────────────────
let queue = [];

function addFromString() {
  const s = $('strInput').value.trim(); if (!s) return;
  try { addPuzzle(JSON.parse(atob(s)), s); $('strInput').value = ''; }
  catch(e) { alert('Invalid puzzle string.'); }
}

function addPuzzle(puz, enc) {
  const res = MathdokuSolver.solve(puz, {maxSolutions:1});
  if (!res) { alert('No solution found.'); return; }
  const rating = MathdokuSolver.rate(puz);
  enc = enc || btoa(JSON.stringify({size:puz.size, cages:puz.cages, givens:puz.givens||[]}));
  queue.push({puz, rating, solution:res.grid, enc});
  renderQueue(); updatePreview();
}

function removePuzzle(i) { queue.splice(i,1); renderQueue(); updatePreview(); }

function renderQueue() {
  const el = $('queueList');
  if (!queue.length) { el.innerHTML='<p style="color:var(--muted);font-size:.8rem;text-align:center;padding:20px 0;">No puzzles yet.</p>'; $('exportBtn').disabled=true; return; }
  $('exportBtn').disabled = false;
  el.innerHTML = queue.map((item,i) =>
    `<div class="q-item">
      <div class="q-item-info">
        <div class="q-name">#${i+1} · ${item.puz.size}×${item.puz.size}</div>
        <div class="q-meta">${item.rating.difficulty} · ${item.rating.score}</div>
      </div>
      <button class="q-rm" onclick="removePuzzle(${i})">✕</button>
    </div>`
  ).join('');
}

// ── Generation ────────────────────────────────────────────────────────────────
const DIFF_BANDS = {'Easy':[0,.5],'Medium':[.5,1.2],'Hard':[1.2,1.6],'Vicious':[1.6,2.5],'Devilish':[2.5,3.4],'Diabolical':[3.4,5],'Beyond Diabolical':[5,Infinity]};
function diffProx(score,t) {
  if (t==='any') return 0;
  const b=DIFF_BANDS[t]; if (!b) return Infinity;
  if (score>=b[0]&&score<b[1]) return 0;
  return score<b[0]?b[0]-score:score-b[1];
}

let genRunning=false, genBestPuz=null, genBestProx=Infinity;

function stopGen() { genRunning=false; $('genInline').classList.remove('open'); $('genBtn').disabled=false; }

async function startGen() {
  const size=parseInt(segVal('gSzSegs')), diff=segVal('gDfSegs'), uniq=segVal('gUnSegs');
  genRunning=true; genBestPuz=null; genBestProx=Infinity;
  $('genBtn').disabled=true; $('genInline').classList.add('open');
  $('genAtt').textContent='0'; $('genBst').textContent='—'; $('genAccBtn').style.display='none';
  await sleep(0);
  let att=0;
  while (genRunning) {
    att++;
    const puz=randomPuzzle(size);
    const sr=MathdokuSolver.solve(puz,{maxSolutions:2});
    if (!sr) { await maybeYield(att); continue; }
    const isUniq=sr.solutions.length===1;
    if (uniq==='guaranteed'&&!isUniq) { await maybeYield(att); continue; }
    if (uniq==='only'&&isUniq) { await maybeYield(att); continue; }
    const rating=MathdokuSolver.rate(puz);
    const prox=diffProx(rating.score,diff);
    if (prox<genBestProx) {
      genBestProx=prox; genBestPuz=puz;
      $('genBst').textContent=rating.difficulty+' ('+rating.score+')';
      $('genAccBtn').style.display='';
    }
    await maybeYield(att);
    if (!genRunning) return;
    if (prox===0) { stopGen(); addPuzzle(puz); return; }
  }
}
function acceptGen() { if (genBestPuz) { stopGen(); addPuzzle(genBestPuz); } }
async function maybeYield(att) { if (att%3===0) { $('genAtt').textContent=att; await sleep(0); } }

// ── Puzzle builders ───────────────────────────────────────────────────────────
function randomPuzzle(size) { return {size,cages:carveCages(randomLatinSquare(size),size),givens:[]}; }
function randomLatinSquare(size) {
  const g=Array.from({length:size},()=>new Array(size).fill(0));
  const rU=new Array(size).fill(0),cU=new Array(size).fill(0);
  function bt(pos) {
    if (pos===size*size) return true;
    const r=Math.floor(pos/size),c=pos%size,used=rU[r]|cU[c];
    for (const v of shuffle(Array.from({length:size},(_,i)=>i+1))) {
      const bit=1<<v; if (used&bit) continue;
      g[r][c]=v; rU[r]|=bit; cU[c]|=bit;
      if (bt(pos+1)) return true;
      g[r][c]=0; rU[r]&=~bit; cU[c]&=~bit;
    }
    return false;
  }
  bt(0); return g;
}
function carveCages(grid,size) {
  const asgn=Array.from({length:size},()=>new Array(size).fill(false)),cages=[];
  for (const flat of shuffle(Array.from({length:size*size},(_,i)=>i))) {
    const r=Math.floor(flat/size),c=flat%size;
    if (asgn[r][c]) continue;
    const cells=[[r,c]]; asgn[r][c]=true;
    const mx=size<=5?4:size<=7?3:2;
    for (let t=0;t<mx-1;t++) {
      const cands=[];
      for (const [cr,cc] of cells) for (const [dr,dc] of [[-1,0],[1,0],[0,-1],[0,1]]) {
        const nr=cr+dr,nc=cc+dc;
        if (nr>=0&&nr<size&&nc>=0&&nc<size&&!asgn[nr][nc]) cands.push([nr,nc]);
      }
      if (!cands.length) break;
      const [nr,nc]=cands[Math.floor(Math.random()*cands.length)];
      cells.push([nr,nc]); asgn[nr][nc]=true;
    }
    const vals=cells.map(([cr,cc])=>grid[cr][cc]);
    cages.push({id:Date.now()+cages.length,cells,...chooseOp(vals)});
  }
  return cages;
}
function chooseOp(vals) {
  if (vals.length===1) return {op:'=',target:vals[0]};
  const ops=['+','*'],s=[...vals].sort((a,b)=>b-a);
  const sub=s.slice(1).reduce((a,v)=>a-v,s[0]),div=s.slice(1).reduce((a,v)=>a/v,s[0]);
  if (sub>0) ops.push('-');
  if (Number.isInteger(div)&&div>0) ops.push('/');
  const op=ops[Math.floor(Math.random()*ops.length)];
  return {op,target:op==='+'?vals.reduce((a,b)=>a+b,0):op==='*'?vals.reduce((a,b)=>a*b,1):op==='-'?sub:div};
}
function shuffle(arr) { for (let i=arr.length-1;i>0;i--) { const j=Math.floor(Math.random()*(i+1));[arr[i],arr[j]]=[arr[j],arr[i]]; } return arr; }

// ── Canvas renderer ───────────────────────────────────────────────────────────
function puzzleToCanvas(item, px, showSol) {
  const {puz,solution}=item, N=puz.size;
  const PAD=Math.round(px*.045), g=px-PAD*2, cell=g/N;
  const cv=document.createElement('canvas'); cv.width=px; cv.height=px;
  const ctx=cv.getContext('2d');
  ctx.fillStyle='#fff'; ctx.fillRect(0,0,px,px);
  const c2cage=Array.from({length:N},()=>new Array(N).fill(-1));
  puz.cages.forEach((cage,ci)=>cage.cells.forEach(([r,c])=>c2cage[r][c]=ci));
  const THIN=Math.max(1,Math.round(cell*.018)), THICK=Math.max(2,Math.round(cell*.065));
  for (let r=0;r<N;r++) for (let c=0;c<N;c++) {
    const x=PAD+c*cell, y=PAD+r*cell;
    const ci=c2cage[r][c], cage=ci!==-1?puz.cages[ci]:null;
    const inC=(rr,cc)=>cage&&cage.cells.some(([a,b])=>a===rr&&b===cc);
    ctx.strokeStyle='#111';
    const sides=[
      [r===0||!inC(r-1,c)?THICK:THIN, x,y,x+cell,y],
      [r===N-1||!inC(r+1,c)?THICK:THIN, x,y+cell,x+cell,y+cell],
      [c===0||!inC(r,c-1)?THICK:THIN, x,y,x,y+cell],
      [c===N-1||!inC(r,c+1)?THICK:THIN, x+cell,y,x+cell,y+cell],
    ];
    for (const [lw,x1,y1,x2,y2] of sides) {
      ctx.lineWidth=lw; ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
    }
    if (showSol) {
      ctx.fillStyle='#111'; ctx.font=`bold ${Math.round(cell*.48)}px Segoe UI,sans-serif`;
      ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(solution[r][c],x+cell/2,y+cell/2);
    }
  }
  for (let r=0;r<N;r++) for (let c=0;c<N;c++) {
    const ci=c2cage[r][c]; if (ci===-1) continue;
    const cage=puz.cages[ci];
    const sorted=[...cage.cells].sort((a,b)=>(a[0]*N+a[1])-(b[0]*N+b[1]));
    if (sorted[0][0]!==r||sorted[0][1]!==c) continue;
    const x=PAD+c*cell, y=PAD+r*cell;
    const fs=Math.round(cell*.21);
    ctx.fillStyle='#111'; ctx.font=`bold ${fs}px Segoe UI,sans-serif`;
    ctx.textAlign='left'; ctx.textBaseline='top';
    ctx.fillText(cage.target+(cage.op==='='?'':cage.op), x+THICK+2, y+THICK+1);
  }
  ctx.strokeStyle='#111'; ctx.lineWidth=THICK*1.5;
  ctx.strokeRect(PAD,PAD,g,g);
  return cv;
}

// ── QR canvas ─────────────────────────────────────────────────────────────────
function qrToCanvas(enc, size) {
  return new Promise((res,rej) => {
    const url = 'https://api.qrserver.com/v1/create-qr-code/?size='+size+'x'+size+'&data='
      + encodeURIComponent(location.origin+location.pathname.replace('print.html','play.html')+'?p='+enc);
    const img = new Image(); img.crossOrigin='anonymous';
    img.onload = () => {
      const cv=document.createElement('canvas'); cv.width=size; cv.height=size;
      cv.getContext('2d').drawImage(img,0,0,size,size); res(cv);
    };
    img.onerror = () => rej(new Error('QR fetch failed'));
    img.src = url;
  });
}

// ── Helpers ───────────────────────────────────────────────────────────────────
function diffText(item) {
  const mode = segVal('diffSegs');
  if (mode==='none') return '';
  if (mode==='name') return item.rating.difficulty;
  return item.rating.difficulty+' ('+item.rating.score+')';
}

// layout → {cols, rows}
// 1pp: 1×1, 2pp: 1×2 (stacked), 4pp: 2×2
function layoutGrid(layout) {
  if (layout===1) return {cols:1,rows:1};
  if (layout===2) return {cols:1,rows:2};
  return {cols:2,rows:2}; // 4pp
}

// ── Preview ───────────────────────────────────────────────────────────────────
function updatePreview() {
  const pv=$('preview');
  if (!queue.length) { pv.innerHTML='<p style="color:#999;font-size:.8rem;text-align:center;padding:24px 0;">Add puzzles to preview.</p>'; return; }
  const layout=parseInt(segVal('layoutSegs'));
  const {cols}=layoutGrid(layout);
  const showSol=segVal('solSegs'), showNum=segVal('numSegs')==='yes';
  const title=$('sheetTitle').value.trim();
  const pvPx = cols===1?260:180;
  pv.innerHTML='';

  const pages=[];
  for (let i=0;i<queue.length;i+=layout) pages.push(queue.slice(i,i+layout));

  pages.forEach((page,pi) => {
    const pageEl=document.createElement('div');
    pageEl.style.cssText=`background:#fff;padding:12px;display:grid;gap:8px;grid-template-columns:repeat(${cols},1fr);margin-bottom:8px;border-radius:8px;`;
    if (pi===0&&title) {
      const t=document.createElement('div');
      t.style.cssText=`grid-column:1/-1;text-align:center;font-size:12px;font-weight:900;color:#111;padding-bottom:6px;border-bottom:2px solid #111;font-family:sans-serif;`;
      t.textContent=title; pageEl.appendChild(t);
    }
    page.forEach((item,j) => {
      const idx=pi*layout+j;
      const wrap=document.createElement('div');
      wrap.style.cssText='display:flex;flex-direction:column;align-items:center;gap:3px;';
      if (showNum) {
        const num=document.createElement('div');
        num.style.cssText='font-family:sans-serif;font-size:9px;font-weight:900;color:#111;align-self:flex-start;';
        num.textContent='#'+(idx+1); wrap.appendChild(num);
      }
      const cv=puzzleToCanvas(item,pvPx,false);
      cv.style.cssText='width:100%;height:auto;border:1px solid #ddd;'; wrap.appendChild(cv);
      const dt=diffText(item);
      if (dt) {
        const lbl=document.createElement('div');
        lbl.style.cssText='font-family:sans-serif;font-size:8px;color:#555;text-align:center;';
        lbl.textContent=dt; wrap.appendChild(lbl);
      }
      if (showSol==='below') {
        const sc=puzzleToCanvas(item,pvPx,true);
        sc.style.cssText='width:100%;height:auto;border:1px solid #ddd;opacity:.75;margin-top:2px;'; wrap.appendChild(sc);
      }
      pageEl.appendChild(wrap);
    });
    pv.appendChild(pageEl);
    if (pi<pages.length-1) { const hr=document.createElement('div'); hr.style.cssText='height:1px;background:#ddd;margin:4px 0;'; pv.appendChild(hr); }
  });

  if (showSol==='page') {
    const hr=document.createElement('div'); hr.style.cssText='height:1px;background:#ddd;margin:4px 0;'; pv.appendChild(hr);
    pages.forEach((page,pi) => {
      const pageEl=document.createElement('div');
      pageEl.style.cssText=`background:#fff;padding:12px;display:grid;gap:8px;grid-template-columns:repeat(${cols},1fr);margin-bottom:8px;border-radius:8px;`;
      const hdr=document.createElement('div');
      hdr.style.cssText='grid-column:1/-1;text-align:center;font-size:10px;font-weight:900;color:#111;font-family:sans-serif;padding-bottom:4px;border-bottom:1px solid #ccc;';
      hdr.textContent='Solutions'+(title?' — '+title:''); pageEl.appendChild(hdr);
      page.forEach((item,j) => {
        const idx=pi*layout+j;
        const wrap=document.createElement('div');
        wrap.style.cssText='display:flex;flex-direction:column;align-items:center;gap:3px;';
        if (showNum) {
          const num=document.createElement('div');
          num.style.cssText='font-family:sans-serif;font-size:9px;font-weight:900;color:#111;align-self:flex-start;';
          num.textContent='#'+(idx+1); wrap.appendChild(num);
        }
        const sc=puzzleToCanvas(item,pvPx,true);
        sc.style.cssText='width:100%;height:auto;border:1px solid #ddd;'; wrap.appendChild(sc);
        pageEl.appendChild(wrap);
      });
      pv.appendChild(pageEl);
    });
  }
}

// ── Export ────────────────────────────────────────────────────────────────────
async function doExport() {
  const fmt=segVal('fmtSegs');
  $('exportBtn').disabled=true; $('exportBtn').textContent='Exporting…';
  try {
    if (fmt==='pdf'||fmt==='pdf-qr') await exportPDF(fmt==='pdf-qr');
    else if (fmt==='png') await exportPNG();
    else if (fmt==='qr') await exportQROnly();
  } finally {
    $('exportBtn').disabled=false; $('exportBtn').textContent='Export';
  }
}

// A4 portrait at 96dpi
const PAGE_W=794, PAGE_H=1123, PAD=45, GAP=8;

function calcPuzPx(layout, hasNum, hasDiff) {
  const {cols,rows}=layoutGrid(layout);
  const titleH=($('sheetTitle').value.trim())?28:0;
  const cellW=Math.floor((PAGE_W-PAD*2-(cols-1)*GAP)/cols);
  const cellH=Math.floor((PAGE_H-PAD*2-titleH-(rows-1)*GAP)/rows);
  const numH=hasNum?20:0, diffH=hasDiff?18:0;
  return Math.min(cellW, cellH-numH-diffH);
}

function buildPageEl(cols, rows, titleH, isFirst, title, isSolPage) {
  const el=document.createElement('div');
  const rowTemplate=titleH&&isFirst ? `${titleH}px repeat(${rows},1fr)` : `repeat(${rows},1fr)`;
  el.style.cssText=`background:#fff;width:${PAGE_W}px;height:${PAGE_H}px;padding:${PAD}px;`
    +`display:grid;gap:${GAP}px;grid-template-columns:repeat(${cols},1fr);`
    +`grid-template-rows:${rowTemplate};page-break-after:always;box-sizing:border-box;overflow:hidden;`;
  if (isFirst&&title) {
    const t=document.createElement('div');
    t.style.cssText=`grid-column:1/-1;text-align:center;font-size:14pt;font-weight:900;color:#111;`
      +`border-bottom:2pt solid #111;font-family:sans-serif;display:flex;align-items:center;justify-content:center;`;
    t.textContent=isSolPage?('Solutions'+(title?' — '+title:'')):(title||'');
    el.appendChild(t);
  } else if (isSolPage&&!title) {
    const t=document.createElement('div');
    t.style.cssText=`grid-column:1/-1;text-align:center;font-size:14pt;font-weight:900;color:#111;`
      +`border-bottom:2pt solid #111;font-family:sans-serif;display:flex;align-items:center;justify-content:center;`;
    t.textContent='Solutions'; el.appendChild(t);
  }
  return el;
}

function buildPuzWrap(item, idx, puzPx, showNum, showSol, solMode) {
  const wrap=document.createElement('div');
  wrap.style.cssText='display:flex;flex-direction:column;align-items:center;justify-content:center;gap:2px;overflow:hidden;';
  if (showNum) {
    const num=document.createElement('div');
    num.style.cssText='font-family:sans-serif;font-size:10pt;font-weight:900;color:#111;align-self:flex-start;flex-shrink:0;';
    num.textContent='#'+(idx+1); wrap.appendChild(num);
  }
  const cv=puzzleToCanvas(item,puzPx,false);
  cv.style.cssText=`display:block;width:${puzPx}px;height:${puzPx}px;flex-shrink:0;`; wrap.appendChild(cv);
  const dt=diffText(item);
  if (dt) {
    const lbl=document.createElement('div');
    lbl.style.cssText='font-family:sans-serif;font-size:8pt;color:#555;flex-shrink:0;';
    lbl.textContent=dt; wrap.appendChild(lbl);
  }
  if (solMode==='below') {
    const sc=puzzleToCanvas(item,puzPx,true);
    sc.style.cssText=`display:block;width:${puzPx}px;height:${puzPx}px;opacity:.8;margin-top:2px;flex-shrink:0;`; wrap.appendChild(sc);
  }
  return wrap;
}

async function exportPDF(withQR) {
  const layout=parseInt(segVal('layoutSegs'));
  const qrSz=withQR?parseInt(segVal('qrSzSegs')):0;
  const showSol=segVal('solSegs'), showNum=segVal('numSegs')==='yes';
  const title=$('sheetTitle').value.trim();
  const {cols,rows}=layoutGrid(layout);
  const hasDiff=segVal('diffSegs')!=='none';
  const puzPx=calcPuzPx(layout, showNum, hasDiff);
  const titleH=title?28:0;

  const area=$('printArea'); area.innerHTML='';
  let styleEl=$('printOrientStyle');
  if (!styleEl) { styleEl=document.createElement('style'); styleEl.id='printOrientStyle'; document.head.appendChild(styleEl); }
  styleEl.textContent=`@media print { @page { size: A4 portrait; margin: 0; } }`;

  const pages=[];
  for (let i=0;i<queue.length;i+=layout) pages.push(queue.slice(i,i+layout));

  // Puzzle pages
  for (let pi=0;pi<pages.length;pi++) {
    const page=pages[pi];
    const pageEl=buildPageEl(cols, rows, titleH, pi===0, title, false);
    page.forEach((item,j) => {
      pageEl.appendChild(buildPuzWrap(item, pi*layout+j, puzPx, showNum, true, showSol==='below'?'below':'none'));
    });
    area.appendChild(pageEl);
  }

  // QR page
  if (withQR) {
    const qrCols=Math.min(queue.length,4);
    const qrPage=document.createElement('div');
    qrPage.style.cssText=`background:#fff;width:${PAGE_W}px;min-height:${PAGE_H}px;padding:${PAD}px;page-break-before:always;box-sizing:border-box;`;
    const hdr=document.createElement('div');
    hdr.style.cssText='font-family:sans-serif;font-size:13pt;font-weight:900;color:#111;margin-bottom:20px;';
    hdr.textContent='Scan to play on mobile'+(title?' — '+title:''); qrPage.appendChild(hdr);
    const grid=document.createElement('div');
    grid.style.cssText=`display:grid;grid-template-columns:repeat(${qrCols},auto);gap:16px;align-items:start;`;
    for (let i=0;i<queue.length;i++) {
      const cell=document.createElement('div');
      cell.style.cssText='display:flex;flex-direction:column;align-items:center;gap:4px;';
      try {
        const qc=await qrToCanvas(queue[i].enc,qrSz);
        qc.style.cssText='display:block;'; cell.appendChild(qc);
      } catch(e) {}
      if (showNum) {
        const lbl=document.createElement('div');
        lbl.style.cssText='font-family:sans-serif;font-size:9pt;font-weight:900;color:#111;';
        lbl.textContent='#'+(i+1); cell.appendChild(lbl);
      }
      grid.appendChild(cell);
    }
    qrPage.appendChild(grid); area.appendChild(qrPage);
  }

  // Solution pages
  if (showSol==='page') {
    const solTitleH=28;
    const solPuzPx=calcPuzPx(layout, showNum, false);
    for (let pi=0;pi<pages.length;pi++) {
      const page=pages[pi];
      const pageEl=buildPageEl(cols, rows, solTitleH, true, title, true);
      page.forEach((item,j) => {
        const wrap=document.createElement('div');
        wrap.style.cssText='display:flex;flex-direction:column;align-items:center;justify-content:center;gap:2px;overflow:hidden;';
        if (showNum) {
          const num=document.createElement('div');
          num.style.cssText='font-family:sans-serif;font-size:10pt;font-weight:900;color:#111;align-self:flex-start;flex-shrink:0;';
          num.textContent='#'+(pi*layout+j+1); wrap.appendChild(num);
        }
        const sc=puzzleToCanvas(item,solPuzPx,true);
        sc.style.cssText=`display:block;width:${solPuzPx}px;height:${solPuzPx}px;flex-shrink:0;`; wrap.appendChild(sc);
        pageEl.appendChild(wrap);
      });
      area.appendChild(pageEl);
    }
  }

  window.print();
}

async function exportPNG() {
  const px=parseInt($('pngPx').value)||1200;
  const zip=segVal('pngZipSegs');
  const showSol=segVal('solSegs'), showNum=segVal('numSegs')==='yes';
  const doZip=zip==='yes'||(zip==='auto'&&queue.length>1);
  const blobs=[];
  for (let i=0;i<queue.length;i++) {
    const item=queue[i];
    const numH=showNum?Math.round(px*.06):0;
    const dt=diffText(item);
    const lblH=dt?Math.round(px*.05):0;
    const solH=showSol==='below'?px:0;
    const totalH=numH+px+lblH+solH;
    const cv=document.createElement('canvas'); cv.width=px; cv.height=totalH;
    const ctx=cv.getContext('2d');
    ctx.fillStyle='#fff'; ctx.fillRect(0,0,px,totalH);
    let y=0;
    if (showNum) {
      ctx.fillStyle='#111'; ctx.textAlign='left'; ctx.textBaseline='middle';
      ctx.font=`bold ${Math.round(numH*.6)}px Segoe UI,sans-serif`;
      ctx.fillText('#'+(i+1), Math.round(px*.03), y+numH/2); y+=numH;
    }
    ctx.drawImage(puzzleToCanvas(item,px,false),0,y); y+=px;
    if (dt) {
      ctx.fillStyle='#555'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.font=`${Math.round(lblH*.55)}px Segoe UI,sans-serif`;
      ctx.fillText(dt, px/2, y+lblH/2); y+=lblH;
    }
    if (showSol==='below') ctx.drawImage(puzzleToCanvas(item,px,true),0,y);
    blobs.push({name:`puzzle_${i+1}.png`,cv});
  }
  await downloadCanvases(blobs, doZip, 'mathdoku_puzzles.zip');
}

async function exportQROnly() {
  const px=parseInt($('qrPx').value)||400;
  const zip=segVal('qrZipSegs');
  const doZip=zip==='yes'||(zip==='auto'&&queue.length>1);
  const blobs=[];
  for (let i=0;i<queue.length;i++) {
    try {
      const cv=await qrToCanvas(queue[i].enc,px);
      blobs.push({name:`qr_${i+1}.png`,cv});
    } catch(e) { alert('QR generation failed for puzzle #'+(i+1)+'. Check your internet connection.'); return; }
  }
  await downloadCanvases(blobs, doZip, 'mathdoku_qr.zip');
}

async function downloadCanvases(blobs, doZip, zipName) {
  if (doZip) {
    const z=new JSZip();
    for (const {name,cv} of blobs) z.file(name, cv.toDataURL('image/png').split(',')[1], {base64:true});
    const blob=await z.generateAsync({type:'blob'}); dlBlob(blob,zipName);
  } else {
    for (const {name,cv} of blobs) cv.toBlob(b=>dlBlob(b,name),'image/png');
  }
}

function dlBlob(blob,name) {
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=name; a.click();
  setTimeout(()=>URL.revokeObjectURL(a.href),5000);
}

window.addEventListener('DOMContentLoaded', () => {
  const p=new URLSearchParams(location.search).get('p');
  if (p) { try { addPuzzle(JSON.parse(atob(p)),p); } catch(e){} }
  syncFmtOpts();
});
</script>
</body>
</html>
