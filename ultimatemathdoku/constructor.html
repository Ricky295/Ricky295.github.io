<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mathdoku Constructor</title>
<script src="solver.js"></script>
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
  :root {
    --bg: #0e0e10;
    --surface: #18181b;
    --surface2: #222226;
    --border: #2e2e34;
    --accent: #f97316;
    --accent2: #fb923c;
    --text: #f4f4f5;
    --muted: #71717a;
    --danger: #ef4444;
    --success: #22c55e;
    --easy: #22c55e;
    --medium: #3b82f6;
    --hard: #eab308;
    --vicious: #f97316;
    --devilish: #ef4444;
    --diabolical: #a855f7;
    --beyond: #ec4899;
  }
  body { background: var(--bg); color: var(--text); font-family: 'Segoe UI', system-ui, sans-serif; min-height: 100vh; padding: 16px; }
  h1 { font-size: 1.6rem; font-weight: 900; letter-spacing: -0.04em; }
  h1 span { color: var(--accent); }
  .sub { color: var(--muted); font-size: .8rem; margin-top: 2px; }

  header { display: flex; justify-content: space-between; align-items: flex-start; flex-wrap: wrap; gap: 12px; margin-bottom: 24px; }
  .header-btns { display: flex; gap: 8px; flex-wrap: wrap; }

  .btn { background: var(--surface2); border: 1px solid var(--border); color: var(--text); padding: 8px 16px; border-radius: 8px; font-size: .82rem; font-weight: 700; cursor: pointer; transition: background .15s, transform .1s; user-select: none; }
  .btn:hover { background: #2e2e36; }
  .btn:active { transform: scale(.97); }
  .btn-accent { background: var(--accent); border-color: var(--accent); color: #fff; }
  .btn-accent:hover { background: var(--accent2); }
  .btn-danger { border-color: #3f1818; color: var(--danger); }
  .btn-danger:hover { background: #1f1010; }

  .layout { display: grid; grid-template-columns: 1fr; gap: 20px; }
  @media(min-width: 900px) { .layout { grid-template-columns: 1fr 380px; } }

  .card { background: var(--surface); border: 1px solid var(--border); border-radius: 16px; padding: 20px; }
  .card-title { font-size: .7rem; font-weight: 800; text-transform: uppercase; letter-spacing: .1em; color: var(--muted); margin-bottom: 14px; }

  /* Grid */
  #gridWrap { display: flex; justify-content: center; }
  #gridEl { display: grid; border: 3px solid var(--text); background: var(--border); gap: 1px; touch-action: none; user-select: none; }
  .cell {
    width: 100%; aspect-ratio: 1;
    background: var(--surface);
    display: flex; align-items: center; justify-content: center;
    font-size: clamp(.9rem, 3vw, 1.4rem); font-weight: 800;
    position: relative; cursor: pointer;
    transition: background .1s;
    border: 2px solid transparent;
  }
  .cell.free:hover { background: #222228; }
  .cell.selected { background: #1c2a3a; border-color: #3b82f6; z-index: 2; }
  .cell.given { color: var(--accent); }
  .cell.caged { cursor: default; }
  .cage-label {
    position: absolute; top: 2px; left: 4px;
    font-size: clamp(.45rem, 1.2vw, .65rem); font-weight: 900;
    color: var(--text); pointer-events: none; line-height: 1;
  }
  /* thick cage borders */
  .bt { border-top: 3px solid var(--text) !important; }
  .bb { border-bottom: 3px solid var(--text) !important; }
  .bl { border-left: 3px solid var(--text) !important; }
  .br { border-right: 3px solid var(--text) !important; }

  /* Cage form */
  .cage-form { display: flex; flex-wrap: wrap; gap: 10px; align-items: flex-end; margin-top: 16px; padding: 16px; background: var(--surface2); border-radius: 12px; border: 1px solid var(--border); }
  .form-group { display: flex; flex-direction: column; gap: 4px; }
  .form-group label { font-size: .65rem; font-weight: 800; text-transform: uppercase; letter-spacing: .08em; color: var(--muted); }
  .form-group input, .form-group select {
    background: var(--bg); border: 1px solid var(--border); color: var(--text);
    padding: 8px 12px; border-radius: 8px; font-size: .88rem; font-weight: 700;
    outline: none; width: 110px;
  }
  .form-group input:focus, .form-group select:focus { border-color: var(--accent); }
  .sel-status { font-size: .7rem; font-weight: 700; color: var(--muted); margin-left: auto; align-self: center; }

  /* Solution map */
  #solMap { display: grid; gap: 2px; margin-top: 8px; }
  .sol-cell {
    aspect-ratio: 1; background: var(--surface2); border: 1px solid var(--border);
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    font-weight: 900; font-size: clamp(.7rem, 2vw, 1rem); border-radius: 4px;
  }
  .sol-cell.confirmed { color: var(--success); }
  .sol-cell.ambiguous { color: #f472b6; }
  .sol-cands { font-size: clamp(.35rem, 1vw, .5rem); color: var(--muted); line-height: 1.2; text-align: center; }

  /* Rating */
  #ratingBox { border-radius: 12px; padding: 20px; text-align: center; border: 2px solid var(--border); margin-bottom: 12px; }
  #ratingBox .rank { font-size: 1.5rem; font-weight: 900; letter-spacing: -.03em; }
  #ratingBox .score { font-size: .75rem; color: var(--muted); font-weight: 700; margin-top: 4px; }

  /* Cage list */
  #cageList { display: flex; flex-direction: column; gap: 6px; max-height: 280px; overflow-y: auto; }
  #cageList::-webkit-scrollbar { width: 4px; }
  #cageList::-webkit-scrollbar-thumb { background: var(--border); border-radius: 4px; }
  .cage-item { display: flex; justify-content: space-between; align-items: center; background: var(--surface2); border: 1px solid var(--border); border-radius: 8px; padding: 8px 12px; font-size: .8rem; }
  .cage-item .cage-name { font-weight: 800; color: var(--accent); }
  .cage-item .cage-meta { color: var(--muted); font-size: .72rem; margin-top: 1px; }
  .cage-rm { background: none; border: none; color: var(--muted); cursor: pointer; font-size: 1rem; line-height: 1; padding: 2px 6px; border-radius: 4px; transition: color .15s; }
  .cage-rm:hover { color: var(--danger); }

  /* Coverage bar */
  .cov-bar-wrap { height: 4px; background: var(--border); border-radius: 4px; margin-bottom: 6px; overflow: hidden; }
  .cov-bar { height: 100%; background: var(--accent); border-radius: 4px; transition: width .3s; }

  /* Modal */
  #modalOverlay { display: none; position: fixed; inset: 0; background: rgba(0,0,0,.7); backdrop-filter: blur(6px); z-index: 100; align-items: center; justify-content: center; }
  #modalOverlay.open { display: flex; }
  .modal { background: var(--surface); border: 1px solid var(--border); border-radius: 16px; padding: 24px; width: 100%; max-width: 440px; margin: 16px; }
  .modal h3 { font-size: 1rem; font-weight: 800; margin-bottom: 8px; }
  .modal p { font-size: .8rem; color: var(--muted); margin-bottom: 12px; }
  .modal textarea { width: 100%; height: 100px; background: var(--bg); border: 1px solid var(--border); color: var(--text); border-radius: 8px; padding: 10px; font-family: monospace; font-size: .75rem; outline: none; resize: none; }
  .modal-btns { display: flex; justify-content: flex-end; gap: 8px; margin-top: 12px; }

  /* Size selector */
  .size-row { display: flex; align-items: center; gap: 12px; margin-bottom: 16px; flex-wrap: wrap; }
  .size-row label { font-size: .7rem; font-weight: 800; text-transform: uppercase; letter-spacing: .08em; color: var(--muted); }
  .size-row select { background: var(--surface2); border: 1px solid var(--border); color: var(--text); padding: 6px 12px; border-radius: 8px; font-size: .85rem; font-weight: 700; outline: none; }

  .given-hint { font-size: .68rem; color: var(--muted); margin-top: 8px; }
  .given-hint span { color: var(--accent); font-weight: 700; }
</style>
</head>
<body>

<div id="modalOverlay">
  <div class="modal">
    <h3 id="modalTitle">Export</h3>
    <p id="modalDesc">Copy the string below.</p>
    <textarea id="modalTA"></textarea>
    <div class="modal-btns">
      <button class="btn" onclick="closeModal()">Close</button>
      <button class="btn btn-accent" id="modalAction">Copy</button>
    </div>
  </div>
</div>

<header>
  <div>
    <h1>MATHDOKU<span>.BUILD</span></h1>
    <p class="sub">Design Â· Solve Â· Rate</p>
  </div>
  <div class="header-btns">
    <button class="btn" onclick="openExport()">Export</button>
    <button class="btn" onclick="openImport()">Import</button>
    <button class="btn btn-danger" onclick="resetAll()">Reset</button>
  </div>
</header>

<div class="layout">
  <!-- LEFT -->
  <div style="display:flex;flex-direction:column;gap:16px;">
    <div class="card">
      <div class="size-row">
        <label>Grid Size</label>
        <select id="sizeSelect">
          <option value="4" selected>4Ã—4</option>
          <option value="5">5Ã—5</option>
          <option value="6">6Ã—6</option>
          <option value="7">7Ã—7</option>
          <option value="8">8Ã—8</option>
          <option value="9">9Ã—9</option>
        </select>
        <span id="selStatus" style="margin-left:auto;font-size:.75rem;font-weight:700;color:var(--muted);">0 selected</span>
      </div>
      <div id="gridWrap">
        <div id="gridEl"></div>
      </div>
      <div class="cage-form">
        <div class="form-group">
          <label>Target</label>
          <input id="fTarget" type="number" min="1" placeholder="e.g. 12">
        </div>
        <div class="form-group">
          <label>Operation</label>
          <select id="fOp">
            <option value="+">+ Add</option>
            <option value="-">âˆ’ Sub</option>
            <option value="*">Ã— Mul</option>
            <option value="/">Ã· Div</option>
          </select>
        </div>
        <button class="btn btn-accent" onclick="addCage()">Add Cage</button>
      </div>
      <p class="given-hint">ðŸ’¡ Select a single free cell and press <span>1â€“9</span> to set a given. <span>Backspace</span> to clear.</p>
    </div>

    <div class="card">
      <div class="card-title">Solution Map</div>
      <div id="solMap"><p style="color:var(--muted);font-size:.8rem;text-align:center;padding:32px 0;">Run solver to see candidates.</p></div>
    </div>
  </div>

  <!-- RIGHT -->
  <div style="display:flex;flex-direction:column;gap:16px;">
    <div class="card">
      <div class="card-title">Analysis</div>
      <div id="ratingBox" style="display:none;"></div>
      <button class="btn btn-accent" style="width:100%;padding:12px;" onclick="runSolver()">â–¶ Run Solver</button>
    </div>

    <div class="card">
      <div class="card-title">Cage Registry</div>
      <div class="cov-bar-wrap"><div class="cov-bar" id="covBar" style="width:0%"></div></div>
      <p id="covLabel" style="font-size:.72rem;color:var(--muted);margin-bottom:10px;">0 / 0 cells covered</p>
      <div id="cageList"></div>
    </div>
  </div>
</div>

<script>
// â”€â”€ State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let N = 4;
let cages = [];       // { id, cells:[[r,c],...], op, target }
let givens = [];      // { row, col, value }
let selected = new Set(); // flat indices r*N+c
let isDragging = false;

// â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const $ = id => document.getElementById(id);
const flat = (r, c) => r * N + c;
const unflat = f => ({ r: Math.floor(f / N), c: f % N });

function cellToCageIdx(r, c) {
  return cages.findIndex(cage => cage.cells.some(([cr, cc]) => cr === r && cc === c));
}

function cellIsGiven(r, c) {
  return givens.some(g => g.row === r && g.col === c);
}

function givenValue(r, c) {
  const g = givens.find(g => g.row === r && g.col === c);
  return g ? g.value : null;
}

function isFree(r, c) {
  return cellToCageIdx(r, c) === -1 && !cellIsGiven(r, c);
}

// â”€â”€ Render â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function render() {
  const el = $('gridEl');
  const maxW = Math.min(window.innerWidth - 48, 480);
  const cellPx = Math.floor((maxW - N * 1) / N);
  el.style.gridTemplateColumns = `repeat(${N}, ${cellPx}px)`;
  el.style.width = (cellPx * N + N - 1) + 'px';
  el.innerHTML = '';

  for (let r = 0; r < N; r++) {
    for (let c = 0; c < N; c++) {
      const f = flat(r, c);
      const ci = cellToCageIdx(r, c);
      const isGiven = cellIsGiven(r, c);
      const isSel = selected.has(f);

      const div = document.createElement('div');
      div.className = 'cell' +
        (isFree(r,c) && !isGiven ? ' free' : '') +
        (ci !== -1 ? ' caged' : '') +
        (isGiven ? ' given' : '') +
        (isSel ? ' selected' : '');
      div.dataset.f = f;

      // Cage borders
      if (ci !== -1) {
        const cage = cages[ci];
        const inCage = (rr, cc) => cage.cells.some(([a,b]) => a===rr && b===cc);
        if (r === 0 || !inCage(r-1, c)) div.classList.add('bt');
        if (r === N-1 || !inCage(r+1, c)) div.classList.add('bb');
        if (c === 0 || !inCage(r, c-1)) div.classList.add('bl');
        if (c === N-1 || !inCage(r, c+1)) div.classList.add('br');

        // Label on top-left cell
        const sorted = [...cage.cells].sort((a,b) => flat(a[0],a[1]) - flat(b[0],b[1]));
        if (sorted[0][0] === r && sorted[0][1] === c) {
          const lbl = document.createElement('span');
          lbl.className = 'cage-label';
          lbl.textContent = cage.target + cage.op;
          div.appendChild(lbl);
        }
      }

      // Given borders (full box)
      if (isGiven) {
        div.classList.add('bt','bb','bl','br');
        div.append(givenValue(r, c));
      }

      el.appendChild(div);
    }
  }

  updateSelStatus();
  updateCageList();
}

function updateSelStatus() {
  $('selStatus').textContent = selected.size + ' selected';
}

// â”€â”€ Grid interaction â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function cellFromPoint(x, y) {
  const el = document.elementFromPoint(x, y);
  if (!el) return null;
  const cell = el.closest('[data-f]');
  if (!cell) return null;
  const f = parseInt(cell.dataset.f);
  const { r, c } = unflat(f);
  return isFree(r, c) ? f : null;
}

function toggleSelect(f) {
  const { r, c } = unflat(f);
  if (!isFree(r, c)) return;
  if (selected.has(f)) selected.delete(f);
  else selected.add(f);
  render();
}

$('gridEl').addEventListener('mousedown', e => {
  const cell = e.target.closest('[data-f]');
  if (!cell) return;
  const f = parseInt(cell.dataset.f);
  const { r, c } = unflat(f);
  if (!isFree(r, c)) return;
  isDragging = true;
  if (!e.shiftKey) selected.clear();
  selected.add(f);
  render();
});

$('gridEl').addEventListener('mousemove', e => {
  if (!isDragging) return;
  const f = cellFromPoint(e.clientX, e.clientY);
  if (f !== null && !selected.has(f)) { selected.add(f); render(); }
});

document.addEventListener('mouseup', () => { isDragging = false; });

// Touch
$('gridEl').addEventListener('touchstart', e => {
  e.preventDefault();
  const t = e.touches[0];
  const f = cellFromPoint(t.clientX, t.clientY);
  if (f === null) return;
  isDragging = true;
  selected.clear();
  selected.add(f);
  render();
}, { passive: false });

$('gridEl').addEventListener('touchmove', e => {
  e.preventDefault();
  if (!isDragging) return;
  const t = e.touches[0];
  const f = cellFromPoint(t.clientX, t.clientY);
  if (f !== null && !selected.has(f)) { selected.add(f); render(); }
}, { passive: false });

document.addEventListener('touchend', () => { isDragging = false; });

// â”€â”€ Givens via keyboard â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
document.addEventListener('keydown', e => {
  // Don't intercept if typing in an input/select
  if (['INPUT','SELECT','TEXTAREA'].includes(document.activeElement.tagName)) return;
  if (selected.size !== 1) return;

  const f = [...selected][0];
  const { r, c } = unflat(f);
  const digit = parseInt(e.key);

  if (!isNaN(digit) && digit >= 1 && digit <= N) {
    // Remove existing given if any (shouldn't be since cell is free, but safety)
    givens = givens.filter(g => !(g.row === r && g.col === c));
    givens.push({ row: r, col: c, value: digit });
    selected.clear();
    render();
  } else if (e.key === 'Backspace' || e.key === 'Delete') {
    givens = givens.filter(g => !(g.row === r && g.col === c));
    render();
  }
});

// â”€â”€ Cage operations â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function addCage() {
  const target = parseInt($('fTarget').value);
  const op = $('fOp').value;
  if (isNaN(target) || selected.size === 0) return;

  const cells = [...selected].map(f => { const {r,c} = unflat(f); return [r,c]; });

  // Validate: -, / need exactly 2 cells
  if ((op === '-' || op === '/') && cells.length !== 2) {
    alert(`${op} cages must have exactly 2 cells.`); return;
  }

  cages.push({ id: Date.now(), cells, op, target });
  selected.clear();
  $('fTarget').value = '';
  render();
}

function removeCage(id) {
  cages = cages.filter(c => c.id !== id);
  render();
}

function removeGiven(r, c) {
  givens = givens.filter(g => !(g.row === r && g.col === c));
  render();
}

function updateCageList() {
  const list = $('cageList');
  list.innerHTML = '';
  const total = N * N;
  let covered = givens.length + cages.reduce((s, c) => s + c.cells.length, 0);

  // Cages
  cages.forEach(cage => {
    const div = document.createElement('div');
    div.className = 'cage-item';
    div.innerHTML = `
      <div>
        <div class="cage-name">${cage.target}${cage.op}</div>
        <div class="cage-meta">${cage.cells.length} cell${cage.cells.length>1?'s':''} Â· ${cage.cells.map(([r,c])=>`(${r},${c})`).join(' ')}</div>
      </div>
      <button class="cage-rm" title="Remove">âœ•</button>`;
    div.querySelector('.cage-rm').onclick = () => removeCage(cage.id);
    list.appendChild(div);
  });

  // Givens
  givens.forEach(g => {
    const div = document.createElement('div');
    div.className = 'cage-item';
    div.innerHTML = `
      <div>
        <div class="cage-name" style="color:#f97316;">Given: ${g.value}</div>
        <div class="cage-meta">row ${g.row}, col ${g.col}</div>
      </div>
      <button class="cage-rm" title="Remove">âœ•</button>`;
    div.querySelector('.cage-rm').onclick = () => removeGiven(g.row, g.col);
    list.appendChild(div);
  });

  const pct = Math.min(100, Math.round(covered / total * 100));
  $('covBar').style.width = pct + '%';
  $('covLabel').textContent = `${covered} / ${total} cells covered`;
}

// â”€â”€ Solver â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function buildPuzzle() {
  return { size: N, cages, givens };
}

async function runSolver() {
  const btn = document.querySelector('[onclick="runSolver()"]');
  btn.textContent = 'Solvingâ€¦'; btn.disabled = true;
  await new Promise(r => setTimeout(r, 30));

  const puzzle = buildPuzzle();

  // Solve up to 10k
  const result = MathdokuSolver.solve(puzzle, { maxSolutions: 10000 });
  const rating = MathdokuSolver.rate(puzzle);

  renderRating(rating, result);
  if (result && result.solutions.length > 0 && result.solutions.length < 10000) {
    renderSolMap(result.solutions);
  } else {
    $('solMap').innerHTML = '<p style="color:var(--muted);font-size:.8rem;text-align:center;padding:32px 0;">' +
      ((!result || result.solutions.length === 0) ? 'No solution found.' : '10,000+ solutions â€” candidate map hidden.') + '</p>';
  }

  btn.textContent = 'â–¶ Run Solver'; btn.disabled = false;
}

const RANK_COLORS = {
  'Impossible':        '#ef4444',
  'Non-unique':        '#f472b6',
  'Easy':              '#22c55e',
  'Medium':            '#3b82f6',
  'Hard':              '#eab308',
  'Vicious':           '#f97316',
  'Devilish':          '#ef4444',
  'Diabolical':        '#a855f7',
  'Beyond Diabolical': '#ec4899',
};

function rankColor(difficulty) {
  if (!difficulty) return '#71717a';
  for (const [key, val] of Object.entries(RANK_COLORS)) {
    if (difficulty.startsWith(key)) return val;
  }
  return '#71717a';
}

function renderRating(rating, result) {
  const box = $('ratingBox');
  box.style.display = 'block';
  const color = rankColor(rating.difficulty);
  box.style.borderColor = color;
  const sols = result ? result.solutions.length : 0;
  box.innerHTML = `
    <div class="r            align-items: center;
            justify-content: center;
            background: #1e293b;
            border: 1px solid #334155;
            color: #f1f5f9;
            padding: 2px;
            overflow: hidden;
        }
        .solution-val { font-weight: 900; font-size: 1.1rem; }
        .solution-multi { font-size: 0.6rem; color: #94a3b8; font-weight: bold; line-height: 1; text-align: center; }
        
        #cageList::-webkit-scrollbar { width: 4px; }
        #cageList::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 10px; }

        #modalOverlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(15, 23, 42, 0.6);
            backdrop-filter: blur(4px);
            z-index: 50;
            align-items: center;
            justify-content: center;
        }
    </style>
</head>
<body class="bg-slate-50 min-h-screen p-4 md:p-8 font-sans text-slate-900">

    <div id="modalOverlay">
        <div class="bg-white rounded-2xl shadow-2xl p-6 w-full max-w-lg mx-4 border border-slate-200">
            <h3 id="modalTitle" class="text-lg font-bold mb-2 text-slate-900">Share Puzzle</h3>
            <p id="modalDesc" class="text-sm text-slate-500 mb-4">Copy the string below to save your puzzle.</p>
            <textarea id="modalTextarea" class="w-full h-32 p-3 bg-slate-50 border border-slate-200 rounded-xl text-xs font-mono mb-4 focus:ring-2 focus:ring-blue-500 outline-none"></textarea>
            <div class="flex justify-end gap-3">
                <button onclick="closeModal()" class="px-4 py-2 text-sm font-semibold text-slate-500 hover:text-slate-700 transition">Close</button>
                <button id="modalActionBtn" class="bg-blue-600 text-white px-5 py-2 rounded-lg text-sm font-bold hover:bg-blue-700 shadow-md transition-all active:scale-95">Copy String</button>
            </div>
        </div>
    </div>

    <div class="max-w-6xl mx-auto">
        <header class="mb-8 flex flex-col md:flex-row justify-between items-start md:items-center gap-4">
            <div>
                <h1 class="text-3xl font-extrabold tracking-tight italic">MATHDOKU<span class="text-blue-600">.BUILDER</span></h1>
                <p class="text-slate-500 font-medium text-sm">Design, Solve, and Rate Puzzles</p>
            </div>
            <div class="flex flex-wrap gap-2">
                <button onclick="openExportModal()" class="bg-white border border-slate-200 px-4 py-2 rounded-lg text-sm font-semibold hover:bg-slate-50 shadow-sm transition-all">Export</button>
                <button onclick="openImportModal()" class="bg-white border border-slate-200 px-4 py-2 rounded-lg text-sm font-semibold hover:bg-slate-50 shadow-sm transition-all">Import</button>
                <button onclick="resetConstructor()" class="bg-white border border-red-100 px-4 py-2 rounded-lg text-sm font-semibold text-red-500 hover:bg-red-50 transition-all">Reset All</button>
            </div>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-12 gap-8">
            <div class="lg:col-span-7 space-y-6">
                <div class="bg-white p-6 rounded-2xl shadow-sm border border-slate-200">
                    <div class="flex justify-between items-center mb-6">
                        <div class="flex items-center gap-4">
                            <label class="font-bold text-xs uppercase tracking-wider text-slate-400">Dimension</label>
                            <select id="gridSize" class="bg-slate-100 border-none rounded-lg px-4 py-2 text-sm font-bold focus:ring-2 focus:ring-blue-500 outline-none">
                                <option value="3">3x3</option>
                                <option value="4" selected>4x4</option>
                                <option value="5">5x5</option>
                                <option value="6">6x6</option>
                                <option value="9">9x9</option>
                            </select>
                        </div>
                        <div id="selectionStatus" class="text-[10px] font-bold text-slate-400 uppercase">
                            0 Cells Selected
                        </div>
                    </div>

                    <div id="gridContainer" class="grid gap-0 mx-auto border-2 border-slate-900 overflow-hidden bg-slate-200 shadow-xl" style="max-width: 420px;"></div>

                    <div class="mt-8 p-5 bg-blue-50 rounded-2xl border border-blue-100 flex flex-wrap gap-4 items-end">
                        <div class="flex-1 min-w-[120px]">
                            <label class="block text-[10px] font-bold text-blue-400 uppercase mb-1">Target / Given</label>
                            <input id="cageTarget" type="number" class="w-full px-3 py-2 rounded-lg border-blue-200 text-sm outline-none focus:ring-2 focus:ring-blue-500" placeholder="e.g. 12">
                        </div>
                        <div class="flex-1 min-w-[100px]">
                            <label class="block text-[10px] font-bold text-blue-400 uppercase mb-1">Op / Type</label>
                            <select id="cageOp" class="w-full px-3 py-2 rounded-lg border-blue-200 text-sm outline-none focus:ring-2 focus:ring-blue-500">
                                <option value="+">+</option>
                                <option value="-">-</option>
                                <option value="*">Ã—</option>
                                <option value="/">Ã·</option>
                                <option value="=">=</option>
                                <option value="GIVEN">GIVEN</option>
                            </select>
                        </div>
                        <button onclick="createCage()" class="bg-blue-600 text-white px-8 py-2 rounded-lg text-sm font-bold hover:bg-blue-700 shadow-md transition-all active:scale-95">ADD ELEMENT</button>
                    </div>
                </div>

                <div class="bg-slate-900 p-6 rounded-2xl shadow-xl text-white">
                    <h3 class="text-xs font-bold uppercase tracking-widest text-slate-500 mb-4">Solution Map (Candidate Analysis)</h3>
                    <div id="solutionContainer" class="grid gap-1 mx-auto" style="max-width: 320px;">
                        <div class="col-span-full py-12 text-center text-slate-600 text-sm italic font-medium">Solve to reveal all possible candidates...</div>
                    </div>
                </div>
            </div>

            <div class="lg:col-span-5 space-y-6">
                <div class="bg-white p-6 rounded-2xl shadow-sm border border-slate-200">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="font-bold text-lg">Analysis</h2>
                        <span id="statusBadge" class="text-[10px] uppercase tracking-widest px-2 py-0.5 rounded bg-slate-100 text-slate-400 font-bold">Idle</span>
                    </div>
                    
                    <div id="resultsArea">
                        <div class="p-8 rounded-2xl bg-slate-50 border border-dashed border-slate-200 text-slate-400 text-xs text-center font-medium">
                            Ready for analysis (all-cell coverage not required).
                        </div>
                    </div>

                    <button onclick="runSolver()" id="btnAnalyze" class="w-full mt-6 bg-slate-900 text-white py-4 rounded-xl font-bold hover:bg-slate-800 shadow-lg transition-all active:scale-95">
                        RUN SOLVER (Limit 10k)
                    </button>
                </div>

                <div class="bg-white p-6 rounded-2xl shadow-sm border border-slate-200">
                    <div class="flex justify-between items-center mb-3">
                        <h3 class="font-bold text-xs text-slate-400 uppercase tracking-widest">Puzzle Registry</h3>
                        <span id="coverageLabel" class="text-xs font-bold text-slate-500">0 / 16</span>
                    </div>
                    <div id="cageList" class="space-y-2 max-h-96 overflow-y-auto pr-2"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class MathdokuSolver {
            constructor(size, cages) {
                this.size = size;
                this.cages = cages;
                this.grid = Array(size * size).fill(0);
                this.backtracks = 0;
                this.solutions = []; 
                this.cellToCageMap = {};
                
                this.cages.forEach((cage, index) => {
                    cage.cells.forEach(cellIdx => {
                        this.cellToCageMap[cellIdx] = index;
                    });
                });
            }

            isValid(idx, val) {
                const r = Math.floor(idx / this.size);
                const c = idx % this.size;
                for (let i = 0; i < this.size; i++) {
                    if (this.grid[r * this.size + i] === val) return false;
                    if (this.grid[i * this.size + c] === val) return false;
                }
                const cageIdx = this.cellToCageMap[idx];
                if (cageIdx === undefined) return true; // Partial grid: empty cells are just Latin Square constrained
                
                const cage = this.cages[cageIdx];
                const cageValues = cage.cells.map(i => i === idx ? val : this.grid[i]).filter(v => v !== 0);
                if (cageValues.length === cage.cells.length) return this.checkCageLogic(cage, cageValues);
                return this.checkPartialCageLogic(cage, cageValues);
            }

            checkCageLogic(cage, values) {
                switch(cage.op) {
                    case '+': return values.reduce((a, b) => a + b, 0) === cage.target;
                    case '*': return values.reduce((a, b) => a * b, 1) === cage.target;
                    case '-': {
                        const max = Math.max(...values);
                        return (max - (values.reduce((a, b) => a + b, 0) - max)) === cage.target;
                    }
                    case '/': {
                        const max = Math.max(...values);
                        return (max / (values.reduce((a, b) => a * b, 1) / max)) === cage.target;
                    }
                    case '=':
                    case 'GIVEN': return values[0] === cage.target;
                    default: return false;
                }
            }

            checkPartialCageLogic(cage, values) {
                const remaining = cage.cells.length - values.length;
                const currentSum = values.reduce((a, b) => a + b, 0);
                const currentProd = values.reduce((a, b) => a * b, 1);
                switch(cage.op) {
                    case '+':
                        if (currentSum + remaining > cage.target) return false;
                        if (currentSum + (remaining * this.size) < cage.target) return false;
                        break;
                    case '*':
                        if (currentProd > cage.target && cage.target !== 0) return false;
                        break;
                }
                return true;
            }

            findAllSolutions(limit = 10000) {
                this.solutions = [];
                this.backtracks = 0;
                this.solveRecursive(0, limit);
                return this.solutions;
            }

            solveRecursive(idx, limit) {
                if (this.solutions.length >= limit) return;
                if (idx === this.size * this.size) {
                    this.solutions.push([...this.grid]);
                    return;
                }

                // If cell is a GIVEN, skip the value loop
                const cageIdx = this.cellToCageMap[idx];
                if (cageIdx !== undefined && this.cages[cageIdx].op === 'GIVEN') {
                    const val = this.cages[cageIdx].target;
                    if (this.isValid(idx, val)) {
                        this.grid[idx] = val;
                        this.solveRecursive(idx + 1, limit);
                        this.grid[idx] = 0;
                    }
                    return;
                }

                for (let val = 1; val <= this.size; val++) {
                    if (this.isValid(idx, val)) {
                        this.grid[idx] = val;
                        this.solveRecursive(idx + 1, limit);
                        this.grid[idx] = 0;
                        if (this.solutions.length >= limit) return;
                    } else {
                        this.backtracks++;
                    }
                }
            }

            rateDifficulty() {
                if (this.solutions.length === 0) return { rank: "Impossible", score: Infinity };
                
                let totalCageComplexity = 0;
                this.cages.forEach(c => {
                    if (c.op === 'GIVEN') return;
                    const combos = this.countPotentialCombinations(c);
                    let complexity = Math.log2(combos + 1);
                    if (c.op === '/' || c.op === '*') complexity *= 1.5;
                    if (c.op === '-') complexity *= 1.2;
                    totalCageComplexity += complexity;
                });

                const avgCageComplexity = totalCageComplexity / Math.max(1, this.cages.length);
                const searchScore = Math.sqrt(this.backtracks) * 2;
                const totalScore = Math.round((avgCageComplexity * 20) + searchScore);

                if (this.solutions.length > 1) {
                    return { 
                        rank: "Non-unique", 
                        score: totalScore, 
                        metrics: { 
                            backtracks: this.backtracks, 
                            avgComplexity: avgCageComplexity.toFixed(2), 
                            solutionCount: this.solutions.length 
                        } 
                    };
                }

                let rank = "";
                if (totalScore < 15) rank = "Easy";
                else if (totalScore < 30) rank = "Medium";
                else if (totalScore < 50) rank = "Hard";
                else if (totalScore < 75) rank = "Vicious";
                else if (totalScore < 110) rank = "Devilish";
                else if (totalScore < 160) rank = "Diabolical";
                else rank = "Beyond Diabolical";

                return { 
                    score: totalScore, 
                    rank, 
                    metrics: { 
                        backtracks: this.backtracks, 
                        avgComplexity: avgCageComplexity.toFixed(2), 
                        solutionCount: this.solutions.length 
                    } 
                };
            }

            countPotentialCombinations(cage) {
                if (cage.op === 'GIVEN') return 1;
                let count = 0;
                const k = cage.cells.length;
                const backtrack = (index, currentValues) => {
                    if (index === k) {
                        if (this.checkCageLogic(cage, currentValues)) count++;
                        return;
                    }
                    for (let v = 1; v <= this.size; v++) {
                        currentValues.push(v);
                        backtrack(index + 1, currentValues);
                        currentValues.pop();
                    }
                };
                backtrack(0, []);
                return count;
            }
        }

        // --- UI Logic ---
        let size = 4;
        let cages = [];
        let selectedCells = new Set();
        let cellToCageMap = {};

        const gridContainer = document.getElementById('gridContainer');
        const gridSizeSelect = document.getElementById('gridSize');
        const cageListEl = document.getElementById('cageList');
        const selectionStatus = document.getElementById('selectionStatus');
        const cageTargetInput = document.getElementById('cageTarget');
        const cageOpInput = document.getElementById('cageOp');

        function init() {
            size = parseInt(gridSizeSelect.value);
            renderGrid();
            gridSizeSelect.onchange = (e) => { size = parseInt(e.target.value); resetConstructor(); };
        }

        function renderGrid() {
            gridContainer.innerHTML = '';
            gridContainer.style.gridTemplateColumns = `repeat(${size}, 1fr)`;
            for (let i = 0; i < size * size; i++) {
                const cell = document.createElement('div');
                const givenCage = cages.find(c => c.op === 'GIVEN' && c.cells.includes(i));
                cell.className = `grid-cell ${selectedCells.has(i) ? 'selected' : ''} ${givenCage ? 'given' : ''}`;
                cell.dataset.idx = i;
                const label = document.createElement('span');
                label.className = 'cage-label';
                cell.appendChild(label);
                
                if (givenCage) cell.append(givenCage.target);

                cell.onclick = (e) => {
                    if (!e.shiftKey && !e.ctrlKey) {
                        if (cellToCageMap[i] === undefined && !selectedCells.has(i)) selectedCells.clear();
                    }
                    if (cellToCageMap[i] === undefined) {
                        if (selectedCells.has(i)) selectedCells.delete(i);
                        else selectedCells.add(i);
                        renderGrid(); updateSelectionCount();
                    }
                };
                gridContainer.appendChild(cell);
            }
            drawCageBorders();
        }

        function drawCageBorders() {
            const cells = gridContainer.children;
            cages.forEach((cage, cIdx) => {
                const sortedCells = [...cage.cells].sort((a, b) => a - b);
                const labelCell = cells[sortedCells[0]];
                if (cage.op !== 'GIVEN') {
                    labelCell.querySelector('.cage-label').innerText = `${cage.target}${cage.op === '=' ? '' : cage.op}`;
                }
                cage.cells.forEach(idx => {
                    const r = Math.floor(idx / size), c = idx % size;
                    const cell = cells[idx];
                    if (r === 0 || cellToCageMap[idx - size] !== cIdx) cell.classList.add('border-t-heavy');
                    if (r === size - 1 || cellToCageMap[idx + size] !== cIdx) cell.classList.add('border-b-heavy');
                    if (c === 0 || cellToCageMap[idx - 1] !== cIdx) cell.classList.add('border-l-heavy');
                    if (c === size - 1 || cellToCageMap[idx + 1] !== cIdx) cell.classList.add('border-r-heavy');
                });
            });
        }

        function updateSelectionCount() {
            selectionStatus.textContent = `${selectedCells.size} Cells Selected`;
        }

        window.createCage = () => {
            const target = parseInt(cageTargetInput.value);
            const op = cageOpInput.value;
            if (isNaN(target) || selectedCells.size === 0) return;
            if (op === 'GIVEN' && selectedCells.size > 1) {
                alert("Givens must be single cells."); return;
            }
            const newCage = { target, op, cells: Array.from(selectedCells), id: Date.now() };
            const cageIdx = cages.length;
            cages.push(newCage);
            newCage.cells.forEach(idx => cellToCageMap[idx] = cageIdx);
            selectedCells.clear(); updateSelectionCount();
            cageTargetInput.value = ''; renderGrid(); updateCageList();
        };

        function updateCageList() {
            cageListEl.innerHTML = '';
            let covered = 0;
            cages.forEach((c, i) => {
                covered += c.cells.length;
                const div = document.createElement('div');
                div.className = 'flex justify-between items-center bg-slate-50 p-3 rounded-xl text-xs border border-slate-200';
                div.innerHTML = `
                    <span class="font-bold text-slate-700">
                        <strong class="text-blue-600">${c.op === 'GIVEN' ? 'GIVEN: ' + c.target : c.target + (c.op === '=' ? '' : c.op)}</strong> 
                        <span class="text-slate-400 ml-1">(${c.cells.length} cell${c.cells.length > 1 ? 's' : ''})</span>
                    </span>
                    <button class="text-slate-300 hover:text-red-500 transition-colors" onclick="removeCage(${i})">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M6 18L18 6M6 6l12 12"></path></svg>
                    </button>`;
                cageListEl.appendChild(div);
            });
            document.getElementById('coverageLabel').textContent = `${covered} / ${size * size}`;
        }

        window.removeCage = (index) => {
            cages.splice(index, 1);
            cellToCageMap = {}; cages.forEach((c, i) => c.cells.forEach(idx => cellToCageMap[idx] = i));
            renderGrid(); updateCageList();
        };

        window.runSolver = async () => {
            const badge = document.getElementById('statusBadge');
            badge.innerText = "SEARCHING...";
            badge.className = "text-[10px] uppercase tracking-widest px-2 py-0.5 rounded bg-blue-100 text-blue-600 font-bold";
            await new Promise(r => setTimeout(r, 100));
            
            const solver = new MathdokuSolver(size, cages);
            const solutions = solver.findAllSolutions(10000);
            const rating = solver.rateDifficulty();
            
            renderResults(rating);
            if (solutions.length > 0) renderSolutionsMap(solutions);
            else document.getElementById('solutionContainer').innerHTML = '<div class="col-span-full py-12 text-center text-red-400 text-sm font-medium">Contradiction: No solution possible.</div>';
        };

        function renderResults(rating) {
            const badge = document.getElementById('statusBadge');
            if (rating.rank === "Impossible") {
                badge.innerText = "IMPOSSIBLE";
                badge.className = "text-[10px] uppercase tracking-widest px-2 py-0.5 rounded bg-red-100 text-red-600 font-bold";
                document.getElementById('resultsArea').innerHTML = `<div class="p-6 rounded-2xl bg-red-50 border border-red-200 text-center"><p class="text-[10px] uppercase font-bold text-red-500 mb-1">Error</p><p class="text-xl font-black text-red-900">UNSOLVABLE</p></div>`;
                return;
            }
            badge.innerText = "DONE";
            badge.className = "text-[10px] uppercase tracking-widest px-2 py-0.5 rounded bg-green-100 text-green-600 font-bold";
            const rankColors = { "Non-unique": "text-pink-600 bg-pink-50", "Easy": "text-green-600 bg-green-50", "Medium": "text-blue-600 bg-blue-50", "Hard": "text-yellow-600 bg-yellow-50", "Vicious": "text-orange-600 bg-orange-50", "Devilish": "text-red-600 bg-red-50", "Diabolical": "text-purple-600 bg-purple-50", "Beyond Diabolical": "text-white bg-slate-900" };
            const colorClass = rankColors[rating.rank] || "bg-slate-50";
            document.getElementById('resultsArea').innerHTML = `
                <div class="p-6 rounded-2xl ${colorClass.split(' ')[1]} border-2 border-slate-900 shadow-sm text-center">
                    <p class="text-[10px] uppercase font-black text-slate-400 mb-1 tracking-tighter">Complexity Rating</p>
                    <p class="text-2xl font-black ${colorClass.split(' ')[0]}">${rating.rank.toUpperCase()}</p>
                    <div class="flex flex-wrap justify-center gap-x-4 gap-y-1 mt-3 text-[10px] text-slate-500 font-bold uppercase tracking-widest">
                        <span>Score: ${rating.score}</span>
                        <span>|</span>
                        <span>Found: ${rating.metrics.solutionCount}${rating.metrics.solutionCount >= 10000 ? '+' : ''} sol.</span>
                    </div>
                </div>`;
        }

        function renderSolutionsMap(solutions) {
            const container = document.getElementById('solutionContainer');
            container.style.gridTemplateColumns = `repeat(${size}, 1fr)`;
            container.innerHTML = '';
            
            for (let i = 0; i < size * size; i++) {
                const possibleValues = new Set();
                solutions.forEach(sol => possibleValues.add(sol[i]));
                const values = Array.from(possibleValues).sort((a, b) => a - b);
                
                const cell = document.createElement('div');
                cell.className = 'solution-cell';
                
                if (values.length === 1) {
                    cell.innerHTML = `<span class="solution-val">${values[0]}</span>`;
                } else {
                    const label = values.length > 3 ? `${values.slice(0, 2).join(',')},..` : values.join(', ');
                    cell.innerHTML = `
                        <span class="solution-val text-pink-400">?</span>
                        <span class="solution-multi">${label}</span>
                    `;
                    cell.title = "Possible: " + values.join(', ');
                }
                container.appendChild(cell);
            }
        }

        window.resetConstructor = () => {
            cages = []; cellToCageMap = {}; selectedCells.clear();
            renderGrid(); updateCageList(); updateSelectionCount();
            document.getElementById('resultsArea').innerHTML = `<div class="p-8 rounded-2xl bg-slate-50 border border-dashed border-slate-200 text-slate-400 text-xs text-center font-medium">Ready for analysis.</div>`;
            document.getElementById('solutionContainer').innerHTML = '<div class="col-span-full py-12 text-center text-slate-600 text-sm italic font-medium">Solve to reveal candidates...</div>';
            const badge = document.getElementById('statusBadge');
            badge.innerText = "IDLE"; badge.className = "text-[10px] uppercase tracking-widest px-2 py-0.5 rounded bg-slate-100 text-slate-400 font-bold";
        };

        window.openExportModal = () => {
            const base64 = btoa(JSON.stringify({ size, cages }));
            const area = document.getElementById('modalTextarea');
            document.getElementById('modalTitle').textContent = "Export Puzzle";
            area.value = base64; area.readOnly = true;
            document.getElementById('modalActionBtn').onclick = () => { area.select(); document.execCommand('copy'); };
            document.getElementById('modalOverlay').style.display = 'flex';
        };

        window.openImportModal = () => {
            const area = document.getElementById('modalTextarea');
            document.getElementById('modalTitle').textContent = "Import Puzzle";
            area.value = ""; area.readOnly = false;
            document.getElementById('modalActionBtn').onclick = () => {
                try {
                    const data = JSON.parse(atob(area.value));
                    size = data.size; cages = data.cages;
                    gridSizeSelect.value = size;
                    cellToCageMap = {}; cages.forEach((c, i) => c.cells.forEach(idx => cellToCageMap[idx] = i));
                    renderGrid(); updateCageList(); closeModal();
                } catch (e) { alert("Invalid puzzle string."); }
            };
            document.getElementById('modalOverlay').style.display = 'flex';
        };

        window.closeModal = () => document.getElementById('modalOverlay').style.display = 'none';

        init();
    </script>
</body>
</html>
