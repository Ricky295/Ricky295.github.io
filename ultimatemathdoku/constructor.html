<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mathdoku Constructor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .grid-cell {
            aspect-ratio: 1 / 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            font-weight: bold;
            position: relative;
            cursor: pointer;
            border: 1px solid #e5e7eb;
            background: white;
            transition: all 0.2s;
            user-select: none;
        }
        .grid-cell:hover { background-color: #f3f4f6; }
        .grid-cell.selected { background-color: #dbeafe; outline: 2px solid #3b82f6; z-index: 10; }
        .cage-label { position: absolute; top: 2px; left: 4px; font-size: 0.7rem; font-weight: 800; color: #374151; pointer-events: none; }
        
        .border-t-heavy { border-top: 3.5px solid #0f172a; }
        .border-b-heavy { border-bottom: 3.5px solid #0f172a; }
        .border-l-heavy { border-left: 3.5px solid #0f172a; }
        .border-r-heavy { border-right: 3.5px solid #0f172a; }

        .solution-cell {
            aspect-ratio: 1 / 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #1e293b;
            border: 1px solid #334155;
            font-weight: 900;
            font-size: 1.25rem;
            color: #f1f5f9;
        }
        
        #cageList::-webkit-scrollbar { width: 4px; }
        #cageList::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 10px; }

        #modalOverlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(15, 23, 42, 0.6);
            backdrop-filter: blur(4px);
            z-index: 50;
            align-items: center;
            justify-content: center;
        }
    </style>
</head>
<body class="bg-slate-50 min-h-screen p-4 md:p-8 font-sans text-slate-900">

    <div id="modalOverlay">
        <div class="bg-white rounded-2xl shadow-2xl p-6 w-full max-w-lg mx-4 border border-slate-200">
            <h3 id="modalTitle" class="text-lg font-bold mb-2 text-slate-900">Share Puzzle</h3>
            <p id="modalDesc" class="text-sm text-slate-500 mb-4">Copy the string below to save your puzzle.</p>
            <textarea id="modalTextarea" class="w-full h-32 p-3 bg-slate-50 border border-slate-200 rounded-xl text-xs font-mono mb-4 focus:ring-2 focus:ring-blue-500 outline-none"></textarea>
            <div class="flex justify-end gap-3">
                <button onclick="closeModal()" class="px-4 py-2 text-sm font-semibold text-slate-500 hover:text-slate-700 transition">Close</button>
                <button id="modalActionBtn" class="bg-blue-600 text-white px-5 py-2 rounded-lg text-sm font-bold hover:bg-blue-700 shadow-md transition-all active:scale-95">Copy String</button>
            </div>
        </div>
    </div>

    <div class="max-w-6xl mx-auto">
        <header class="mb-8 flex flex-col md:flex-row justify-between items-start md:items-center gap-4">
            <div>
                <h1 class="text-3xl font-extrabold tracking-tight italic">MATHDOKU<span class="text-blue-600">.BUILDER</span></h1>
                <p class="text-slate-500 font-medium text-sm">Design, Solve, and Rate Puzzles</p>
            </div>
            <div class="flex flex-wrap gap-2">
                <button onclick="openExportModal()" class="bg-white border border-slate-200 px-4 py-2 rounded-lg text-sm font-semibold hover:bg-slate-50 shadow-sm transition-all">Export</button>
                <button onclick="openImportModal()" class="bg-white border border-slate-200 px-4 py-2 rounded-lg text-sm font-semibold hover:bg-slate-50 shadow-sm transition-all">Import</button>
                <button onclick="resetConstructor()" class="bg-white border border-red-100 px-4 py-2 rounded-lg text-sm font-semibold text-red-500 hover:bg-red-50 transition-all">Reset All</button>
            </div>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-12 gap-8">
            <div class="lg:col-span-7 space-y-6">
                <div class="bg-white p-6 rounded-2xl shadow-sm border border-slate-200">
                    <div class="flex justify-between items-center mb-6">
                        <div class="flex items-center gap-4">
                            <label class="font-bold text-xs uppercase tracking-wider text-slate-400">Dimension</label>
                            <select id="gridSize" class="bg-slate-100 border-none rounded-lg px-4 py-2 text-sm font-bold focus:ring-2 focus:ring-blue-500 outline-none">
                                <option value="3">3x3</option>
                                <option value="4" selected>4x4</option>
                                <option value="5">5x5</option>
                                <option value="6">6x6</option>
                                <option value="9">9x9</option>
                            </select>
                        </div>
                        <div id="selectionStatus" class="text-[10px] font-bold text-slate-400 uppercase">
                            0 Cells Selected
                        </div>
                    </div>

                    <div id="gridContainer" class="grid gap-0 mx-auto border-2 border-slate-900 overflow-hidden bg-slate-200 shadow-xl" style="max-width: 420px;"></div>

                    <div class="mt-8 p-5 bg-blue-50 rounded-2xl border border-blue-100 flex flex-wrap gap-4 items-end">
                        <div class="flex-1 min-w-[120px]">
                            <label class="block text-[10px] font-bold text-blue-400 uppercase mb-1">Cage Target</label>
                            <input id="cageTarget" type="number" class="w-full px-3 py-2 rounded-lg border-blue-200 text-sm outline-none focus:ring-2 focus:ring-blue-500">
                        </div>
                        <div class="flex-1 min-w-[100px]">
                            <label class="block text-[10px] font-bold text-blue-400 uppercase mb-1">Operator</label>
                            <select id="cageOp" class="w-full px-3 py-2 rounded-lg border-blue-200 text-sm outline-none focus:ring-2 focus:ring-blue-500">
                                <option value="+">+</option>
                                <option value="-">-</option>
                                <option value="*">ร</option>
                                <option value="/">รท</option>
                                <option value="=">=</option>
                            </select>
                        </div>
                        <button onclick="createCage()" class="bg-blue-600 text-white px-8 py-2 rounded-lg text-sm font-bold hover:bg-blue-700 shadow-md transition-all active:scale-95">CREATE CAGE</button>
                    </div>
                </div>

                <div class="bg-slate-900 p-6 rounded-2xl shadow-xl text-white">
                    <h3 class="text-xs font-bold uppercase tracking-widest text-slate-500 mb-4">Solution Map</h3>
                    <div id="solutionContainer" class="grid gap-1 mx-auto" style="max-width: 320px;">
                        <div class="col-span-full py-12 text-center text-slate-600 text-sm italic font-medium">Solve to reveal solution...</div>
                    </div>
                </div>
            </div>

            <div class="lg:col-span-5 space-y-6">
                <div class="bg-white p-6 rounded-2xl shadow-sm border border-slate-200">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="font-bold text-lg">Analysis</h2>
                        <span id="statusBadge" class="text-[10px] uppercase tracking-widest px-2 py-0.5 rounded bg-slate-100 text-slate-400 font-bold">Idle</span>
                    </div>
                    
                    <div id="resultsArea">
                        <div class="p-8 rounded-2xl bg-slate-50 border border-dashed border-slate-200 text-slate-400 text-xs text-center font-medium">
                            Awaiting grid completion...
                        </div>
                    </div>

                    <button onclick="runSolver()" id="btnAnalyze" class="w-full mt-6 bg-slate-900 text-white py-4 rounded-xl font-bold hover:bg-slate-800 shadow-lg transition-all active:scale-95">
                        RUN SOLVER
                    </button>
                </div>

                <div class="bg-white p-6 rounded-2xl shadow-sm border border-slate-200">
                    <div class="flex justify-between items-center mb-3">
                        <h3 class="font-bold text-xs text-slate-400 uppercase tracking-widest">Cage Registry</h3>
                        <span id="coverageLabel" class="text-xs font-bold text-slate-500">0 / 16</span>
                    </div>
                    <div id="cageList" class="space-y-2 max-h-96 overflow-y-auto pr-2"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        /**
         * Mathdoku Solver Class - Integrated directly to avoid module issues
         */
        class MathdokuSolver {
            constructor(size, cages) {
                this.size = size;
                this.cages = cages;
                this.grid = Array(size * size).fill(0);
                this.backtracks = 0;
                this.firstSolution = null;
                this.cellToCageMap = {};
                this.cages.forEach((cage, index) => {
                    cage.cells.forEach(cellIdx => {
                        this.cellToCageMap[cellIdx] = index;
                    });
                });
            }

            isValid(idx, val) {
                const r = Math.floor(idx / this.size);
                const c = idx % this.size;
                for (let i = 0; i < this.size; i++) {
                    if (this.grid[r * this.size + i] === val) return false;
                    if (this.grid[i * this.size + c] === val) return false;
                }
                const cageIdx = this.cellToCageMap[idx];
                if (cageIdx === undefined) return true;
                const cage = this.cages[cageIdx];
                const cageValues = cage.cells.map(i => i === idx ? val : this.grid[i]).filter(v => v !== 0);
                if (cageValues.length === cage.cells.length) return this.checkCageLogic(cage, cageValues);
                return this.checkPartialCageLogic(cage, cageValues);
            }

            checkCageLogic(cage, values) {
                switch(cage.op) {
                    case '+': return values.reduce((a, b) => a + b, 0) === cage.target;
                    case '*': return values.reduce((a, b) => a * b, 1) === cage.target;
                    case '-': {
                        const max = Math.max(...values);
                        return (max - (values.reduce((a, b) => a + b, 0) - max)) === cage.target;
                    }
                    case '/': {
                        const max = Math.max(...values);
                        return (max / (values.reduce((a, b) => a * b, 1) / max)) === cage.target;
                    }
                    case '=': return values[0] === cage.target;
                    default: return false;
                }
            }

            checkPartialCageLogic(cage, values) {
                const remaining = cage.cells.length - values.length;
                const currentSum = values.reduce((a, b) => a + b, 0);
                const currentProd = values.reduce((a, b) => a * b, 1);
                switch(cage.op) {
                    case '+':
                        if (currentSum + remaining > cage.target) return false;
                        if (currentSum + (remaining * this.size) < cage.target) return false;
                        break;
                    case '*':
                        if (currentProd > cage.target && cage.target !== 0) return false;
                        break;
                }
                return true;
            }

            countPotentialCombinations(cage) {
                let count = 0;
                const n = this.size;
                const k = cage.cells.length;
                const backtrack = (index, currentValues) => {
                    if (index === k) {
                        if (this.checkCageLogic(cage, currentValues)) count++;
                        return;
                    }
                    for (let v = 1; v <= n; v++) {
                        currentValues.push(v);
                        backtrack(index + 1, currentValues);
                        currentValues.pop();
                    }
                };
                backtrack(0, []);
                return count;
            }

            solve(index = 0) {
                if (index === this.size * this.size) {
                    this.firstSolution = [...this.grid];
                    return true;
                }
                for (let v = 1; v <= this.size; v++) {
                    if (this.isValid(index, v)) {
                        this.grid[index] = v;
                        if (this.solve(index + 1)) return true;
                        this.grid[index] = 0;
                        this.backtracks++;
                    }
                }
                return false;
            }

            rateDifficulty() {
                if (!this.firstSolution) return { rank: "Unsolvable", score: Infinity };
                let totalCageComplexity = 0;
                this.cages.forEach(c => {
                    const combos = this.countPotentialCombinations(c);
                    let complexity = Math.log2(combos + 1);
                    if (c.op === '/' || c.op === '*') complexity *= 1.5;
                    if (c.op === '-') complexity *= 1.2;
                    totalCageComplexity += complexity;
                });
                const avgCageComplexity = totalCageComplexity / this.cages.length;
                const searchScore = Math.sqrt(this.backtracks) * 2;
                const totalScore = Math.round((avgCageComplexity * 20) + searchScore);
                let rank = "";
                if (totalScore < 15) rank = "Easy";
                else if (totalScore < 30) rank = "Medium";
                else if (totalScore < 50) rank = "Hard";
                else if (totalScore < 75) rank = "Vicious";
                else if (totalScore < 110) rank = "Devilish";
                else if (totalScore < 160) rank = "Diabolical";
                else rank = "Beyond Diabolical";
                return { score: totalScore, rank, metrics: { backtracks: this.backtracks, avgCageComplexity: avgCageComplexity.toFixed(2), totalCages: this.cages.length } };
            }
        }

        // --- Application UI Logic ---

        let size = 4;
        let cages = [];
        let selectedCells = new Set();
        let cellToCageMap = {};

        const gridContainer = document.getElementById('gridContainer');
        const gridSizeSelect = document.getElementById('gridSize');
        const cageListEl = document.getElementById('cageList');
        const selectionStatus = document.getElementById('selectionStatus');
        const cageTargetInput = document.getElementById('cageTarget');
        const cageOpInput = document.getElementById('cageOp');

        function init() {
            size = parseInt(gridSizeSelect.value);
            cages = [];
            selectedCells.clear();
            cellToCageMap = {};
            renderGrid();
            updateCageList();
            gridSizeSelect.onchange = (e) => {
                size = parseInt(e.target.value);
                resetConstructor();
            };
        }

        function renderGrid() {
            gridContainer.innerHTML = '';
            gridContainer.style.gridTemplateColumns = `repeat(${size}, 1fr)`;
            
            for (let i = 0; i < size * size; i++) {
                const cell = document.createElement('div');
                cell.className = `grid-cell ${selectedCells.has(i) ? 'selected' : ''}`;
                cell.dataset.idx = i;
                
                const label = document.createElement('span');
                label.className = 'cage-label';
                cell.appendChild(label);

                cell.addEventListener('click', (e) => {
                    if (!e.shiftKey && !e.ctrlKey && !e.metaKey) {
                        if (cellToCageMap[i] === undefined && !selectedCells.has(i)) {
                            selectedCells.clear();
                        }
                    }
                    if (cellToCageMap[i] === undefined) {
                        if (selectedCells.has(i)) {
                            selectedCells.delete(i);
                        } else {
                            selectedCells.add(i);
                        }
                        renderGrid();
                        updateSelectionCount();
                    }
                });
                gridContainer.appendChild(cell);
            }
            drawCageBorders();
        }

        function drawCageBorders() {
            const cells = gridContainer.children;
            cages.forEach((cage, cIdx) => {
                const sortedCells = [...cage.cells].sort((a, b) => a - b);
                const labelCell = cells[sortedCells[0]];
                labelCell.querySelector('.cage-label').innerText = `${cage.target}${cage.op === '=' ? '' : cage.op}`;
                cage.cells.forEach(idx => {
                    const r = Math.floor(idx / size);
                    const c = idx % size;
                    const cell = cells[idx];
                    if (r === 0 || cellToCageMap[idx - size] !== cIdx) cell.classList.add('border-t-heavy');
                    if (r === size - 1 || cellToCageMap[idx + size] !== cIdx) cell.classList.add('border-b-heavy');
                    if (c === 0 || cellToCageMap[idx - 1] !== cIdx) cell.classList.add('border-l-heavy');
                    if (c === size - 1 || cellToCageMap[idx + 1] !== cIdx) cell.classList.add('border-r-heavy');
                });
            });
        }

        function updateSelectionCount() {
            selectionStatus.textContent = `${selectedCells.size} Cells Selected`;
        }

        window.createCage = () => {
            const target = parseInt(cageTargetInput.value);
            const op = cageOpInput.value;
            if (isNaN(target) || selectedCells.size === 0) return;
            const newCage = { target, op, cells: Array.from(selectedCells), id: Date.now() };
            const cageIdx = cages.length;
            cages.push(newCage);
            newCage.cells.forEach(idx => cellToCageMap[idx] = cageIdx);
            selectedCells.clear();
            updateSelectionCount();
            cageTargetInput.value = '';
            renderGrid();
            updateCageList();
        };

        function updateCageList() {
            cageListEl.innerHTML = '';
            let covered = 0;
            cages.forEach((c, i) => {
                covered += c.cells.length;
                const div = document.createElement('div');
                div.className = 'flex justify-between items-center bg-slate-50 p-3 rounded-xl text-xs border border-slate-200';
                div.innerHTML = `
                    <span class="font-bold text-slate-700">
                        <strong class="text-blue-600">${c.target}${c.op === '=' ? '' : c.op}</strong> 
                        <span class="text-slate-400 ml-1">(${c.cells.length} cells)</span>
                    </span>
                    <button class="text-slate-300 hover:text-red-500 transition-colors" onclick="removeCage(${i})">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M6 18L18 6M6 6l12 12"></path></svg>
                    </button>`;
                cageListEl.appendChild(div);
            });
            document.getElementById('coverageLabel').textContent = `${covered} / ${size * size}`;
        }

        window.removeCage = (index) => {
            cages.splice(index, 1);
            cellToCageMap = {};
            cages.forEach((c, i) => c.cells.forEach(idx => cellToCageMap[idx] = i));
            renderGrid();
            updateCageList();
        };

        window.runSolver = async () => {
            const covered = Object.keys(cellToCageMap).length;
            if (covered < size * size) {
                alert("Please cover all cells before solving.");
                return;
            }
            const badge = document.getElementById('statusBadge');
            badge.innerText = "SOLVING...";
            badge.className = "text-[10px] uppercase tracking-widest px-2 py-0.5 rounded bg-blue-100 text-blue-600 font-bold";
            await new Promise(r => setTimeout(r, 200));
            const solver = new MathdokuSolver(size, cages);
            const success = solver.solve();
            if (success) {
                const rating = solver.rateDifficulty();
                renderResults(rating);
                renderSolution(solver.firstSolution);
            } else {
                badge.innerText = "IMPOSSIBLE";
                badge.className = "text-[10px] uppercase tracking-widest px-2 py-0.5 rounded bg-red-100 text-red-600 font-bold";
                document.getElementById('resultsArea').innerHTML = `<div class="p-6 rounded-2xl bg-red-50 border border-red-200 text-center"><p class="text-[10px] uppercase font-bold text-red-500 mb-1">Error</p><p class="text-xl font-black text-red-900">NO SOLUTION FOUND</p></div>`;
                document.getElementById('solutionContainer').innerHTML = '<div class="col-span-full py-12 text-center text-red-400 text-sm font-medium">Contradiction in cage logic.</div>';
            }
        };

        function renderResults(rating) {
            const badge = document.getElementById('statusBadge');
            badge.innerText = "VALID";
            badge.className = "text-[10px] uppercase tracking-widest px-2 py-0.5 rounded bg-green-100 text-green-600 font-bold";
            const rankColors = { "Easy": "text-green-600 bg-green-50", "Medium": "text-blue-600 bg-blue-50", "Hard": "text-yellow-600 bg-yellow-50", "Vicious": "text-orange-600 bg-orange-50", "Devilish": "text-red-600 bg-red-50", "Diabolical": "text-purple-600 bg-purple-50", "Beyond Diabolical": "text-white bg-slate-900" };
            const colorClass = rankColors[rating.rank] || "bg-slate-50";
            document.getElementById('resultsArea').innerHTML = `<div class="p-6 rounded-2xl ${colorClass.split(' ')[1]} border-2 border-slate-900 shadow-sm text-center"><p class="text-[10px] uppercase font-black text-slate-400 mb-1 tracking-tighter">Complexity Rating</p><p class="text-2xl font-black ${colorClass.split(' ')[0]}">${rating.rank.toUpperCase()}</p><div class="flex justify-center gap-4 mt-3 text-[10px] text-slate-500 font-bold uppercase tracking-widest"><span>Score: ${rating.score}</span><span>|</span><span>Complexity: ${rating.metrics.avgCageComplexity}</span></div></div>`;
        }

        function renderSolution(solution) {
            const container = document.getElementById('solutionContainer');
            container.style.gridTemplateColumns = `repeat(${size}, 1fr)`;
            container.innerHTML = '';
            solution.forEach(val => {
                const cell = document.createElement('div');
                cell.className = 'solution-cell';
                cell.textContent = val;
                container.appendChild(cell);
            });
        }

        window.resetConstructor = () => {
            cages = []; cellToCageMap = {}; selectedCells.clear();
            renderGrid(); updateCageList(); updateSelectionCount();
            document.getElementById('resultsArea').innerHTML = `<div class="p-8 rounded-2xl bg-slate-50 border border-dashed border-slate-200 text-slate-400 text-xs text-center font-medium">Awaiting grid completion...</div>`;
            document.getElementById('solutionContainer').innerHTML = '<div class="col-span-full py-12 text-center text-slate-600 text-sm italic font-medium">Solve to reveal solution...</div>';
            const badge = document.getElementById('statusBadge');
            badge.innerText = "IDLE";
            badge.className = "text-[10px] uppercase tracking-widest px-2 py-0.5 rounded bg-slate-100 text-slate-400 font-bold";
        };

        window.openExportModal = () => {
            const data = { size, cages };
            const base64 = btoa(JSON.stringify(data));
            const area = document.getElementById('modalTextarea');
            const btn = document.getElementById('modalActionBtn');
            document.getElementById('modalTitle').textContent = "Export Puzzle";
            area.value = base64; area.readOnly = true;
            btn.textContent = "Copy to Clipboard";
            btn.onclick = () => {
                area.select(); document.execCommand('copy');
                btn.textContent = "Copied!";
                setTimeout(() => btn.textContent = "Copy to Clipboard", 2000);
            };
            document.getElementById('modalOverlay').style.display = 'flex';
        };

        window.openImportModal = () => {
            const area = document.getElementById('modalTextarea');
            const btn = document.getElementById('modalActionBtn');
            document.getElementById('modalTitle').textContent = "Import Puzzle";
            area.value = ""; area.readOnly = false;
            btn.textContent = "Load Puzzle";
            btn.onclick = () => {
                try {
                    const data = JSON.parse(atob(area.value));
                    size = data.size; cages = data.cages;
                    gridSizeSelect.value = size;
                    cellToCageMap = {};
                    cages.forEach((c, i) => c.cells.forEach(idx => cellToCageMap[idx] = i));
                    renderGrid(); updateCageList(); closeModal();
                } catch (e) { alert("Invalid string."); }
            };
            document.getElementById('modalOverlay').style.display = 'flex';
        };

        window.closeModal = () => document.getElementById('modalOverlay').style.display = 'none';

        init();
    </script>
</body>
</html>
