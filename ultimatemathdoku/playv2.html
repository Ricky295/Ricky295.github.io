<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mathdoku Play</title>
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
  :root {
    --bg: #0e0e10; --surface: #18181b; --surface2: #222226;
    --border: #2e2e34; --accent: #f97316; --accent2: #fb923c;
    --text: #f4f4f5; --muted: #71717a; --danger: #ef4444; --success: #22c55e;
    --blue: #3b82f6;
  }
  body { background: var(--bg); color: var(--text); font-family: 'Segoe UI', system-ui, sans-serif; min-height: 100vh; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 16px; }

  /* â”€â”€ Lobby â”€â”€ */
  #lobby { display: flex; flex-direction: column; align-items: center; gap: 28px; width: 100%; max-width: 420px; }
  #lobby h1 { font-size: 2rem; font-weight: 900; letter-spacing: -0.04em; }
  #lobby h1 span { color: var(--accent); }

  .lobby-card { background: var(--surface); border: 1px solid var(--border); border-radius: 20px; padding: 24px; width: 100%; display: flex; flex-direction: column; gap: 16px; }
  .lobby-card h2 { font-size: .7rem; font-weight: 800; text-transform: uppercase; letter-spacing: .1em; color: var(--muted); }

  .option-row { display: flex; flex-direction: column; gap: 6px; }
  .option-row label { font-size: .68rem; font-weight: 700; text-transform: uppercase; letter-spacing: .08em; color: var(--muted); }
  .option-row input {
    background: var(--surface2); border: 1px solid var(--border); color: var(--text);
    padding: 10px 14px; border-radius: 10px; font-size: .9rem; font-weight: 700; outline: none; width: 100%;
  }
  .option-row input:focus { border-color: var(--accent); }

  .seg { display: flex; gap: 4px; flex-wrap: wrap; }
  .seg-btn { flex: 1; background: var(--surface2); border: 1px solid var(--border); color: var(--muted); padding: 9px 4px; border-radius: 8px; font-size: .78rem; font-weight: 800; cursor: pointer; transition: all .15s; text-align: center; min-width: 36px; }
  .seg-btn.active { background: var(--accent); border-color: var(--accent); color: #fff; }

  .btn { background: var(--surface2); border: 1px solid var(--border); color: var(--text); padding: 12px 20px; border-radius: 10px; font-size: .88rem; font-weight: 700; cursor: pointer; transition: background .15s, transform .1s; user-select: none; width: 100%; }
  .btn:hover { background: #2e2e36; }
  .btn:active { transform: scale(.97); }
  .btn-accent { background: var(--accent); border-color: var(--accent); color: #fff; }
  .btn-accent:hover { background: var(--accent2); }
  .btn-danger { border-color: #3f1818; color: var(--danger); }
  .btn-danger:hover { background: #1f1010; }

  .or-divider { display: flex; align-items: center; gap: 10px; color: var(--muted); font-size: .75rem; font-weight: 700; width: 100%; }
  .or-divider::before, .or-divider::after { content: ''; flex: 1; height: 1px; background: var(--border); }

  .gen-status { display: flex; align-items: center; gap: 10px; }
  .gen-info { display: flex; justify-content: space-between; font-size: .78rem; font-weight: 700; color: var(--muted); }
  .gen-info span b { color: var(--text); }
  .gen-info span.best b { color: var(--accent); }

  .spinner { width: 18px; height: 18px; border: 2px solid var(--border); border-top-color: var(--accent); border-radius: 50%; animation: spin .7s linear infinite; flex-shrink: 0; }
  @keyframes spin { to { transform: rotate(360deg); } }

  /* â”€â”€ Game â”€â”€ */
  #game { display: none; flex-direction: column; align-items: center; gap: 12px; width: 100%; max-width: 540px; }

  .game-topbar { width: 100%; display: flex; justify-content: space-between; align-items: center; }
  .back-btn { background: none; border: none; color: var(--muted); font-size: .8rem; font-weight: 700; cursor: pointer; padding: 4px 0; }
  .back-btn:hover { color: var(--text); }
  #timerDisplay { font-size: 1.1rem; font-weight: 900; letter-spacing: .05em; color: var(--text); font-variant-numeric: tabular-nums; }

  .puzzle-wrap { position: relative; width: 100%; }
  #gridEl { display: grid; border: 3px solid var(--text); background: var(--border); gap: 1px; touch-action: none; user-select: none; margin: 0 auto; }

  .cell {
    width: 100%; aspect-ratio: 1; background: var(--surface);
    display: flex; align-items: center; justify-content: center;
    font-size: clamp(.9rem, 4vw, 1.5rem); font-weight: 900;
    position: relative; cursor: pointer; transition: background .1s;
    border: 2px solid transparent;
  }
  .cell:hover { background: #1e1e22; }
  .cell.selected { background: #1c2a3a; border-color: var(--blue); z-index: 2; }
  .cell.given { color: var(--accent); cursor: default; }
  .cell.given:hover { background: var(--surface); }
  .cell.filled { color: var(--blue); }
  .cell.error { color: var(--danger) !important; background: #1f1010 !important; }
  .cell.correct { color: var(--success) !important; }
  .cell.highlight { background: #1a2030; }

  .cage-label {
    position: absolute; top: 2px; left: 3px;
    font-size: clamp(.4rem, 1.1vw, .6rem); font-weight: 900;
    color: var(--text); pointer-events: none; line-height: 1;
  }
  .bt { border-top: 3px solid var(--text) !important; }
  .bb { border-bottom: 3px solid var(--text) !important; }
  .bl { border-left: 3px solid var(--text) !important; }
  .br { border-right: 3px solid var(--text) !important; }

  .pencil-grid { display: grid; width: 90%; height: 90%; position: absolute; inset: 5%; }
  .pencil-digit { display: flex; align-items: center; justify-content: center; font-size: clamp(.3rem, .9vw, .5rem); font-weight: 700; color: var(--muted); line-height: 1; }

  #difficultyLabel { text-align: center; font-size: .7rem; font-weight: 800; text-transform: uppercase; letter-spacing: .12em; color: var(--muted); margin-top: 6px; }

  #numpad { display: grid; gap: 6px; width: 100%; }
  .np-btn {
    background: var(--surface); border: 1px solid var(--border); color: var(--text);
    aspect-ratio: 1; border-radius: 10px; font-size: clamp(1rem, 4vw, 1.4rem);
    font-weight: 900; cursor: pointer; transition: background .1s, transform .1s;
    display: flex; align-items: center; justify-content: center;
  }
  .np-btn:hover { background: var(--surface2); }
  .np-btn:active { transform: scale(.93); }
  .np-erase { background: var(--surface2); color: var(--muted); font-size: clamp(.7rem, 2.5vw, 1rem); }
  .np-pencil { background: var(--surface2); font-size: clamp(.65rem, 2vw, .85rem); }
  .np-pencil.active { background: #1c2a3a; border-color: var(--blue); color: var(--blue); }

  #winOverlay { display: none; position: fixed; inset: 0; background: rgba(0,0,0,.8); backdrop-filter: blur(8px); z-index: 200; align-items: center; justify-content: center; }
  #winOverlay.open { display: flex; }
  .win-box { background: var(--surface); border: 1px solid var(--border); border-radius: 24px; padding: 40px 32px; text-align: center; max-width: 340px; margin: 16px; }
  .win-box .emoji { font-size: 3rem; margin-bottom: 12px; }
  .win-box h2 { font-size: 1.6rem; font-weight: 900; margin-bottom: 6px; }
  .win-box p { color: var(--muted); font-size: .85rem; margin-bottom: 20px; }
  .win-stats { display: flex; justify-content: center; gap: 24px; margin-bottom: 24px; }
  .win-stat .val { font-size: 1.2rem; font-weight: 900; color: var(--accent); }
  .win-stat .lbl { font-size: .65rem; font-weight: 700; text-transform: uppercase; color: var(--muted); }
</style>
</head>
<body>

<!-- â”€â”€ Lobby â”€â”€ -->
<div id="lobby">
  <div style="text-align:center;">
    <h1>MATHDOKU<span>.PLAY</span></h1>
    <p style="color:var(--muted);font-size:.85rem;margin-top:6px;">Train your mind.</p>
  </div>

  <div class="lobby-card">
    <h2>New Puzzle</h2>

    <div class="option-row">
      <label>Grid Size</label>
      <div class="seg" id="sizeSegs">
        <div class="seg-btn active" data-val="4">4Ã—4</div>
        <div class="seg-btn" data-val="5">5Ã—5</div>
        <div class="seg-btn" data-val="6">6Ã—6</div>
        <div class="seg-btn" data-val="7">7Ã—7</div>
        <div class="seg-btn" data-val="8">8Ã—8</div>
        <div class="seg-btn" data-val="9">9Ã—9</div>
      </div>
    </div>

    <div class="option-row">
      <label>Difficulty</label>
      <div class="seg" id="diffSegs">
        <div class="seg-btn active" data-val="any">Any</div>
        <div class="seg-btn" data-val="Easy">Easy</div>
        <div class="seg-btn" data-val="Medium">Med</div>
        <div class="seg-btn" data-val="Hard">Hard</div>
        <div class="seg-btn" data-val="Vicious">Vic</div>
        <div class="seg-btn" data-val="Devilish">Dev</div>
        <div class="seg-btn" data-val="Diabolical">Dia</div>
        <div class="seg-btn" data-val="Beyond Diabolical">BD</div>
      </div>
    </div>

    <div class="option-row">
      <label>Uniqueness</label>
      <div class="seg" id="uniqSegs">
        <div class="seg-btn active" data-val="guaranteed">Guaranteed</div>
        <div class="seg-btn" data-val="any">Allow non-unique</div>
        <div class="seg-btn" data-val="only">Only non-unique</div>
      </div>
    </div>

    <button class="btn btn-accent" id="genBtn" onclick="generatePuzzle()">â–¶ Generate Puzzle</button>

    <div id="genInline" style="display:none; flex-direction:column; gap:10px;">
      <div class="gen-status">
        <div class="spinner"></div>
        <span style="font-size:.85rem;font-weight:800;color:var(--muted);text-transform:uppercase;letter-spacing:.08em;">Generatingâ€¦</span>
      </div>
      <div class="gen-info">
        <span>Attempts: <b id="genAttempts">0</b></span>
        <span class="best">Best so far: <b id="genBestLabel">â€”</b></span>
      </div>
      <button class="btn" id="genAcceptBtn" style="display:none;" onclick="acceptBest()">Accept Best</button>
      <button class="btn btn-danger" onclick="stopGeneration()">âœ• Cancel</button>
    </div>
  </div>

  <div class="or-divider">or</div>

  <div class="lobby-card">
    <h2>Load from String</h2>
    <div class="option-row">
      <label>Puzzle String</label>
      <input id="importStr" type="text" placeholder="Paste export stringâ€¦">
    </div>
    <button class="btn" onclick="loadFromString()">Load Puzzle</button>
  </div>
</div>

<!-- â”€â”€ Game â”€â”€ -->
<div id="game">
  <div class="game-topbar">
    <button class="back-btn" onclick="goLobby()">â† Back</button>
    <div id="timerDisplay">0:00</div>
  </div>
  <div class="puzzle-wrap">
    <div id="gridEl"></div>
    <div id="difficultyLabel">â€”</div>
  </div>
  <div id="numpad"></div>
</div>

<!-- Win overlay -->
<div id="winOverlay">
  <div class="win-box">
    <div class="emoji">ğŸ‰</div>
    <h2>Solved!</h2>
    <p id="winDiff"></p>
    <div class="win-stats">
      <div class="win-stat"><div class="val" id="winTime">â€”</div><div class="lbl">Time</div></div>
    </div>
    <button class="btn btn-accent" style="margin-top:8px;" onclick="goLobby()">Play Again</button>
  </div>
</div>

<script src="solver.js"></script>
<script>
// â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const $ = id => document.getElementById(id);
const sleep = ms => new Promise(r => setTimeout(r, ms));

// â”€â”€ Segment controls â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function segVal(id) { return $(id).querySelector('.seg-btn.active')?.dataset.val; }
document.querySelectorAll('.seg').forEach(seg => {
  seg.addEventListener('click', e => {
    const btn = e.target.closest('.seg-btn');
    if (!btn) return;
    seg.querySelectorAll('.seg-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
  });
});

// â”€â”€ URL load â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
window.addEventListener('DOMContentLoaded', () => {
  const p = new URLSearchParams(location.search).get('p');
  if (p) { try { startGame(JSON.parse(atob(p))); } catch(e) {} }
});

// â”€â”€ Lobby â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function loadFromString() {
  const str = $('importStr').value.trim();
  if (!str) return;
  try { startGame(JSON.parse(atob(str))); }
  catch(e) { alert('Invalid puzzle string.'); }
}

// â”€â”€ Difficulty bands â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const DIFF_BANDS = {
  'Easy':              [0,      0.5],
  'Medium':            [0.5,    1.2],
  'Hard':              [1.2,    1.6],
  'Vicious':           [1.6,    2.5],
  'Devilish':          [2.5,    3.4],
  'Diabolical':        [3.4,    5.0],
  'Beyond Diabolical': [5.0,  Infinity],
};

// Midpoint of each band â€” used to bias cage carving toward target difficulty
const DIFF_MIDPOINTS = {
  'Easy': 0.25, 'Medium': 0.85, 'Hard': 1.4, 'Vicious': 2.0,
  'Devilish': 2.95, 'Diabolical': 4.2, 'Beyond Diabolical': 7.0,
};

function diffProximity(score, targetDiff) {
  if (targetDiff === 'any') return 0;
  const band = DIFF_BANDS[targetDiff];
  if (!band) return Infinity;
  if (score >= band[0] && score < band[1]) return 0;
  if (score < band[0]) return band[0] - score;
  return score - band[1];
}

// â”€â”€ Cheap structural pre-filter â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Estimates approximate difficulty bucket WITHOUT calling rate().
// Returns a score bucket: 0=very_easy, 1=easy/med, 2=med/hard, 3=hard+
// so we can skip rating puzzles that are structurally too far from target.
function cheapDiffEstimate(puz) {
  const { size, cages } = puz;
  let singleCount = 0, opMix = 0, totalCells = 0;
  for (const cage of cages) {
    const n = cage.cells.length;
    totalCells += n;
    if (n === 1) singleCount++;
    if (cage.op === '-' || cage.op === '/') opMix++;
  }
  const singleRatio = singleCount / cages.length;
  const opRatio     = opMix / cages.length;
  const avgSize     = totalCells / cages.length;
  // Rough heuristic: more singles & fewer hard ops â†’ easier
  const easyScore   = singleRatio * 3 - opRatio * 2 - (avgSize - 1) * 0.5;
  if (easyScore >  1.5) return 0; // very easy
  if (easyScore >  0.5) return 1; // easy-medium range
  if (easyScore > -0.5) return 2; // medium-hard range
  return 3;                       // hard+
}

// Per-difficulty: which cheap bucket values to SKIP (not worth rating)
const CHEAP_SKIP = {
  'Easy':              new Set([2, 3]),
  'Medium':            new Set([3]),
  'Hard':              new Set([0]),
  'Vicious':           new Set([0]),
  'Devilish':          new Set([0, 1]),
  'Diabolical':        new Set([0, 1]),
  'Beyond Diabolical': new Set([0, 1]),
  'any':               new Set(),
};

// â”€â”€ Generation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let genRunning = false, genBestPuzzle = null, genBestProximity = Infinity, genBestLabel = 'â€”';

function stopGeneration() {
  genRunning = false;
  $('genInline').style.display = 'none';
  $('genBtn').style.display    = '';
}

async function generatePuzzle() {
  const size = parseInt(segVal('sizeSegs'));
  const diff = segVal('diffSegs');
  const uniq = segVal('uniqSegs');

  genRunning       = true;
  genBestPuzzle    = null;
  genBestProximity = Infinity;
  genBestLabel     = 'â€”';

  $('genBtn').style.display       = 'none';
  $('genInline').style.display    = 'flex';
  $('genAttempts').textContent    = '0';
  $('genBestLabel').textContent   = 'â€”';
  $('genAcceptBtn').style.display = 'none';
  await sleep(0);

  // Cage carving params steered by target difficulty
  const targetMid  = DIFF_MIDPOINTS[diff] ?? 1.5;
  // Higher difficulty â†’ prefer larger cages + more hard ops
  // targetMid range roughly 0.25 (Easy) to 7 (BD)
  const hardness   = Math.min(1, targetMid / 5); // 0..1
  const maxCageSz  = Math.round(2 + hardness * (Math.min(size, 5) - 2)); // 2..5
  // op bias: at hardness=0 strongly prefer +/*, at hardness=1 strongly prefer -//
  const hardOpProb = 0.1 + hardness * 0.7; // 0.1..0.8

  const skipSet = CHEAP_SKIP[diff] ?? new Set();

  let attempt = 0;
  while (genRunning) {
    attempt++;

    const puz = randomPuzzle(size, maxCageSz, hardOpProb);

    // â”€â”€ Cheap pre-filter: skip structurally wrong puzzles before solve/rate â”€â”€
    if (diff !== 'any') {
      const bucket = cheapDiffEstimate(puz);
      if (skipSet.has(bucket)) { await maybeYield(attempt); continue; }
    }

    // â”€â”€ Uniqueness check â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const solveResult = MathdokuSolver.solve(puz, { maxSolutions: 2 });
    if (!solveResult) { await maybeYield(attempt); continue; }
    const isUniq = solveResult.solutions.length === 1;
    if (uniq === 'guaranteed' && !isUniq) { await maybeYield(attempt); continue; }
    if (uniq === 'only'       &&  isUniq) { await maybeYield(attempt); continue; }

    // â”€â”€ Rate â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const rating   = MathdokuSolver.rate(puz);
    const rawDiff  = isUniq
      ? rating.difficulty
      : rating.difficulty.replace(/^Non-unique \(/, '').replace(/\)$/, '');
    const proximity = diffProximity(rating.score, diff);

    if (proximity < genBestProximity) {
      genBestProximity = proximity;
      genBestPuzzle    = puz;
      genBestLabel     = rawDiff + ' (' + rating.score + ')';
      $('genBestLabel').textContent   = genBestLabel;
      $('genAcceptBtn').style.display = '';
    }

    await maybeYield(attempt);
    if (!genRunning) return;

    if (proximity === 0) {
      genRunning = false;
      $('genInline').style.display = 'none';
      $('genBtn').style.display    = '';
      startGame(puz);
      return;
    }
  }
}

async function maybeYield(attempt) {
  if (attempt % 3 === 0) {
    $('genAttempts').textContent = attempt;
    await sleep(0);
  }
}

function acceptBest() {
  if (!genBestPuzzle) return;
  genRunning = false;
  $('genInline').style.display = 'none';
  $('genBtn').style.display    = '';
  startGame(genBestPuzzle);
}

// â”€â”€ Puzzle generation helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function randomPuzzle(size, maxCageSz, hardOpProb) {
  const grid  = fastLatinSquare(size);
  const cages = carveCages(grid, size, maxCageSz, hardOpProb);
  return { size, cages, givens: [] };
}

// â”€â”€ Fast Latin square: no backtracking â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Build via cyclic base then shuffle rows, cols, and value labels.
function fastLatinSquare(size) {
  // Start with row i = [(i + j) % size + 1 for j in 0..size]
  const grid = Array.from({length: size}, (_, i) =>
    Array.from({length: size}, (_, j) => (i + j) % size + 1)
  );
  // Shuffle row groups (for sizes with natural groups) and individual rows
  shuffleArr(grid);
  // Shuffle columns
  const colPerm = shuffle(Array.from({length: size}, (_, i) => i));
  for (let r = 0; r < size; r++) {
    const row = grid[r].slice();
    for (let c = 0; c < size; c++) grid[r][c] = row[colPerm[c]];
  }
  // Relabel values (permute 1..size)
  const valPerm = shuffle(Array.from({length: size}, (_, i) => i + 1));
  for (let r = 0; r < size; r++)
    for (let c = 0; c < size; c++)
      grid[r][c] = valPerm[grid[r][c] - 1];
  return grid;
}

// â”€â”€ Cage carving with difficulty steering â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function carveCages(grid, size, maxCageSz, hardOpProb) {
  const assigned = Array.from({length: size}, () => new Uint8Array(size));
  const cages = [];

  // Scan in random order
  const order = shuffle(Array.from({length: size * size}, (_, i) => i));

  for (const flat of order) {
    const r0 = Math.floor(flat / size), c0 = flat % size;
    if (assigned[r0][c0]) continue;

    const cells = [[r0, c0]];
    assigned[r0][c0] = 1;

    // Grow cage using a BFS frontier, pick randomly
    // Larger maxCageSz â†’ harder puzzle (more ambiguity per cage)
    const targetSz = 1 + Math.floor(Math.random() * maxCageSz);
    while (cells.length < targetSz) {
      // Collect all unassigned orthogonal neighbours of cells already in cage
      const frontier = [];
      for (const [cr, cc] of cells) {
        for (const [dr, dc] of [[-1,0],[1,0],[0,-1],[0,1]]) {
          const nr = cr + dr, nc = cc + dc;
          if (nr >= 0 && nr < size && nc >= 0 && nc < size && !assigned[nr][nc]) {
            // Avoid duplicates in frontier
            if (!frontier.some(([a,b]) => a===nr && b===nc))
              frontier.push([nr, nc]);
          }
        }
      }
      if (!frontier.length) break;
      const [nr, nc] = frontier[Math.floor(Math.random() * frontier.length)];
      cells.push([nr, nc]);
      assigned[nr][nc] = 1;
    }

    const vals = cells.map(([cr, cc]) => grid[cr][cc]);
    const { op, target } = chooseOp(vals, hardOpProb);
    cages.push({ id: Date.now() + cages.length, cells, op, target });
  }
  return cages;
}

// â”€â”€ Operation selection with hard-op bias â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function chooseOp(vals, hardOpProb = 0.4) {
  if (vals.length === 1) return { op: '=', target: vals[0] };

  const sorted = [...vals].sort((a, b) => b - a);
  const sub    = sorted.slice(1).reduce((a, v) => a - v, sorted[0]);
  const div    = sorted.slice(1).reduce((a, v) => a / v, sorted[0]);

  const canSub = sub > 0;
  const canDiv = Number.isInteger(div) && div > 0;

  // Build weighted op list
  // Hard ops (- /) get weight = hardOpProb share; soft ops (+, *) share the rest
  const opts = [];
  const softW = (1 - hardOpProb) / 2;
  const hardW = canSub || canDiv
    ? hardOpProb / (canSub && canDiv ? 2 : 1)
    : 0;
  const softBoost = canSub || canDiv ? 0 : (1 - hardW) / 2;

  opts.push({ op: '+', w: softW + softBoost });
  opts.push({ op: '*', w: softW + softBoost });
  if (canSub) opts.push({ op: '-', w: hardW });
  if (canDiv) opts.push({ op: '/', w: hardW });

  // Weighted random pick
  let r = Math.random();
  let op = '+';
  for (const o of opts) {
    r -= o.w;
    if (r <= 0) { op = o.op; break; }
  }

  const target = op === '+' ? vals.reduce((a, b) => a + b, 0)
               : op === '*' ? vals.reduce((a, b) => a * b, 1)
               : op === '-' ? sub : div;
  return { op, target };
}

function shuffleArr(arr) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
}
function shuffle(arr) { shuffleArr(arr); return arr; }

// â”€â”€ Game state â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let puzzle, solution, userGrid, pencilGrid, selected, pencilMode, timerSec, timerInt, solved, difficulty;

function startGame(puz) {
  puzzle = puz;
  const N = puz.size;
  const result = MathdokuSolver.solve(puz, { maxSolutions: 1 });
  if (!result) { alert('This puzzle has no solution.'); return; }
  solution   = result.grid;
  difficulty = MathdokuSolver.rate(puz).difficulty;
  userGrid   = Array.from({length: N}, () => new Array(N).fill(0));
  pencilGrid = Array.from({length: N}, () => Array.from({length: N}, () => new Set()));
  selected   = null;
  pencilMode = false;
  solved     = false;
  (puz.givens||[]).forEach(g => { userGrid[g.row][g.col] = g.value; });
  clearInterval(timerInt);
  timerSec = 0;
  $('timerDisplay').textContent = '0:00';
  timerInt = setInterval(() => {
    if (solved) return;
    timerSec++;
    $('timerDisplay').textContent = Math.floor(timerSec/60) + ':' + String(timerSec%60).padStart(2,'0');
  }, 1000);
  $('lobby').style.display = 'none';
  $('game').style.display  = 'flex';
  $('difficultyLabel').textContent = difficulty;
  const encoded = btoa(JSON.stringify({ size: puz.size, cages: puz.cages, givens: puz.givens || [] }));
  history.replaceState(null, '', '?p=' + encoded);
  renderGrid();
  renderNumpad();
}

function goLobby() {
  clearInterval(timerInt);
  $('winOverlay').classList.remove('open');
  $('game').style.display  = 'none';
  $('lobby').style.display = 'flex';
}

// â”€â”€ Render grid â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderGrid() {
  const N  = puzzle.size;
  const el = $('gridEl');
  const maxW  = Math.min(window.innerWidth - 32, 480);
  const cellPx = Math.floor((maxW - N) / N);
  el.style.gridTemplateColumns = 'repeat(' + N + ', ' + cellPx + 'px)';
  el.style.width = (cellPx * N + N - 1) + 'px';
  el.innerHTML = '';

  const cellToCage = Array.from({length:N}, () => new Array(N).fill(-1));
  puzzle.cages.forEach((cage,ci) => cage.cells.forEach(([r,c]) => cellToCage[r][c] = ci));

  for (let r = 0; r < N; r++) {
    for (let c = 0; c < N; c++) {
      const ci      = cellToCage[r][c];
      const isGiven = (puzzle.givens||[]).some(g => g.row===r && g.col===c);
      const val     = userGrid[r][c];
      const isSel   = selected && selected[0]===r && selected[1]===c;
      const isHl    = selected && !isSel && (selected[0]===r || selected[1]===c);

      const div = document.createElement('div');
      let cls = 'cell';
      if (isGiven)                          cls += ' given';
      else if (val && val===solution[r][c]) cls += ' correct';
      else if (val)                         cls += ' error';
      if (isSel) cls += ' selected';
      else if (isHl) cls += ' highlight';
      div.className = cls;

      if (ci !== -1) {
        const cage = puzzle.cages[ci];
        const inCage = (rr,cc) => cage.cells.some(([a,b]) => a===rr && b===cc);
        if (r===0    || !inCage(r-1,c)) div.classList.add('bt');
        if (r===N-1  || !inCage(r+1,c)) div.classList.add('bb');
        if (c===0    || !inCage(r,c-1)) div.classList.add('bl');
        if (c===N-1  || !inCage(r,c+1)) div.classList.add('br');
        const sorted = [...cage.cells].sort((a,b) => (a[0]*N+a[1])-(b[0]*N+b[1]));
        if (sorted[0][0]===r && sorted[0][1]===c) {
          const lbl = document.createElement('span');
          lbl.className = 'cage-label';
          lbl.textContent = cage.target + (cage.op==='=' ? '' : cage.op);
          div.appendChild(lbl);
        }
      }

      if (val) {
        div.append(val);
      } else {
        const marks = pencilGrid[r][c];
        if (marks.size > 0) {
          const cols = Math.ceil(Math.sqrt(N));
          const pg = document.createElement('div');
          pg.className = 'pencil-grid';
          pg.style.gridTemplateColumns = 'repeat(' + cols + ', 1fr)';
          for (let v = 1; v <= N; v++) {
            const pd = document.createElement('div');
            pd.className = 'pencil-digit';
            pd.textContent = marks.has(v) ? v : '';
            pg.appendChild(pd);
          }
          div.appendChild(pg);
        }
      }

      if (!isGiven) div.addEventListener('click', () => { selected = [r,c]; renderGrid(); });
      el.appendChild(div);
    }
  }
}

// â”€â”€ Input â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function inputValue(v) {
  if (!selected || solved) return;
  const [r, c] = selected;
  if ((puzzle.givens||[]).some(g => g.row===r && g.col===c)) return;
  if (pencilMode) {
    if (userGrid[r][c]) return;
    if (pencilGrid[r][c].has(v)) pencilGrid[r][c].delete(v);
    else pencilGrid[r][c].add(v);
  } else {
    userGrid[r][c] = v;
    pencilGrid[r][c].clear();
    for (let i = 0; i < puzzle.size; i++) { pencilGrid[r][i].delete(v); pencilGrid[i][c].delete(v); }
    checkWin();
  }
  renderGrid();
}

function eraseCell() {
  if (!selected || solved) return;
  const [r, c] = selected;
  if ((puzzle.givens||[]).some(g => g.row===r && g.col===c)) return;
  userGrid[r][c] = 0;
  pencilGrid[r][c].clear();
  renderGrid();
}

function checkWin() {
  const N = puzzle.size;
  for (let r = 0; r < N; r++)
    for (let c = 0; c < N; c++)
      if (userGrid[r][c] !== solution[r][c]) return;
  solved = true;
  clearInterval(timerInt);
  const m = Math.floor(timerSec/60), s = timerSec%60;
  $('winTime').textContent = m + ':' + String(s).padStart(2,'0');
  $('winDiff').textContent = difficulty;
  setTimeout(() => $('winOverlay').classList.add('open'), 400);
}

// â”€â”€ Numpad â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderNumpad() {
  const N  = puzzle.size;
  const np = $('numpad');
  np.innerHTML = '';
  np.style.gridTemplateColumns = 'repeat(' + (N + 2) + ', 1fr)';
  for (let v = 1; v <= N; v++) {
    const btn = document.createElement('button');
    btn.className = 'np-btn' + (pencilMode ? ' pencil-mode' : '');
    btn.textContent = v;
    btn.onclick = () => inputValue(v);
    np.appendChild(btn);
  }
  const pencilBtn = document.createElement('button');
  pencilBtn.className = 'np-btn np-pencil' + (pencilMode ? ' active' : '');
  pencilBtn.textContent = 'âœï¸';
  pencilBtn.onclick = () => { pencilMode = !pencilMode; renderNumpad(); };
  np.appendChild(pencilBtn);
  const eraseBtn = document.createElement('button');
  eraseBtn.className = 'np-btn np-erase';
  eraseBtn.textContent = 'âŒ«';
  eraseBtn.onclick = () => eraseCell();
  np.appendChild(eraseBtn);
}

// â”€â”€ Keyboard â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
document.addEventListener('keydown', e => {
  if ($('game').style.display === 'none') return;
  if (['INPUT','TEXTAREA'].includes(document.activeElement.tagName)) return;
  const N = puzzle?.size || 4;
  const digit = parseInt(e.key);
  if (!isNaN(digit) && digit >= 1 && digit <= N) { inputValue(digit); return; }
  if (e.key==='Backspace'||e.key==='Delete'||e.key==='0') { eraseCell(); return; }
  if (e.key==='p'||e.key==='P') { pencilMode = !pencilMode; renderNumpad(); renderGrid(); return; }
  if (selected) {
    const dirs = { ArrowUp:[-1,0], ArrowDown:[1,0], ArrowLeft:[0,-1], ArrowRight:[0,1] };
    if (dirs[e.key]) {
      e.preventDefault();
      const [dr,dc] = dirs[e.key];
      selected = [Math.max(0,Math.min(N-1,selected[0]+dr)), Math.max(0,Math.min(N-1,selected[1]+dc))];
      renderGrid();
    }
  }
});

window.addEventListener('resize', () => { if (puzzle) renderGrid(); });
</script>
</body>
</html>
