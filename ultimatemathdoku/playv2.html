<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mathdoku Play</title>
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
  :root {
    --bg: #0e0e10; --surface: #18181b; --surface2: #222226;
    --border: #2e2e34; --accent: #f97316; --accent2: #fb923c;
    --text: #f4f4f5; --muted: #71717a; --danger: #ef4444; --success: #22c55e;
    --blue: #3b82f6;
  }
  body { background: var(--bg); color: var(--text); font-family: 'Segoe UI', system-ui, sans-serif; min-height: 100vh; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 16px; }

  /* ‚îÄ‚îÄ Lobby ‚îÄ‚îÄ */
  #lobby { display: flex; flex-direction: column; align-items: center; gap: 28px; width: 100%; max-width: 420px; }
  #lobby h1 { font-size: 2rem; font-weight: 900; letter-spacing: -0.04em; }
  #lobby h1 span { color: var(--accent); }

  .lobby-card { background: var(--surface); border: 1px solid var(--border); border-radius: 20px; padding: 24px; width: 100%; display: flex; flex-direction: column; gap: 16px; }
  .lobby-card h2 { font-size: .7rem; font-weight: 800; text-transform: uppercase; letter-spacing: .1em; color: var(--muted); }

  .option-row { display: flex; flex-direction: column; gap: 6px; }
  .option-row label { font-size: .68rem; font-weight: 700; text-transform: uppercase; letter-spacing: .08em; color: var(--muted); }
  .option-row input {
    background: var(--surface2); border: 1px solid var(--border); color: var(--text);
    padding: 10px 14px; border-radius: 10px; font-size: .9rem; font-weight: 700; outline: none; width: 100%;
  }
  .option-row input:focus { border-color: var(--accent); }

  .seg { display: flex; gap: 4px; flex-wrap: wrap; }
  .seg-btn { flex: 1; background: var(--surface2); border: 1px solid var(--border); color: var(--muted); padding: 9px 4px; border-radius: 8px; font-size: .78rem; font-weight: 800; cursor: pointer; transition: all .15s; text-align: center; min-width: 36px; }
  .seg-btn.active { background: var(--accent); border-color: var(--accent); color: #fff; }

  .btn { background: var(--surface2); border: 1px solid var(--border); color: var(--text); padding: 12px 20px; border-radius: 10px; font-size: .88rem; font-weight: 700; cursor: pointer; transition: background .15s, transform .1s; user-select: none; width: 100%; }
  .btn:hover { background: #2e2e36; }
  .btn:active { transform: scale(.97); }
  .btn-accent { background: var(--accent); border-color: var(--accent); color: #fff; }
  .btn-accent:hover { background: var(--accent2); }
  .btn-danger { border-color: #3f1818; color: var(--danger); }
  .btn-danger:hover { background: #1f1010; }

  .or-divider { display: flex; align-items: center; gap: 10px; color: var(--muted); font-size: .75rem; font-weight: 700; width: 100%; }
  .or-divider::before, .or-divider::after { content: ''; flex: 1; height: 1px; background: var(--border); }

  .gen-status { display: flex; align-items: center; gap: 10px; }
  .gen-info { display: flex; justify-content: space-between; font-size: .78rem; font-weight: 700; color: var(--muted); }
  .gen-info span b { color: var(--text); }
  .gen-info span.best b { color: var(--accent); }

  .spinner { width: 18px; height: 18px; border: 2px solid var(--border); border-top-color: var(--accent); border-radius: 50%; animation: spin .7s linear infinite; flex-shrink: 0; }
  @keyframes spin { to { transform: rotate(360deg); } }

  /* ‚îÄ‚îÄ Game ‚îÄ‚îÄ */
  #game { display: none; flex-direction: column; align-items: center; gap: 12px; width: 100%; max-width: 540px; }

  .game-topbar { width: 100%; display: flex; justify-content: space-between; align-items: center; }
  .back-btn { background: none; border: none; color: var(--muted); font-size: .8rem; font-weight: 700; cursor: pointer; padding: 4px 0; }
  .back-btn:hover { color: var(--text); }
  #timerDisplay { font-size: 1.1rem; font-weight: 900; letter-spacing: .05em; color: var(--text); font-variant-numeric: tabular-nums; }

  .puzzle-wrap { position: relative; width: 100%; }
  #gridEl { display: grid; border: 3px solid var(--text); background: var(--border); gap: 1px; touch-action: none; user-select: none; margin: 0 auto; }

  .cell {
    width: 100%; aspect-ratio: 1; background: var(--surface);
    display: flex; align-items: center; justify-content: center;
    font-size: clamp(.9rem, 4vw, 1.5rem); font-weight: 900;
    position: relative; cursor: pointer; transition: background .1s;
    border: 2px solid transparent;
  }
  .cell:hover { background: #1e1e22; }
  .cell.selected { background: #1c2a3a; border-color: var(--blue); z-index: 2; }
  .cell.given { color: var(--accent); cursor: default; }
  .cell.given:hover { background: var(--surface); }
  .cell.filled { color: var(--blue); }
  .cell.error { color: var(--danger) !important; background: #1f1010 !important; }
  .cell.correct { color: var(--success) !important; }
  .cell.highlight { background: #1a2030; }

  .cage-label {
    position: absolute; top: 2px; left: 3px;
    font-size: clamp(.4rem, 1.1vw, .6rem); font-weight: 900;
    color: var(--text); pointer-events: none; line-height: 1;
  }
  .bt { border-top: 3px solid var(--text) !important; }
  .bb { border-bottom: 3px solid var(--text) !important; }
  .bl { border-left: 3px solid var(--text) !important; }
  .br { border-right: 3px solid var(--text) !important; }

  .pencil-grid { display: grid; width: 90%; height: 90%; position: absolute; inset: 5%; }
  .pencil-digit { display: flex; align-items: center; justify-content: center; font-size: clamp(.3rem, .9vw, .5rem); font-weight: 700; color: var(--muted); line-height: 1; }

  #difficultyLabel { text-align: center; font-size: .7rem; font-weight: 800; text-transform: uppercase; letter-spacing: .12em; color: var(--muted); margin-top: 6px; }

  #numpad { display: grid; gap: 6px; width: 100%; }
  .np-btn {
    background: var(--surface); border: 1px solid var(--border); color: var(--text);
    aspect-ratio: 1; border-radius: 10px; font-size: clamp(1rem, 4vw, 1.4rem);
    font-weight: 900; cursor: pointer; transition: background .1s, transform .1s;
    display: flex; align-items: center; justify-content: center;
  }
  .np-btn:hover { background: var(--surface2); }
  .np-btn:active { transform: scale(.93); }
  .np-erase { background: var(--surface2); color: var(--muted); font-size: clamp(.7rem, 2.5vw, 1rem); }
  .np-pencil { background: var(--surface2); font-size: clamp(.65rem, 2vw, .85rem); }
  .np-pencil.active { background: #1c2a3a; border-color: var(--blue); color: var(--blue); }

  #winOverlay { display: none; position: fixed; inset: 0; background: rgba(0,0,0,.8); backdrop-filter: blur(8px); z-index: 200; align-items: center; justify-content: center; }
  #winOverlay.open { display: flex; }
  .win-box { background: var(--surface); border: 1px solid var(--border); border-radius: 24px; padding: 40px 32px; text-align: center; max-width: 340px; margin: 16px; }
  .win-box .emoji { font-size: 3rem; margin-bottom: 12px; }
  .win-box h2 { font-size: 1.6rem; font-weight: 900; margin-bottom: 6px; }
  .win-box p { color: var(--muted); font-size: .85rem; margin-bottom: 20px; }
  .win-stats { display: flex; justify-content: center; gap: 24px; margin-bottom: 24px; }
  .win-stat .val { font-size: 1.2rem; font-weight: 900; color: var(--accent); }
  .win-stat .lbl { font-size: .65rem; font-weight: 700; text-transform: uppercase; color: var(--muted); }
</style>
</head>
<body>

<!-- ‚îÄ‚îÄ Lobby ‚îÄ‚îÄ -->
<div id="lobby">
  <div style="text-align:center;">
    <h1>MATHDOKU<span>.PLAY</span></h1>
    <p style="color:var(--muted);font-size:.85rem;margin-top:6px;">Train your mind.</p>
  </div>

  <div class="lobby-card">
    <h2>New Puzzle</h2>

    <div class="option-row">
      <label>Grid Size</label>
      <div class="seg" id="sizeSegs">
        <div class="seg-btn active" data-val="4">4√ó4</div>
        <div class="seg-btn" data-val="5">5√ó5</div>
        <div class="seg-btn" data-val="6">6√ó6</div>
        <div class="seg-btn" data-val="7">7√ó7</div>
        <div class="seg-btn" data-val="8">8√ó8</div>
        <div class="seg-btn" data-val="9">9√ó9</div>
      </div>
    </div>

    <div class="option-row">
      <label>Difficulty</label>
      <div class="seg" id="diffSegs">
        <div class="seg-btn active" data-val="any">Any</div>
        <div class="seg-btn" data-val="Easy">Easy</div>
        <div class="seg-btn" data-val="Medium">Med</div>
        <div class="seg-btn" data-val="Hard">Hard</div>
        <div class="seg-btn" data-val="Vicious">Vic</div>
        <div class="seg-btn" data-val="Devilish">Dev</div>
        <div class="seg-btn" data-val="Diabolical">Dia</div>
        <div class="seg-btn" data-val="Beyond Diabolical">BD</div>
      </div>
    </div>

    <div class="option-row">
      <label>Uniqueness</label>
      <div class="seg" id="uniqSegs">
        <div class="seg-btn active" data-val="guaranteed">Guaranteed</div>
        <div class="seg-btn" data-val="any">Allow non-unique</div>
        <div class="seg-btn" data-val="only">Only non-unique</div>
      </div>
    </div>

    <!-- Generate button -->
    <button class="btn btn-accent" id="genBtn" onclick="generatePuzzle()">‚ñ∂ Generate Puzzle</button>

    <!-- Inline generation status (hidden until generating) -->
    <div id="genInline" style="display:none; flex-direction:column; gap:10px;">
      <div class="gen-status">
        <div class="spinner"></div>
        <span style="font-size:.85rem;font-weight:800;color:var(--muted);text-transform:uppercase;letter-spacing:.08em;">Generating‚Ä¶</span>
      </div>
      <div class="gen-info">
        <span>Attempts: <b id="genAttempts">0</b></span>
        <span class="best">Best so far: <b id="genBestLabel">‚Äî</b></span>
      </div>
      <button class="btn" id="genAcceptBtn" style="display:none;" onclick="acceptBest()">Accept Best</button>
      <button class="btn btn-danger" onclick="stopGeneration()">‚úï Cancel</button>
    </div>
  </div>

  <div class="or-divider">or</div>

  <div class="lobby-card">
    <h2>Load from String</h2>
    <div class="option-row">
      <label>Puzzle String</label>
      <input id="importStr" type="text" placeholder="Paste export string‚Ä¶">
    </div>
    <button class="btn" onclick="loadFromString()">Load Puzzle</button>
  </div>
</div>

<!-- ‚îÄ‚îÄ Game ‚îÄ‚îÄ -->
<div id="game">
  <div class="game-topbar">
    <button class="back-btn" onclick="goLobby()">‚Üê Back</button>
    <div id="timerDisplay">0:00</div>
  </div>
  <div class="puzzle-wrap">
    <div id="gridEl"></div>
    <div id="difficultyLabel">‚Äî</div>
  </div>
  <div id="numpad"></div>
</div>

<!-- Win overlay -->
<div id="winOverlay">
  <div class="win-box">
    <div class="emoji">üéâ</div>
    <h2>Solved!</h2>
    <p id="winDiff"></p>
    <div class="win-stats">
      <div class="win-stat"><div class="val" id="winTime">‚Äî</div><div class="lbl">Time</div></div>
    </div>
    <button class="btn btn-accent" style="margin-top:8px;" onclick="goLobby()">Play Again</button>
  </div>
</div>

<script src="solver.js"></script>
<script>
// ‚îÄ‚îÄ Helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const $ = id => document.getElementById(id);
const sleep = ms => new Promise(r => setTimeout(r, ms));

// ‚îÄ‚îÄ Segment controls ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function segVal(id) { return $(id).querySelector('.seg-btn.active')?.dataset.val; }
document.querySelectorAll('.seg').forEach(seg => {
  seg.addEventListener('click', e => {
    const btn = e.target.closest('.seg-btn');
    if (!btn) return;
    seg.querySelectorAll('.seg-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
  });
});

// ‚îÄ‚îÄ URL load ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
window.addEventListener('DOMContentLoaded', () => {
  const p = new URLSearchParams(location.search).get('p');
  if (p) { try { startGame(JSON.parse(atob(p))); } catch(e) {} }
});

// ‚îÄ‚îÄ Lobby ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function loadFromString() {
  const str = $('importStr').value.trim();
  if (!str) return;
  try { startGame(JSON.parse(atob(str))); }
  catch(e) { alert('Invalid puzzle string.'); }
}

// ‚îÄ‚îÄ Generation ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Difficulty band boundaries [min, max) ‚Äî used to compute proximity score
const DIFF_BANDS = {
  'Easy':              [0,      0.5],
  'Medium':            [0.5,    1.2],
  'Hard':              [1.2,    1.6],
  'Vicious':           [1.6,    2.5],
  'Devilish':          [2.5,    3.4],
  'Diabolical':        [3.4,    5.0],
  'Beyond Diabolical': [5.0,  Infinity],
};

function diffProximity(score, targetDiff) {
  if (targetDiff === 'any') return 0; // all equally good
  const band = DIFF_BANDS[targetDiff];
  if (!band) return Infinity;
  if (score >= band[0] && score < band[1]) return 0; // inside band
  if (score < band[0]) return band[0] - score;       // below band
  return score - band[1];                            // above band
}

let genRunning = false, genBestPuzzle = null, genBestProximity = Infinity, genBestLabel = '‚Äî';

function stopGeneration() {
  genRunning = false;
  $('genInline').style.display = 'none';
  $('genBtn').style.display    = '';
}

async function generatePuzzle() {
  const size = parseInt(segVal('sizeSegs'));
  const diff = segVal('diffSegs');
  const uniq = segVal('uniqSegs');

  genRunning       = true;
  genBestPuzzle    = null;
  genBestProximity = Infinity;
  genBestLabel     = '‚Äî';

  $('genBtn').style.display       = 'none';
  $('genInline').style.display    = 'flex';
  $('genAttempts').textContent    = '0';
  $('genBestLabel').textContent   = '‚Äî';
  $('genAcceptBtn').style.display = 'none';
  await sleep(0);

  let attempt = 0;
  while (genRunning) {
    attempt++;

    const puz = randomPuzzle(size);

    // Fast uniqueness check only ‚Äî no full rate() yet
    const solveResult = MathdokuSolver.solve(puz, { maxSolutions: 2 });
    if (!solveResult) continue; // no solution at all, skip
    const isUniq = solveResult.solutions.length === 1;

    // Uniqueness filter ‚Äî don't even consider these for best-so-far
    if (uniq === 'guaranteed' && !isUniq) { await maybeYield(attempt); continue; }
    if (uniq === 'only'       &&  isUniq) { await maybeYield(attempt); continue; }

    // Now rate (only puzzles that pass uniqueness filter)
    const rating  = MathdokuSolver.rate(puz);
    const rawDiff = isUniq
      ? rating.difficulty
      : rating.difficulty.replace(/^Non-unique \(/, '').replace(/\)$/, '');
    const proximity = diffProximity(rating.score, diff);

    // Update best-so-far if this is closer to target
    if (proximity < genBestProximity) {
      genBestProximity = proximity;
      genBestPuzzle    = puz;
      genBestLabel     = rawDiff + ' (' + rating.score + ')';
      $('genBestLabel').textContent   = genBestLabel;
      $('genAcceptBtn').style.display = '';
    }

    await maybeYield(attempt);
    if (!genRunning) return;

    // Exact match
    if (proximity === 0) {
      genRunning = false;
      $('genInline').style.display = 'none';
      $('genBtn').style.display    = '';
      startGame(puz);
      return;
    }
  }
}

async function maybeYield(attempt) {
  if (attempt % 3 === 0) {
    $('genAttempts').textContent = attempt;
    await sleep(0);
  }
}

function acceptBest() {
  if (!genBestPuzzle) return;
  genRunning = false;
  $('genInline').style.display = 'none';
  $('genBtn').style.display    = '';
  startGame(genBestPuzzle);
}

// ‚îÄ‚îÄ Puzzle generation helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function randomPuzzle(size) {
  const grid  = randomLatinSquare(size);
  const cages = carveCages(grid, size);
  return { size, cages, givens: [] };
}

function randomLatinSquare(size) {
  // Use a row-by-row approach with bitmasks for fast conflict checking
  const grid    = Array.from({length: size}, () => new Array(size).fill(0));
  const rowUsed = new Array(size).fill(0);  // bitmask of used values per row
  const colUsed = new Array(size).fill(0);  // bitmask of used values per col

  function bt(pos) {
    if (pos === size * size) return true;
    const r = Math.floor(pos / size), c = pos % size;
    const used = rowUsed[r] | colUsed[c];
    const vals = shuffle(Array.from({length: size}, (_,i) => i+1));
    for (const v of vals) {
      const bit = 1 << v;
      if (used & bit) continue;
      grid[r][c]  = v;
      rowUsed[r] |= bit;
      colUsed[c] |= bit;
      if (bt(pos+1)) return true;
      grid[r][c]  = 0;
      rowUsed[r] &= ~bit;
      colUsed[c] &= ~bit;
    }
    return false;
  }
  bt(0);
  return grid;
}

function carveCages(grid, size) {
  const assigned = Array.from({length: size}, () => new Array(size).fill(false));
  const cages = [];
  const MAX_COMBOS = 500;

  const order = shuffle(Array.from({length: size*size}, (_,i) => i));
  for (const flat of order) {
    const r = Math.floor(flat / size), c = flat % size;
    if (assigned[r][c]) continue;
    const cells = [[r, c]];
    assigned[r][c] = true;

    for (let t = 0; t < size - 1; t++) {
      const cands = [];
      for (const [cr, cc] of cells)
        for (const [dr, dc] of [[-1,0],[1,0],[0,-1],[0,1]]) {
          const nr = cr+dr, nc = cc+dc;
          if (nr>=0 && nr<size && nc>=0 && nc<size && !assigned[nr][nc])
            cands.push([nr, nc]);
        }
      if (!cands.length) break;

      // Try adding a neighbour ‚Äî only commit if combos stay under cap
      const candidate = cands[Math.floor(Math.random() * cands.length)];
      const testCells = [...cells, candidate];
      const testVals  = testCells.map(([cr,cc]) => grid[cr][cc]);
      const { op, target } = chooseOp(testVals);
      const combos = countCombos(testCells, op, target, size);
      if (combos > MAX_COMBOS) break; // too complex, stop growing

      cells.push(candidate);
      assigned[candidate[0]][candidate[1]] = true;
    }

    const vals = cells.map(([cr,cc]) => grid[cr][cc]);
    const { op, target } = chooseOp(vals);
    cages.push({ id: Date.now() + cages.length, cells, op, target });
  }
  return cages;
}

function countCombos(cells, op, target, size) {
  const n = cells.length;
  let count = 0;
  function gen(idx, cur) {
    if (idx === n) {
      // reuse checkCage from solver
      if (checkCageLocal(cur, op, target)) count++;
      return;
    }
    for (let v = 1; v <= size; v++) { cur.push(v); gen(idx+1, cur); cur.pop(); }
  }
  gen(0, []);
  return count;
}

function checkCageLocal(values, op, target) {
  switch(op) {
    case '=': return values.length === 1 && values[0] === target;
    case '+': return values.reduce((a,b) => a+b, 0) === target;
    case '*': return values.reduce((a,b) => a*b, 1) === target;
    case '-': { const s = [...values].sort((a,b)=>b-a); return s.slice(1).reduce((a,v)=>a-v, s[0]) === target; }
    case '/': { const s = [...values].sort((a,b)=>b-a); return s.slice(1).reduce((a,v)=>a/v, s[0]) === target; }
  }
  return false;
}

function chooseOp(vals) {
  if (vals.length === 1) return { op: '=', target: vals[0] };
  const ops = ['+', '*'];
  const sorted = [...vals].sort((a,b) => b-a);
  const sub = sorted.slice(1).reduce((a,v) => a-v, sorted[0]);
  const div = sorted.slice(1).reduce((a,v) => a/v, sorted[0]);
  if (sub > 0) ops.push('-');
  if (Number.isInteger(div) && div > 0) ops.push('/');
  const op = ops[Math.floor(Math.random() * ops.length)];
  const target = op==='+' ? vals.reduce((a,b)=>a+b,0)
               : op==='*' ? vals.reduce((a,b)=>a*b,1)
               : op==='-' ? sub : div;
  return { op, target };
}

function shuffle(arr) {
  for (let i = arr.length-1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i+1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

// ‚îÄ‚îÄ Game state ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let puzzle, solution, userGrid, pencilGrid, selected, pencilMode, timerSec, timerInt, solved, difficulty;

function startGame(puz) {
  puzzle = puz;
  const N = puz.size;
  const result = MathdokuSolver.solve(puz, { maxSolutions: 1 });
  if (!result) { alert('This puzzle has no solution.'); return; }
  solution   = result.grid;
  difficulty = MathdokuSolver.rate(puz).difficulty;
  userGrid   = Array.from({length: N}, () => new Array(N).fill(0));
  pencilGrid = Array.from({length: N}, () => Array.from({length: N}, () => new Set()));
  selected   = null;
  pencilMode = false;
  solved     = false;
  (puz.givens||[]).forEach(g => { userGrid[g.row][g.col] = g.value; });
  clearInterval(timerInt);
  timerSec = 0;
  $('timerDisplay').textContent = '0:00';
  timerInt = setInterval(() => {
    if (solved) return;
    timerSec++;
    $('timerDisplay').textContent = Math.floor(timerSec/60) + ':' + String(timerSec%60).padStart(2,'0');
  }, 1000);
  $('lobby').style.display = 'none';
  $('game').style.display  = 'flex';
  $('difficultyLabel').textContent = difficulty;
  // Update URL so the puzzle is shareable
  const encoded = btoa(JSON.stringify({ size: puz.size, cages: puz.cages, givens: puz.givens || [] }));
  history.replaceState(null, '', '?p=' + encoded);
  renderGrid();
  renderNumpad();
}

function goLobby() {
  clearInterval(timerInt);
  $('winOverlay').classList.remove('open');
  $('game').style.display  = 'none';
  $('lobby').style.display = 'flex';
}

// ‚îÄ‚îÄ Render grid ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function renderGrid() {
  const N  = puzzle.size;
  const el = $('gridEl');
  const maxW  = Math.min(window.innerWidth - 32, 480);
  const cellPx = Math.floor((maxW - N) / N);
  el.style.gridTemplateColumns = 'repeat(' + N + ', ' + cellPx + 'px)';
  el.style.width = (cellPx * N + N - 1) + 'px';
  el.innerHTML = '';

  const cellToCage = Array.from({length:N}, () => new Array(N).fill(-1));
  puzzle.cages.forEach((cage,ci) => cage.cells.forEach(([r,c]) => cellToCage[r][c] = ci));

  for (let r = 0; r < N; r++) {
    for (let c = 0; c < N; c++) {
      const ci      = cellToCage[r][c];
      const isGiven = (puzzle.givens||[]).some(g => g.row===r && g.col===c);
      const val     = userGrid[r][c];
      const isSel   = selected && selected[0]===r && selected[1]===c;
      const isHl    = selected && !isSel && (selected[0]===r || selected[1]===c);

      const div = document.createElement('div');
      let cls = 'cell';
      if (isGiven)                          cls += ' given';
      else if (val && val===solution[r][c]) cls += ' correct';
      else if (val)                         cls += ' error';
      if (isSel) cls += ' selected';
      else if (isHl) cls += ' highlight';
      div.className = cls;

      if (ci !== -1) {
        const cage = puzzle.cages[ci];
        const inCage = (rr,cc) => cage.cells.some(([a,b]) => a===rr && b===cc);
        if (r===0    || !inCage(r-1,c)) div.classList.add('bt');
        if (r===N-1  || !inCage(r+1,c)) div.classList.add('bb');
        if (c===0    || !inCage(r,c-1)) div.classList.add('bl');
        if (c===N-1  || !inCage(r,c+1)) div.classList.add('br');
        const sorted = [...cage.cells].sort((a,b) => (a[0]*N+a[1])-(b[0]*N+b[1]));
        if (sorted[0][0]===r && sorted[0][1]===c) {
          const lbl = document.createElement('span');
          lbl.className = 'cage-label';
          lbl.textContent = cage.target + (cage.op==='=' ? '' : cage.op);
          div.appendChild(lbl);
        }
      }

      if (val) {
        div.append(val);
      } else {
        const marks = pencilGrid[r][c];
        if (marks.size > 0) {
          const cols = Math.ceil(Math.sqrt(N));
          const pg = document.createElement('div');
          pg.className = 'pencil-grid';
          pg.style.gridTemplateColumns = 'repeat(' + cols + ', 1fr)';
          for (let v = 1; v <= N; v++) {
            const pd = document.createElement('div');
            pd.className = 'pencil-digit';
            pd.textContent = marks.has(v) ? v : '';
            pg.appendChild(pd);
          }
          div.appendChild(pg);
        }
      }

      if (!isGiven) div.addEventListener('click', () => { selected = [r,c]; renderGrid(); });
      el.appendChild(div);
    }
  }
}

// ‚îÄ‚îÄ Input ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function inputValue(v) {
  if (!selected || solved) return;
  const [r, c] = selected;
  if ((puzzle.givens||[]).some(g => g.row===r && g.col===c)) return;
  if (pencilMode) {
    if (userGrid[r][c]) return;
    if (pencilGrid[r][c].has(v)) pencilGrid[r][c].delete(v);
    else pencilGrid[r][c].add(v);
  } else {
    userGrid[r][c] = v;
    pencilGrid[r][c].clear();
    for (let i = 0; i < puzzle.size; i++) { pencilGrid[r][i].delete(v); pencilGrid[i][c].delete(v); }
    checkWin();
  }
  renderGrid();
}

function eraseCell() {
  if (!selected || solved) return;
  const [r, c] = selected;
  if ((puzzle.givens||[]).some(g => g.row===r && g.col===c)) return;
  userGrid[r][c] = 0;
  pencilGrid[r][c].clear();
  renderGrid();
}

function checkWin() {
  const N = puzzle.size;
  for (let r = 0; r < N; r++)
    for (let c = 0; c < N; c++)
      if (userGrid[r][c] !== solution[r][c]) return;
  solved = true;
  clearInterval(timerInt);
  const m = Math.floor(timerSec/60), s = timerSec%60;
  $('winTime').textContent = m + ':' + String(s).padStart(2,'0');
  $('winDiff').textContent = difficulty;
  setTimeout(() => $('winOverlay').classList.add('open'), 400);
}

// ‚îÄ‚îÄ Numpad ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function renderNumpad() {
  const N  = puzzle.size;
  const np = $('numpad');
  np.innerHTML = '';
  np.style.gridTemplateColumns = 'repeat(' + (N + 2) + ', 1fr)';
  for (let v = 1; v <= N; v++) {
    const btn = document.createElement('button');
    btn.className = 'np-btn' + (pencilMode ? ' pencil-mode' : '');
    btn.textContent = v;
    btn.onclick = () => inputValue(v);
    np.appendChild(btn);
  }
  const pencilBtn = document.createElement('button');
  pencilBtn.className = 'np-btn np-pencil' + (pencilMode ? ' active' : '');
  pencilBtn.textContent = '‚úèÔ∏è';
  pencilBtn.onclick = () => { pencilMode = !pencilMode; renderNumpad(); };
  np.appendChild(pencilBtn);
  const eraseBtn = document.createElement('button');
  eraseBtn.className = 'np-btn np-erase';
  eraseBtn.textContent = '‚å´';
  eraseBtn.onclick = () => eraseCell();
  np.appendChild(eraseBtn);
}

// ‚îÄ‚îÄ Keyboard ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
document.addEventListener('keydown', e => {
  if ($('game').style.display === 'none') return;
  if (['INPUT','TEXTAREA'].includes(document.activeElement.tagName)) return;
  const N = puzzle?.size || 4;
  const digit = parseInt(e.key);
  if (!isNaN(digit) && digit >= 1 && digit <= N) { inputValue(digit); return; }
  if (e.key==='Backspace'||e.key==='Delete'||e.key==='0') { eraseCell(); return; }
  if (e.key==='p'||e.key==='P') { pencilMode = !pencilMode; renderNumpad(); renderGrid(); return; }
  if (selected) {
    const dirs = { ArrowUp:[-1,0], ArrowDown:[1,0], ArrowLeft:[0,-1], ArrowRight:[0,1] };
    if (dirs[e.key]) {
      e.preventDefault();
      const [dr,dc] = dirs[e.key];
      selected = [Math.max(0,Math.min(N-1,selected[0]+dr)), Math.max(0,Math.min(N-1,selected[1]+dc))];
      renderGrid();
    }
  }
});

window.addEventListener('resize', () => { if (puzzle) renderGrid(); });
</script>
</body>
</html>
