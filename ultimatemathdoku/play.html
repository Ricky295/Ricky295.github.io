<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mathdoku Play</title>
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
  :root {
    --bg: #0e0e10; --surface: #18181b; --surface2: #222226;
    --border: #2e2e34; --accent: #f97316; --accent2: #fb923c;
    --text: #f4f4f5; --muted: #71717a; --danger: #ef4444; --success: #22c55e;
    --blue: #3b82f6;
  }
  body { background: var(--bg); color: var(--text); font-family: 'Segoe UI', system-ui, sans-serif; min-height: 100vh; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 16px; }

  /* ‚îÄ‚îÄ Lobby ‚îÄ‚îÄ */
  #lobby { display: flex; flex-direction: column; align-items: center; gap: 28px; width: 100%; max-width: 420px; }
  #lobby h1 { font-size: 2rem; font-weight: 900; letter-spacing: -0.04em; }
  #lobby h1 span { color: var(--accent); }
  #lobby p { color: var(--muted); font-size: .85rem; text-align: center; }

  .lobby-card { background: var(--surface); border: 1px solid var(--border); border-radius: 20px; padding: 24px; width: 100%; display: flex; flex-direction: column; gap: 16px; }
  .lobby-card h2 { font-size: .7rem; font-weight: 800; text-transform: uppercase; letter-spacing: .1em; color: var(--muted); }

  .option-row { display: flex; flex-direction: column; gap: 6px; }
  .option-row label { font-size: .68rem; font-weight: 700; text-transform: uppercase; letter-spacing: .08em; color: var(--muted); }
  .option-row select, .option-row input {
    background: var(--surface2); border: 1px solid var(--border); color: var(--text);
    padding: 10px 14px; border-radius: 10px; font-size: .9rem; font-weight: 700; outline: none; width: 100%;
  }
  .option-row select:focus, .option-row input:focus { border-color: var(--accent); }

  .seg { display: flex; gap: 4px; }
  .seg-btn { flex: 1; background: var(--surface2); border: 1px solid var(--border); color: var(--muted); padding: 9px 4px; border-radius: 8px; font-size: .78rem; font-weight: 800; cursor: pointer; transition: all .15s; text-align: center; }
  .seg-btn.active { background: var(--accent); border-color: var(--accent); color: #fff; }

  .btn { background: var(--surface2); border: 1px solid var(--border); color: var(--text); padding: 12px 20px; border-radius: 10px; font-size: .88rem; font-weight: 700; cursor: pointer; transition: background .15s, transform .1s; user-select: none; width: 100%; }
  .btn:hover { background: #2e2e36; }
  .btn:active { transform: scale(.97); }
  .btn-accent { background: var(--accent); border-color: var(--accent); color: #fff; }
  .btn-accent:hover { background: var(--accent2); }

  .or-divider { display: flex; align-items: center; gap: 10px; color: var(--muted); font-size: .75rem; font-weight: 700; }
  .or-divider::before, .or-divider::after { content: ''; flex: 1; height: 1px; background: var(--border); }

  /* ‚îÄ‚îÄ Game ‚îÄ‚îÄ */
  #game { display: none; flex-direction: column; align-items: center; gap: 12px; width: 100%; max-width: 540px; }

  .game-topbar { width: 100%; display: flex; justify-content: space-between; align-items: center; }
  .game-topbar .back-btn { background: none; border: none; color: var(--muted); font-size: .8rem; font-weight: 700; cursor: pointer; padding: 4px 0; }
  .game-topbar .back-btn:hover { color: var(--text); }
  #timerDisplay { font-size: 1.1rem; font-weight: 900; letter-spacing: .05em; color: var(--text); font-variant-numeric: tabular-nums; }

  /* puzzle wrapper: grid + difficulty label */
  .puzzle-wrap { position: relative; width: 100%; }
  #gridEl { display: grid; border: 3px solid var(--text); background: var(--border); gap: 1px; touch-action: none; user-select: none; margin: 0 auto; }

  .cell {
    width: 100%; aspect-ratio: 1; background: var(--surface);
    display: flex; align-items: center; justify-content: center;
    font-size: clamp(.9rem, 4vw, 1.5rem); font-weight: 900;
    position: relative; cursor: pointer; transition: background .1s;
    border: 2px solid transparent;
  }
  .cell:hover { background: #1e1e22; }
  .cell.selected { background: #1c2a3a; border-color: var(--blue); z-index: 2; }
  .cell.given { color: var(--accent); cursor: default; }
  .cell.given:hover { background: var(--surface); }
  .cell.filled { color: var(--blue); }
  .cell.error { color: var(--danger) !important; background: #1f1010 !important; }
  .cell.correct { color: var(--success) !important; }
  .cell.highlight { background: #1a2030; }

  .cage-label {
    position: absolute; top: 2px; left: 3px;
    font-size: clamp(.4rem, 1.1vw, .6rem); font-weight: 900;
    color: var(--text); pointer-events: none; line-height: 1;
  }
  .bt { border-top: 3px solid var(--text) !important; }
  .bb { border-bottom: 3px solid var(--text) !important; }
  .bl { border-left: 3px solid var(--text) !important; }
  .br { border-right: 3px solid var(--text) !important; }

  /* pencil marks grid inside cell */
  .pencil-grid {
    display: grid; width: 90%; height: 90%;
    position: absolute; inset: 5%;
  }
  .pencil-digit {
    display: flex; align-items: center; justify-content: center;
    font-size: clamp(.3rem, .9vw, .5rem); font-weight: 700;
    color: var(--muted); line-height: 1;
  }

  #difficultyLabel {
    text-align: center; font-size: .7rem; font-weight: 800;
    text-transform: uppercase; letter-spacing: .12em;
    color: var(--muted); margin-top: 6px;
  }

  /* numpad */
  #numpad { display: grid; gap: 6px; width: 100%; }
  .np-btn {
    background: var(--surface); border: 1px solid var(--border); color: var(--text);
    aspect-ratio: 1; border-radius: 10px; font-size: clamp(1rem, 4vw, 1.4rem);
    font-weight: 900; cursor: pointer; transition: background .1s, transform .1s;
    display: flex; align-items: center; justify-content: center;
  }
  .np-btn:hover { background: var(--surface2); }
  .np-btn:active { transform: scale(.93); }
  .np-btn.pencil-mode { border-color: var(--blue); color: var(--blue); }
  .np-erase { background: var(--surface2); color: var(--muted); font-size: clamp(.7rem, 2.5vw, 1rem); }
  .np-pencil { background: var(--surface2); font-size: clamp(.65rem, 2vw, .85rem); }
  .np-pencil.active { background: #1c2a3a; border-color: var(--blue); color: var(--blue); }

  /* win overlay */
  #winOverlay { display: none; position: fixed; inset: 0; background: rgba(0,0,0,.8); backdrop-filter: blur(8px); z-index: 200; align-items: center; justify-content: center; }
  #winOverlay.open { display: flex; }
  .win-box { background: var(--surface); border: 1px solid var(--border); border-radius: 24px; padding: 40px 32px; text-align: center; max-width: 340px; margin: 16px; }
  .win-box .emoji { font-size: 3rem; margin-bottom: 12px; }
  .win-box h2 { font-size: 1.6rem; font-weight: 900; margin-bottom: 6px; }
  .win-box p { color: var(--muted); font-size: .85rem; margin-bottom: 20px; }
  .win-stats { display: flex; justify-content: center; gap: 24px; margin-bottom: 24px; }
  .win-stat { display: flex; flex-direction: column; align-items: center; gap: 2px; }
  .win-stat .val { font-size: 1.2rem; font-weight: 900; color: var(--accent); }
  .win-stat .lbl { font-size: .65rem; font-weight: 700; text-transform: uppercase; color: var(--muted); }

  .spinner { width: 20px; height: 20px; border: 2px solid var(--border); border-top-color: var(--accent); border-radius: 50%; animation: spin .7s linear infinite; flex-shrink: 0; }
  @keyframes spin { to { transform: rotate(360deg); } }
  #genOverlay p { font-size: .85rem; font-weight: 700; color: var(--muted); }
</style>
</head>
<body>

<!-- ‚îÄ‚îÄ Lobby ‚îÄ‚îÄ -->
<div id="lobby">
  <div style="text-align:center;">
    <h1>MATHDOKU<span>.PLAY</span></h1>
    <p style="margin-top:6px;">Train your mind.</p>
  </div>

  <div class="lobby-card">
    <h2>New Puzzle</h2>

    <div class="option-row">
      <label>Grid Size</label>
      <div class="seg" id="sizeSegs">
        <div class="seg-btn active" data-val="4">4√ó4</div>
        <div class="seg-btn" data-val="5">5√ó5</div>
        <div class="seg-btn" data-val="6">6√ó6</div>
        <div class="seg-btn" data-val="7">7√ó7</div>
        <div class="seg-btn" data-val="8">8√ó8</div>
        <div class="seg-btn" data-val="9">9√ó9</div>
      </div>
    </div>

    <div class="option-row">
      <label>Difficulty</label>
      <div class="seg" id="diffSegs">
        <div class="seg-btn active" data-val="any">Any</div>
        <div class="seg-btn" data-val="Easy">Easy</div>
        <div class="seg-btn" data-val="Medium">Med</div>
        <div class="seg-btn" data-val="Hard">Hard</div>
        <div class="seg-btn" data-val="Vicious">Vic</div>
        <div class="seg-btn" data-val="Devilish">Dev</div>
        <div class="seg-btn" data-val="Diabolical">Dia</div>
        <div class="seg-btn" data-val="Beyond Diabolical">BD</div>
      </div>
    </div>

    <div class="option-row">
      <label>Uniqueness</label>
      <div class="seg" id="uniqSegs">
        <div class="seg-btn active" data-val="guaranteed">Guaranteed</div>
        <div class="seg-btn" data-val="any">Allow non-unique</div>
        <div class="seg-btn" data-val="only">Only non-unique</div>
      </div>
    </div>

    <button class="btn btn-accent" id="genBtn" onclick="generatePuzzle()">‚ñ∂ Generate Puzzle</button>

    <div id="genInline" style="display:none; flex-direction:column; gap:10px;">
      <div style="display:flex; align-items:center; gap:10px;">
        <div class="spinner"></div>
        <span style="font-size:.85rem; font-weight:800; color:var(--muted); text-transform:uppercase; letter-spacing:.08em;">Generating‚Ä¶</span>
      </div>
      <div style="display:flex; justify-content:space-between; align-items:center; font-size:.78rem; font-weight:700; color:var(--muted);">
        <span>Attempts: <span id="genAttempts" style="color:var(--text);">0</span></span>
        <span>Best so far: <span id="genBestLabel" style="color:var(--accent);">‚Äî</span></span>
      </div>
      <button class="btn" id="genAcceptBtn" style="display:none;" onclick="acceptBest()">Accept Best</button>
      <button class="btn btn-danger" onclick="stopGeneration()">‚úï Cancel</button>
    </div>
  </div>

  <div class="or-divider">or</div>

  <div class="lobby-card">
    <h2>Load from String</h2>
    <div class="option-row">
      <label>Puzzle String</label>
      <input id="importStr" type="text" placeholder="Paste export string‚Ä¶">
    </div>
    <button class="btn" onclick="loadFromString()">Load Puzzle</button>
  </div>
</div>

<!-- ‚îÄ‚îÄ Game ‚îÄ‚îÄ -->
<div id="game">
  <div class="game-topbar" style="max-width:540px;width:100%;">
    <button class="back-btn" onclick="goLobby()">‚Üê Back</button>
    <div id="timerDisplay">0:00</div>
  </div>

  <div class="puzzle-wrap">
    <div id="gridEl"></div>
    <div id="difficultyLabel">‚Äî</div>
  </div>

  <div id="numpad"></div>
</div>

<!-- Win overlay -->
<div id="winOverlay">
  <div class="win-box">
    <div class="emoji">üéâ</div>
    <h2>Solved!</h2>
    <p id="winDiff"></p>
    <div class="win-stats">
      <div class="win-stat"><div class="val" id="winTime">‚Äî</div><div class="lbl">Time</div></div>
    </div>
    <button class="btn btn-accent" onclick="goLobby()">Play Again</button>
  </div>
</div>



<script src="solver.js"></script>
<script>
// ‚îÄ‚îÄ State ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let puzzle = null;       // { size, cages, givens }
let solution = null;     // 2D array [r][c] = value
let userGrid = [];       // 2D array, 0 = empty
let pencilGrid = [];     // 2D array of Set
let selected = null;     // [r,c] or null
let pencilMode = false;
let timerSec = 0;
let timerInt = null;
let solved = false;
let difficulty = '‚Äî';

const $ = id => document.getElementById(id);

// ‚îÄ‚îÄ Segment controls ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function segVal(id) {
  return $( id).querySelector('.active')?.dataset.val;
}
document.querySelectorAll('.seg').forEach(seg => {
  seg.addEventListener('click', e => {
    const btn = e.target.closest('.seg-btn');
    if (!btn) return;
    seg.querySelectorAll('.seg-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
  });
});

// ‚îÄ‚îÄ URL puzzle load ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
window.addEventListener('DOMContentLoaded', () => {
  const params = new URLSearchParams(location.search);
  const p = params.get('p');
  if (p) {
    try {
      const data = JSON.parse(atob(p));
      startGame(data);
      return;
    } catch(e) { /* fall through to lobby */ }
  }
});

// ‚îÄ‚îÄ Lobby actions ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function loadFromString() {
  const str = $('importStr').value.trim();
  if (!str) return;
  try {
    const data = JSON.parse(atob(str));
    startGame(data);
  } catch(e) { alert('Invalid puzzle string.'); }
}

let genRunning = false;
let genBestPuzzle = null;
let genBestScore = null;
let genBestDiff = null;

async function generatePuzzle() {
  const size   = parseInt(segVal('sizeSegs'));
  const diff   = segVal('diffSegs');
  const uniq   = segVal('uniqSegs');

  genRunning   = true;
  genBestPuzzle = null;
  genBestScore  = null;
  genBestDiff   = null;

  $('genBestWrap').style.display = 'none';
  $('genBestLabel').textContent = 'Best so far: ‚Äî';
  $('genOverlay').classList.add('open');
  $('genStatus').textContent = 'Generating‚Ä¶';
  await sleep(30);

  let attempt = 0;
  while (genRunning) {
    attempt++;
    if (attempt % 5 === 0) {
      $('genStatus').textContent = 'Attempt ' + attempt + '‚Ä¶';
      await sleep(0);
    }

    const puz = randomPuzzle(size);
    const rating = MathdokuSolver.rate(puz);
    const isUnique = !rating.difficulty.startsWith('Non-unique');
    const diffLabel = isUnique ? rating.difficulty : rating.difficulty.replace(/^Non-unique \(/, '').replace(/\)$/, '');

    // Always update best so far so the accept button is always available
    updateBest(puz, rating, diffLabel);

    // Check uniqueness filter
    if (uniq === 'guaranteed' && !isUnique) continue;
    if (uniq === 'only' && isUnique) continue;

    // Check difficulty filter
    if (diff !== 'any' && diffLabel !== diff) continue;

    // Perfect match ‚Äî accept immediately
    genRunning = false;
    $('genOverlay').classList.remove('open');
    startGame(puz);
    return;
  }

  // Stopped by user (acceptBest)
}

function updateBest(puz, rating, diffLabel) {
  // Always keep track of the best puzzle found so far (closest match by score proximity)
  if (!genBestPuzzle) {
    genBestPuzzle = puz;
    genBestScore  = rating.score;
    genBestDiff   = rating.difficulty;
  } else {
    // Prefer puzzles with a valid solution; otherwise just keep latest
    genBestPuzzle = puz;
    genBestScore  = rating.score;
    genBestDiff   = rating.difficulty;
  }
  $('genBestWrap').style.display = 'flex';
  $('genBestLabel').textContent = 'Best so far: ' + genBestDiff + ' (score ' + genBestScore + ')';
}

function acceptBest() {
  if (!genBestPuzzle) return;
  genRunning = false;
  $('genOverlay').classList.remove('open');
  startGame(genBestPuzzle);
}



function randomPuzzle(size) {
  // 1. Generate a random valid latin square
  const grid = randomLatinSquare(size);

  // 2. Carve random cages covering all cells
  const cages = carveCages(grid, size);

  return { size, cages, givens: [] };
}

function randomLatinSquare(size) {
  // Shuffle-based backtracking
  const grid = Array.from({length: size}, () => new Array(size).fill(0));
  function bt(pos) {
    if (pos === size * size) return true;
    const r = Math.floor(pos / size), c = pos % size;
    const nums = shuffle(Array.from({length: size}, (_,i) => i+1));
    for (const v of nums) {
      let ok = true;
      for (let i = 0; i < c; i++) if (grid[r][i] === v) { ok = false; break; }
      if (ok) for (let i = 0; i < r; i++) if (grid[i][c] === v) { ok = false; break; }
      if (!ok) continue;
      grid[r][c] = v;
      if (bt(pos+1)) return true;
      grid[r][c] = 0;
    }
    return false;
  }
  bt(0);
  return grid;
}

function carveCages(grid, size) {
  const assigned = Array.from({length: size}, () => new Array(size).fill(false));
  const cages = [];
  const cells = shuffle(Array.from({length: size*size}, (_,i) => i));

  for (const flat of cells) {
    const r = Math.floor(flat / size), c = flat % size;
    if (assigned[r][c]) continue;

    // Grow a cage of 1‚Äì4 cells using flood-fill-like expansion
    const maxSize = Math.min(4, size);
    const cageCells = [[r, c]];
    assigned[r][c] = true;

    const tries = 1 + Math.floor(Math.random() * (maxSize - 1));
    for (let t = 0; t < tries; t++) {
      const candidates = [];
      for (const [cr, cc] of cageCells) {
        for (const [dr, dc] of [[-1,0],[1,0],[0,-1],[0,1]]) {
          const nr = cr+dr, nc = cc+dc;
          if (nr>=0 && nr<size && nc>=0 && nc<size && !assigned[nr][nc])
            candidates.push([nr, nc]);
        }
      }
      if (!candidates.length) break;
      const [nr, nc] = candidates[Math.floor(Math.random() * candidates.length)];
      cageCells.push([nr, nc]);
      assigned[nr][nc] = true;
    }

    // Pick operation
    const vals = cageCells.map(([cr,cc]) => grid[cr][cc]);
    const { op, target } = chooseOp(vals, size);
    cages.push({ id: Date.now() + cages.length, cells: cageCells, op, target });
  }
  return cages;
}

function chooseOp(vals, size) {
  if (vals.length === 1) return { op: '=', target: vals[0] };
  const ops = ['+', '*'];
  // allow - and / only if result is positive/integer
  const sorted = [...vals].sort((a,b) => b-a);
  const subResult = sorted.slice(1).reduce((acc,v) => acc-v, sorted[0]);
  if (subResult > 0) ops.push('-');
  const divResult = sorted.slice(1).reduce((acc,v) => acc/v, sorted[0]);
  if (Number.isInteger(divResult) && divResult > 0) ops.push('/');

  const op = ops[Math.floor(Math.random() * ops.length)];
  let target;
  switch(op) {
    case '+': target = vals.reduce((a,b) => a+b, 0); break;
    case '*': target = vals.reduce((a,b) => a*b, 1); break;
    case '-': target = subResult; break;
    case '/': target = divResult; break;
  }
  return { op, target };
}

function shuffle(arr) {
  for (let i = arr.length-1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i+1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

// ‚îÄ‚îÄ Start game ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function startGame(puz) {
  puzzle = puz;
  const N = puz.size;

  // Solve to get solution
  const result = MathdokuSolver.solve(puz, { maxSolutions: 1 });
  if (!result) { alert('This puzzle has no solution.'); return; }
  solution = result.grid;

  // Rate
  const rating = MathdokuSolver.rate(puz);
  difficulty = rating.difficulty;

  // Init user state
  userGrid  = Array.from({length: N}, () => new Array(N).fill(0));
  pencilGrid = Array.from({length: N}, () => Array.from({length: N}, () => new Set()));
  selected   = null;
  pencilMode = false;
  solved     = false;

  // Pre-fill givens
  (puz.givens || []).forEach(g => { userGrid[g.row][g.col] = g.value; });

  // Timer
  clearInterval(timerInt);
  timerSec = 0;
  $('timerDisplay').textContent = '0:00';
  timerInt = setInterval(() => {
    if (solved) return;
    timerSec++;
    const m = Math.floor(timerSec/60), s = timerSec%60;
    $('timerDisplay').textContent = m + ':' + String(s).padStart(2,'0');
  }, 1000);

  $('lobby').style.display = 'none';
  $('game').style.display  = 'flex';
  $('difficultyLabel').textContent = difficulty;

  renderGrid();
  renderNumpad();
}

function goLobby() {
  clearInterval(timerInt);
  $('winOverlay').classList.remove('open');
  $('game').style.display  = 'none';
  $('lobby').style.display = 'flex';
}

// ‚îÄ‚îÄ Render grid ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function renderGrid() {
  const N = puzzle.size;
  const el = $('gridEl');
  const maxW = Math.min(window.innerWidth - 32, 480);
  const cellPx = Math.floor((maxW - N) / N);
  el.style.gridTemplateColumns = 'repeat(' + N + ', ' + cellPx + 'px)';
  el.style.width = (cellPx * N + N - 1) + 'px';
  el.innerHTML = '';

  // Build cage lookup
  const cellToCage = Array.from({length:N}, () => new Array(N).fill(-1));
  puzzle.cages.forEach((cage,ci) => cage.cells.forEach(([r,c]) => cellToCage[r][c] = ci));

  for (let r = 0; r < N; r++) {
    for (let c = 0; c < N; c++) {
      const ci = cellToCage[r][c];
      const isGiven = (puzzle.givens||[]).some(g => g.row===r && g.col===c);
      const val = userGrid[r][c];
      const isSel = selected && selected[0]===r && selected[1]===c;
      const isHighlight = selected && !isSel && (selected[0]===r || selected[1]===c);

      const div = document.createElement('div');
      let cls = 'cell';
      if (isGiven) cls += ' given';
      else if (val && val === solution[r][c]) cls += ' correct';
      else if (val && val !== solution[r][c]) cls += ' error';
      else if (val) cls += ' filled';
      if (isSel) cls += ' selected';
      else if (isHighlight) cls += ' highlight';
      div.className = cls;

      // Cage borders
      if (ci !== -1) {
        const cage = puzzle.cages[ci];
        const inCage = (rr,cc) => cage.cells.some(([a,b]) => a===rr && b===cc);
        if (r===0 || !inCage(r-1,c)) div.classList.add('bt');
        if (r===N-1 || !inCage(r+1,c)) div.classList.add('bb');
        if (c===0 || !inCage(r,c-1)) div.classList.add('bl');
        if (c===N-1 || !inCage(r,c+1)) div.classList.add('br');

        const sorted = [...cage.cells].sort((a,b) => (a[0]*N+a[1])-(b[0]*N+b[1]));
        if (sorted[0][0]===r && sorted[0][1]===c) {
          const lbl = document.createElement('span');
          lbl.className = 'cage-label';
          lbl.textContent = cage.target + (cage.op === '=' ? '' : cage.op);
          div.appendChild(lbl);
        }
      }

      // Value or pencil marks
      if (val) {
        div.append(val);
      } else {
        const marks = pencilGrid[r][c];
        if (marks.size > 0) {
          const cols = Math.ceil(Math.sqrt(N));
          const pg = document.createElement('div');
          pg.className = 'pencil-grid';
          pg.style.gridTemplateColumns = 'repeat(' + cols + ', 1fr)';
          for (let v = 1; v <= N; v++) {
            const pd = document.createElement('div');
            pd.className = 'pencil-digit';
            pd.textContent = marks.has(v) ? v : '';
            pg.appendChild(pd);
          }
          div.appendChild(pg);
        }
      }

      if (!isGiven) {
        div.addEventListener('click', () => selectCell(r, c));
      }
      el.appendChild(div);
    }
  }
}

function selectCell(r, c) {
  selected = [r, c];
  renderGrid();
}

// ‚îÄ‚îÄ Input ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function inputValue(v) {
  if (!selected || solved) return;
  const [r, c] = selected;
  const isGiven = (puzzle.givens||[]).some(g => g.row===r && g.col===c);
  if (isGiven) return;

  if (pencilMode) {
    if (userGrid[r][c]) return; // can't pencil on a filled cell
    if (pencilGrid[r][c].has(v)) pencilGrid[r][c].delete(v);
    else pencilGrid[r][c].add(v);
  } else {
    userGrid[r][c] = v;
    pencilGrid[r][c].clear();
    // Auto-remove pencil marks in same row/col
    for (let i = 0; i < puzzle.size; i++) {
      pencilGrid[r][i].delete(v);
      pencilGrid[i][c].delete(v);
    }
    checkWin();
  }
  renderGrid();
}

function eraseCell() {
  if (!selected || solved) return;
  const [r, c] = selected;
  const isGiven = (puzzle.givens||[]).some(g => g.row===r && g.col===c);
  if (isGiven) return;
  userGrid[r][c] = 0;
  pencilGrid[r][c].clear();
  renderGrid();
}

function checkWin() {
  const N = puzzle.size;
  for (let r = 0; r < N; r++)
    for (let c = 0; c < N; c++)
      if (userGrid[r][c] !== solution[r][c]) return;
  // All correct!
  solved = true;
  clearInterval(timerInt);
  const m = Math.floor(timerSec/60), s = timerSec%60;
  $('winTime').textContent = m + ':' + String(s).padStart(2,'0');
  $('winDiff').textContent = difficulty;
  setTimeout(() => $('winOverlay').classList.add('open'), 400);
}

// ‚îÄ‚îÄ Numpad ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function renderNumpad() {
  const N = puzzle.size;
  const np = $('numpad');
  np.innerHTML = '';
  // cols: N digits + erase + pencil
  const cols = Math.min(N + 2, 11);
  np.style.gridTemplateColumns = 'repeat(' + cols + ', 1fr)';

  for (let v = 1; v <= N; v++) {
    const btn = document.createElement('button');
    btn.className = 'np-btn' + (pencilMode ? ' pencil-mode' : '');
    btn.textContent = v;
    btn.onclick = () => inputValue(v);
    np.appendChild(btn);
  }

  // Pencil toggle
  const pencilBtn = document.createElement('button');
  pencilBtn.className = 'np-btn np-pencil' + (pencilMode ? ' active' : '');
  pencilBtn.textContent = '‚úèÔ∏è';
  pencilBtn.title = 'Pencil mode';
  pencilBtn.onclick = () => { pencilMode = !pencilMode; renderNumpad(); renderGrid(); };
  np.appendChild(pencilBtn);

  // Erase
  const eraseBtn = document.createElement('button');
  eraseBtn.className = 'np-btn np-erase';
  eraseBtn.textContent = '‚å´';
  eraseBtn.title = 'Erase';
  eraseBtn.onclick = () => eraseCell();
  np.appendChild(eraseBtn);
}

// ‚îÄ‚îÄ Keyboard ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
document.addEventListener('keydown', e => {
  if ($('game').style.display === 'none') return;
  if (['INPUT','TEXTAREA'].includes(document.activeElement.tagName)) return;

  const N = puzzle?.size || 4;
  const digit = parseInt(e.key);

  if (!isNaN(digit) && digit >= 1 && digit <= N) {
    inputValue(digit);
  } else if (e.key === 'Backspace' || e.key === 'Delete' || e.key === '0') {
    eraseCell();
  } else if (e.key === 'p' || e.key === 'P') {
    pencilMode = !pencilMode; renderNumpad(); renderGrid();
  } else if (selected) {
    const [r, c] = selected;
    const dirs = { ArrowUp:[-1,0], ArrowDown:[1,0], ArrowLeft:[0,-1], ArrowRight:[0,1] };
    if (dirs[e.key]) {
      e.preventDefault();
      const [dr,dc] = dirs[e.key];
      const nr = Math.max(0, Math.min(N-1, r+dr));
      const nc = Math.max(0, Math.min(N-1, c+dc));
      selected = [nr, nc]; renderGrid();
    }
  }
});

window.addEventListener('resize', () => { if (puzzle) renderGrid(); });
</script>
</body>
</html>
