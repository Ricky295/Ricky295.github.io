<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PROGRAMDOKU</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #1a1a1a;
            color: #e0e0e0;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .container {
            background: #2d2d2d;
            border: 2px solid #555;
            padding: 30px;
            max-width: 600px;
            width: 100%;
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
            color: #e0e0e0;
            font-size: 24px;
            letter-spacing: 2px;
        }

        .share-container {
            background: #252525;
            border: 1px solid #444;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 4px;
            display: none;
        }

        .share-container.active {
            display: block;
        }

        .share-url {
            background: #1a1a1a;
            border: 1px solid #0f0;
            color: #0f0;
            padding: 12px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            word-break: break-all;
            margin-bottom: 10px;
            border-radius: 4px;
        }

        .share-container button {
            margin-top: 0;
            padding: 8px;
            font-size: 12px;
        }

        .share-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: #b0b0b0;
            font-weight: bold;
            font-size: 13px;
        }

        input[type="number"],
        input[type="datetime-local"],
        input[type="range"] {
            width: 100%;
            padding: 10px;
            border: 1px solid #444;
            background: #1a1a1a;
            color: #e0e0e0;
            font-family: inherit;
            font-size: 14px;
        }

        input[type="number"]:focus,
        input[type="datetime-local"]:focus {
            outline: none;
            border-color: #0f0;
            box-shadow: 0 0 5px rgba(0, 255, 0, 0.3);
        }

        input[type="range"] {
            padding: 0;
            height: 6px;
        }

        .range-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .value-display {
            display: inline-block;
            margin-left: 10px;
            color: #0f0;
            font-weight: bold;
        }

        button {
            width: 100%;
            padding: 12px;
            background: #333;
            color: #0f0;
            border: 1px solid #0f0;
            font-family: inherit;
            font-size: 13px;
            font-weight: bold;
            cursor: pointer;
            letter-spacing: 1px;
            margin-top: 20px;
            transition: all 0.2s;
        }

        button:hover {
            background: #0f0;
            color: #1a1a1a;
        }

        button:active {
            opacity: 0.8;
        }

        .game-container {
            display: none;
        }

        .game-container.active {
            display: block;
        }

        .timer {
            text-align: center;
            font-size: 28px;
            font-weight: bold;
            color: #0f0;
            margin-bottom: 20px;
            letter-spacing: 2px;
            font-family: 'Courier New', monospace;
        }

        .sudoku-board {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            gap: 0;
            background: #111;
            padding: 8px;
            margin-bottom: 20px;
            width: 100%;
            aspect-ratio: 1;
            max-width: 100%;
            border: 3px solid #444;
        }

        .sudoku-cell {
            background: #1a1a1a;
            border: 1px solid #333;
            padding: 0;
            aspect-ratio: 1;
            font-size: clamp(14px, 4vw, 24px);
            font-weight: bold;
            text-align: center;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
            color: #0f0;
            font-family: 'Courier New', monospace;
        }

        .sudoku-cell:nth-child(3n)::after {
            content: '';
            position: absolute;
            right: -1px;
            top: 0;
            width: 2px;
            height: 100%;
            background: #444;
        }

        .sudoku-cell:nth-child(n+19):nth-child(-n+27)::before,
        .sudoku-cell:nth-child(n+55):nth-child(-n+63)::before {
            content: '';
            position: absolute;
            bottom: -1px;
            left: 0;
            width: 100%;
            height: 2px;
            background: #444;
        }

        .sudoku-cell.given {
            background: #252525;
            cursor: not-allowed;
            color: #e0e0e0;
        }

        .sudoku-cell.selected {
            background: #333;
            border-color: #0f0;
            box-shadow: inset 0 0 10px rgba(0, 255, 0, 0.2);
        }

        .sudoku-cell.highlighted {
            background: #2a2a2a;
        }

        .sudoku-cell.error {
            color: #ff4444;
        }

        .sudoku-cell.selected.error {
            border-color: #ff4444;
            box-shadow: inset 0 0 10px rgba(255, 68, 68, 0.2);
        }

        .candidates {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0;
            font-size: 50%;
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .candidate {
            display: flex;
            align-items: center;
            justify-content: center;
            color: #555;
            font-weight: normal;
        }

        .candidate.hidden {
            display: none;
        }

        .stats {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 10px;
            margin-bottom: 20px;
        }

        .stat-box {
            background: #252525;
            padding: 12px;
            border: 1px solid #444;
            text-align: center;
        }

        .stat-label {
            font-size: 11px;
            color: #888;
            text-transform: uppercase;
            margin-bottom: 5px;
            letter-spacing: 1px;
        }

        .stat-value {
            font-size: 22px;
            font-weight: bold;
            color: #0f0;
        }

        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .controls button {
            margin-top: 0;
            padding: 10px;
            font-size: 12px;
        }

        .waiting-container {
            text-align: center;
            display: none;
        }

        .waiting-container.active {
            display: block;
        }

        .countdown {
            font-size: 48px;
            font-weight: bold;
            color: #0f0;
            margin: 30px 0;
            font-family: 'Courier New', monospace;
            letter-spacing: 2px;
        }

        @media (max-width: 600px) {
            .container {
                padding: 20px;
            }

            .sudoku-cell {
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="setupForm">
            <h1>PROGRAMDOKU</h1>
            
            <div class="form-group">
                <label for="minDiff">MIN DIFFICULTY</label>
                <input type="range" id="minDiff" min="0" max="100" value="30" step="5">
                <span class="value-display" id="minDiffValue">0.30</span>
            </div>

            <div class="form-group">
                <label for="maxDiff">MAX DIFFICULTY</label>
                <input type="range" id="maxDiff" min="0" max="100" value="70" step="5">
                <span class="value-display" id="maxDiffValue">0.70</span>
            </div>

            <div class="range-container">
                <div class="form-group">
                    <label for="targetClues">TARGET CLUES</label>
                    <input type="number" id="targetClues" min="17" max="81" value="25">
                </div>
                <div class="form-group">
                    <label for="maxAttempts">MAX ATTEMPTS</label>
                    <input type="number" id="maxAttempts" min="1" max="1000" value="100">
                </div>
            </div>

            <div class="form-group">
                <label for="startTime">START TIME</label>
                <input type="datetime-local" id="startTime">
            </div>

            <button onclick="generatePuzzle()">GENERATE</button>

            <div id="shareContainer" class="share-container">
                <label>SHARE LINK</label>
                <div class="share-url" id="shareUrl"></div>
                <div class="share-buttons">
                    <button onclick="copyShareLink()">COPY</button>
                    <button onclick="startFromLink()">START</button>
                </div>
            </div>
        </div>

        <div id="waitingContainer" class="waiting-container">
            <h1>WAITING</h1>
            <div class="countdown" id="countdown">00:00:00</div>
        </div>

        <div id="gameContainer" class="game-container">
            <div class="timer" id="timer">00:00:00</div>
            
            <div class="stats">
                <div class="stat-box">
                    <div class="stat-label">MISTAKES</div>
                    <div class="stat-value" id="mistakes">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">LEFT</div>
                    <div class="stat-value" id="remaining">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">DONE</div>
                    <div class="stat-value" id="completed">0%</div>
                </div>
            </div>

            <div class="sudoku-board" id="sudokuBoard"></div>

            <div class="controls">
                <button onclick="clearSelection()">CLEAR</button>
                <button onclick="toggleCandidates()">CANDIDATES</button>
                <button onclick="resetGame()">RESET</button>
                <button onclick="resetToSetup()">SETUP</button>
            </div>
        </div>
    </div>

    <script>
        // Check if loaded from URL params
        const urlParams = new URLSearchParams(window.location.search);
        const puzzleParam = urlParams.get('p');
        const timeParam = urlParams.get('t');

        // Inline newsudoku.js functions
        function convertToMatrix(sudokuString) {
            if (sudokuString.length !== 81) throw new Error("Sudoku string must be exactly 81 characters long.");
            const matrix = [];
            for (let i = 0; i < 9; i++) {
                const rowStart = i * 9;
                const rowEnd = (i + 1) * 9;
                const rowString = sudokuString.substring(rowStart, rowEnd);
                const row = Array.from(rowString, char => parseInt(char));
                matrix.push(row);
            }
            return matrix;
        }

        function range1To9() { return [1, 2, 3, 4, 5, 6, 7, 8, 9]; }
        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function deepCopyBoard(board) { return board.map(row => [...row]); }
        function convertToString(array) { return array.flat().join(''); }

        function getPossibleValues(board, row, col) {
            if (board[row][col] !== 0) return [];
            const used = new Set();
            for (let c = 0; c < 9; c++) used.add(board[row][c]);
            for (let r = 0; r < 9; r++) used.add(board[r][col]);
            const startRow = Math.floor(row / 3) * 3;
            const startCol = Math.floor(col / 3) * 3;
            for (let r = startRow; r < startRow + 3; r++) {
                for (let c = startCol; c < startCol + 3; c++) {
                    used.add(board[r][c]);
                }
            }
            const possible = [];
            for (let num = 1; num <= 9; num++) {
                if (!used.has(num)) possible.push(num);
            }
            return possible;
        }

        function solveGridRandomBacktracking(grid) {
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    if (grid[r][c] === 0) {
                        const possibleNums = range1To9();
                        shuffle(possibleNums);
                        for (const num of possibleNums) {
                            let isValid = true;
                            if (grid[r].includes(num)) isValid = false;
                            if (isValid) {
                                for (let i = 0; i < 9; i++) {
                                    if (grid[i][c] === num) {
                                        isValid = false;
                                        break;
                                    }
                                }
                            }
                            if (isValid) {
                                const startRow = Math.floor(r / 3) * 3;
                                const startCol = Math.floor(c / 3) * 3;
                                for (let rowBox = startRow; rowBox < startRow + 3; rowBox++) {
                                    for (let colBox = startCol; colBox < startCol + 3; colBox++) {
                                        if (grid[rowBox][colBox] === num) {
                                            isValid = false;
                                            break;
                                        }
                                    }
                                    if (!isValid) break;
                                }
                            }
                            if (isValid) {
                                grid[r][c] = num;
                                if (solveGridRandomBacktracking(grid)) return true;
                                grid[r][c] = 0;
                            }
                        }
                        return false;
                    }
                }
            }
            return true;
        }

        function generateSolutionRandom() {
            const solution = Array(9).fill(null).map(() => Array(9).fill(0));
            solveGridRandomBacktracking(solution);
            return solution;
        }

        function eliminatePossibilities(possibilities, rPlaced, cPlaced, valPlaced, puzzle) {
            let contradiction = false;
            for (let i = 0; i < 9; i++) {
                if (possibilities[rPlaced][i].has(valPlaced)) {
                    possibilities[rPlaced][i].delete(valPlaced);
                    if (possibilities[rPlaced][i].size === 0 && puzzle[rPlaced][i] === 0) {
                        contradiction = true;
                    }
                }
                if (possibilities[i][cPlaced].has(valPlaced)) {
                    possibilities[i][cPlaced].delete(valPlaced);
                    if (possibilities[i][cPlaced].size === 0 && puzzle[i][cPlaced] === 0) {
                        contradiction = true;
                    }
                }
            }
            const startRow = Math.floor(rPlaced / 3) * 3;
            const startCol = Math.floor(cPlaced / 3) * 3;
            for (let r = startRow; r < startRow + 3; r++) {
                for (let c = startCol; c < startCol + 3; c++) {
                    if (possibilities[r][c].has(valPlaced)) {
                        possibilities[r][c].delete(valPlaced);
                        if (possibilities[r][c].size === 0 && puzzle[r][c] === 0) {
                            contradiction = true;
                        }
                    }
                }
            }
            return contradiction;
        }

        function solveWithSingles(sudoku, returnDifficulty = false) {
            const puzzle = deepCopyBoard(sudoku);
            const initialEmptyCells = puzzle.flat().filter(x => x === 0).length;
            if (initialEmptyCells === 0) return returnDifficulty ? 0.0 : puzzle;
            
            const possibilities = Array(9).fill(null).map(() => Array(9).fill(null).map(() => new Set()));
            let emptyCellsCount = 0;
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    if (puzzle[r][c] === 0) {
                        possibilities[r][c] = new Set(getPossibleValues(puzzle, r, c));
                        if (possibilities[r][c].size === 0) return returnDifficulty ? -0.2 : sudoku;
                        emptyCellsCount++;
                    } else {
                        possibilities[r][c] = new Set();
                    }
                }
            }
            return returnDifficulty ? -0.1 : puzzle;
        }

        function generateSudoku(minDifficulty, maxDifficulty, targetClues = 25, maxAttempts = 100) {
            for (let attempt = 0; attempt < maxAttempts; attempt++) {
                const solution = generateSolutionRandom();
                const puzzle = deepCopyBoard(solution);
                const positions = [];
                for (let r = 0; r < 9; r++) {
                    for (let c = 0; c < 9; c++) {
                        positions.push([r, c]);
                    }
                }
                shuffle(positions);
                
                let removed = 0;
                for (const [r, c] of positions) {
                    if (81 - removed <= targetClues) break;
                    
                    const originalValue = puzzle[r][c];
                    puzzle[r][c] = 0;
                    
                    const difficulty = solveWithSingles(puzzle, true);
                    
                    if (difficulty < 0) {
                        puzzle[r][c] = originalValue;
                    } else {
                        removed++;
                        if (81 - removed <= targetClues && difficulty >= minDifficulty && difficulty <= maxDifficulty) {
                            return puzzle;
                        }
                    }
                }
                
                const finalDifficulty = solveWithSingles(puzzle, true);
                if (finalDifficulty >= minDifficulty && finalDifficulty <= maxDifficulty && 81 - removed >= targetClues && 81 - removed <= targetClues + 5) {
                    return puzzle;
                }
            }
            
            // Fallback: just create a valid puzzle with target clues
            const solution = generateSolutionRandom();
            const puzzle = deepCopyBoard(solution);
            const positions = [];
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    positions.push([r, c]);
                }
            }
            shuffle(positions);
            
            let removed = 0;
            for (const [r, c] of positions) {
                if (81 - removed <= targetClues) break;
                
                const originalValue = puzzle[r][c];
                puzzle[r][c] = 0;
                
                const difficulty = solveWithSingles(puzzle, true);
                if (difficulty < 0) {
                    puzzle[r][c] = originalValue;
                } else {
                    removed++;
                }
            }
            
            return puzzle;
        }

        // Game State
        let gameState = {
            puzzle: null,
            solution: null,
            current: null,
            initial: null,
            selected: null,
            candidates: null,
            showCandidates: true,
            mistakes: 0,
            startTime: null,
            givenCells: new Set()
        };

        let currentGeneratedPuzzle = null;
        let currentGeneratedTime = null;

        // Initialize start time input
        const now = new Date();
        now.setMinutes(now.getMinutes() + 1);
        document.getElementById('startTime').value = now.toISOString().slice(0, 16);

        // Event listeners
        document.getElementById('minDiff').addEventListener('input', (e) => {
            document.getElementById('minDiffValue').textContent = (e.target.value / 100).toFixed(2);
        });
        document.getElementById('maxDiff').addEventListener('input', (e) => {
            document.getElementById('maxDiffValue').textContent = (e.target.value / 100).toFixed(2);
        });

        function generatePuzzle() {
            const minDiff = parseInt(document.getElementById('minDiff').value) / 100;
            const maxDiff = parseInt(document.getElementById('maxDiff').value) / 100;
            const targetClues = parseInt(document.getElementById('targetClues').value);
            const maxAttempts = parseInt(document.getElementById('maxAttempts').value);

            const startTimeInput = document.getElementById('startTime').value;
            const startDate = new Date(startTimeInput);
            const unixTimestamp = Math.floor(startDate.getTime() / 1000);
            
            const puzzle = generateSudoku(minDiff, maxDiff, targetClues, maxAttempts);
            const puzzleString = convertToString(puzzle);
            
            currentGeneratedPuzzle = puzzleString;
            currentGeneratedTime = unixTimestamp;

            const baseUrl = window.location.origin + window.location.pathname;
            const shareUrl = `${baseUrl}?p=${puzzleString}&t=${unixTimestamp}`;
            
            document.getElementById('shareUrl').textContent = shareUrl;
            document.getElementById('shareContainer').classList.add('active');
        }

        function copyShareLink() {
            const shareUrl = document.getElementById('shareUrl').textContent;
            navigator.clipboard.writeText(shareUrl).then(() => {
                alert('Link copied to clipboard!');
            });
        }

        function startFromLink() {
            if (!currentGeneratedPuzzle || !currentGeneratedTime) return;
            
            const puzzle = convertToMatrix(currentGeneratedPuzzle);
            const startTime = currentGeneratedTime * 1000;
            const now = Date.now();

            if (startTime > now) {
                waitForStartTime(startTime);
            } else {
                initializeGame(puzzle);
                startGameNow();
            }
        }

        function loadFromUrl() {
            const puzzle = convertToMatrix(puzzleParam);
            const startTime = parseInt(timeParam) * 1000;
            const now = Date.now();

            if (startTime > now) {
                waitForStartTime(startTime);
                gameState.puzzle = puzzle;
                gameState.initial = deepCopyBoard(puzzle);
                gameState.current = deepCopyBoard(puzzle);
            } else {
                initializeGame(puzzle);
                startGameNow();
            }
        }

        function initializeGame(puzzle) {
            gameState.puzzle = puzzle;
            gameState.initial = deepCopyBoard(puzzle);
            gameState.current = deepCopyBoard(puzzle);
            gameState.mistakes = 0;
            gameState.selected = null;
            gameState.candidates = Array(9).fill(null).map(() => Array(9).fill(null).map(() => new Set()));

            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    if (puzzle[r][c] !== 0) {
                        gameState.givenCells.add(`${r},${c}`);
                        gameState.candidates[r][c] = new Set();
                    } else {
                        gameState.candidates[r][c] = new Set(getPossibleValues(puzzle, r, c));
                    }
                }
            }

            renderBoard();
            updateStats();
        }

        function waitForStartTime(startTime) {
            document.getElementById('setupForm').style.display = 'none';
            document.getElementById('waitingContainer').classList.add('active');

            const countdown = () => {
                const now = Date.now();
                const diff = startTime - now;

                if (diff <= 0) {
                    startGameNow();
                } else {
                    const hours = Math.floor(diff / 3600000);
                    const minutes = Math.floor((diff % 3600000) / 60000);
                    const seconds = Math.floor((diff % 60000) / 1000);
                    document.getElementById('countdown').textContent = 
                        `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                    setTimeout(countdown, 100);
                }
            };
            countdown();
        }

        function startGameNow() {
            document.getElementById('waitingContainer').classList.remove('active');
            document.getElementById('setupForm').style.display = 'none';
            document.getElementById('gameContainer').classList.add('active');
            gameState.startTime = Date.now();
            updateTimer();
        }

        function renderBoard() {
            const board = document.getElementById('sudokuBoard');
            board.innerHTML = '';

            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'sudoku-cell';
                    
                    if (gameState.initial[r][c] !== 0) {
                        cell.classList.add('given');
                    }

                    if (gameState.selected && gameState.selected[0] === r && gameState.selected[1] === c) {
                        cell.classList.add('selected');
                    }

                    if (gameState.selected && gameState.current[gameState.selected[0]][gameState.selected[1]] !== 0) {
                        const selectedVal = gameState.current[gameState.selected[0]][gameState.selected[1]];
                        if (gameState.current[r][c] === selectedVal && (r !== gameState.selected[0] || c !== gameState.selected[1])) {
                            cell.classList.add('highlighted');
                        }
                    }

                    if (gameState.current[r][c] !== 0) {
                        const isValid = isValidPlacement(r, c, gameState.current[r][c]);
                        if (!isValid) {
                            cell.classList.add('error');
                        }
                    }

                    const cellContent = document.createElement('div');
                    cellContent.style.width = '100%';
                    cellContent.style.height = '100%';
                    cellContent.style.display = 'flex';
                    cellContent.style.alignItems = 'center';
                    cellContent.style.justifyContent = 'center';

                    if (gameState.current[r][c] !== 0) {
                        cellContent.textContent = gameState.current[r][c];
                    } else if (gameState.showCandidates && gameState.candidates[r][c].size > 0) {
                        const candidatesDiv = document.createElement('div');
                        candidatesDiv.className = 'candidates';
                        for (let i = 1; i <= 9; i++) {
                            const candidate = document.createElement('div');
                            candidate.className = 'candidate';
                            if (!gameState.candidates[r][c].has(i)) {
                                candidate.classList.add('hidden');
                            }
                            candidate.textContent = i;
                            candidatesDiv.appendChild(candidate);
                        }
                        cellContent.appendChild(candidatesDiv);
                    }

                    cell.appendChild(cellContent);
                    cell.onclick = () => selectCell(r, c);
                    
                    cell.onkeydown = (e) => {
                        const num = parseInt(e.key);
                        if (num >= 1 && num <= 9 && gameState.selected) {
                            placeNumber(gameState.selected[0], gameState.selected[1], num);
                            e.preventDefault();
                        } else if (e.key === '0' || e.key === 'Backspace' || e.key === 'Delete') {
                            if (gameState.selected) {
                                clearCell(gameState.selected[0], gameState.selected[1]);
                            }
                            e.preventDefault();
                        }
                    };
                    cell.tabIndex = 0;

                    board.appendChild(cell);
                }
            }

            if (gameState.selected) {
                const index = gameState.selected[0] * 9 + gameState.selected[1];
                setTimeout(() => {
                    document.querySelectorAll('.sudoku-cell')[index]?.focus();
                }, 0);
            }
        }

        function selectCell(r, c) {
            if (gameState.initial[r][c] === 0) {
                gameState.selected = [r, c];
                renderBoard();
            }
        }

        function placeNumber(r, c, num) {
            if (gameState.initial[r][c] !== 0) return;

            gameState.current[r][c] = num;
            gameState.candidates[r][c].clear();

            updateCandidatesAfterPlacement(r, c, num);

            if (!isValidPlacement(r, c, num)) {
                gameState.mistakes++;
            }

            updateStats();
            renderBoard();

            if (isPuzzleSolved()) {
                setTimeout(() => alert('PUZZLE SOLVED'), 100);
            }
        }

        function clearCell(r, c) {
            if (gameState.initial[r][c] !== 0) return;

            const val = gameState.current[r][c];
            gameState.current[r][c] = 0;

            gameState.candidates[r][c] = new Set(getPossibleValues(gameState.current, r, c));

            if (val !== 0) {
                for (let i = 0; i < 9; i++) {
                    if (gameState.current[r][i] === 0 && canPlace(r, i, val)) {
                        gameState.candidates[r][i].add(val);
                    }
                    if (gameState.current[i][c] === 0 && canPlace(i, c, val)) {
                        gameState.candidates[i][c].add(val);
                    }
                }
                const startRow = Math.floor(r / 3) * 3;
                const startCol = Math.floor(c / 3) * 3;
                for (let br = startRow; br < startRow + 3; br++) {
                    for (let bc = startCol; bc < startCol + 3; bc++) {
                        if (gameState.current[br][bc] === 0 && canPlace(br, bc, val)) {
                            gameState.candidates[br][bc].add(val);
                        }
                    }
                }
            }

            updateStats();
            renderBoard();
        }

        function updateCandidatesAfterPlacement(r, c, num) {
            for (let i = 0; i < 9; i++) {
                gameState.candidates[r][i].delete(num);
                gameState.candidates[i][c].delete(num);
            }
            const startRow = Math.floor(r / 3) * 3;
            const startCol = Math.floor(c / 3) * 3;
            for (let br = startRow; br < startRow + 3; br++) {
                for (let bc = startCol; bc < startCol + 3; bc++) {
                    gameState.candidates[br][bc].delete(num);
                }
            }
        }

        function isValidPlacement(r, c, num) {
            for (let i = 0; i < 9; i++) {
                if (i !== c && gameState.current[r][i] === num) return false;
            }
            for (let i = 0; i < 9; i++) {
                if (i !== r && gameState.current[i][c] === num) return false;
            }
            const startRow = Math.floor(r / 3) * 3;
            const startCol = Math.floor(c / 3) * 3;
            for (let br = startRow; br < startRow + 3; br++) {
                for (let bc = startCol; bc < startCol + 3; bc++) {
                    if ((br !== r || bc !== c) && gameState.current[br][bc] === num) return false;
                }
            }
            return true;
        }

        function canPlace(r, c, num) {
            if (gameState.current[r][c] !== 0) return false;
            return isValidPlacement(r, c, num);
        }

        function isPuzzleSolved() {
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    if (gameState.current[r][c] === 0) return false;
                    if (!isValidPlacement(r, c, gameState.current[r][c])) return false;
                }
            }
            return true;
        }

        function updateStats() {
            const filled = gameState.current.flat().filter(x => x !== 0).length;
            const remaining = 81 - gameState.initial.flat().filter(x => x !== 0).length;
            const completed = Math.round((filled - gameState.initial.flat().filter(x => x !== 0).length) / remaining * 100);

            document.getElementById('mistakes').textContent = gameState.mistakes;
            document.getElementById('remaining').textContent = remaining - (filled - gameState.initial.flat().filter(x => x !== 0).length);
            document.getElementById('completed').textContent = Math.max(0, completed) + '%';
        }

        function updateTimer() {
            if (!gameState.startTime) return;
            const elapsed = Math.floor((Date.now() - gameState.startTime) / 1000);
            const hours = Math.floor(elapsed / 3600);
            const minutes = Math.floor((elapsed % 3600) / 60);
            const seconds = elapsed % 60;
            document.getElementById('timer').textContent = 
                `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            setTimeout(updateTimer, 1000);
        }

        function clearSelection() {
            if (gameState.selected) {
                clearCell(gameState.selected[0], gameState.selected[1]);
            }
        }

        function toggleCandidates() {
            gameState.showCandidates = !gameState.showCandidates;
            renderBoard();
        }

        function resetGame() {
            gameState.current = deepCopyBoard(gameState.initial);
            gameState.mistakes = 0;
            gameState.selected = null;
            gameState.candidates = Array(9).fill(null).map(() => Array(9).fill(null).map(() => new Set()));
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    if (gameState.initial[r][c] === 0) {
                        gameState.candidates[r][c] = new Set(getPossibleValues(gameState.initial, r, c));
                    }
                }
            }
            updateStats();
            renderBoard();
        }

        function resetToSetup() {
            document.getElementById('setupForm').style.display = 'block';
            document.getElementById('gameContainer').classList.remove('active');
            gameState = {
                puzzle: null,
                solution: null,
                current: null,
                initial: null,
                selected: null,
                candidates: null,
                showCandidates: true,
                mistakes: 0,
                startTime: null,
                givenCells: new Set()
            };
        }

        // Check for URL params on load
        if (puzzleParam && timeParam) {
            loadFromUrl();
        }

        document.addEventListener('keydown', (e) => {
            if (!gameState.selected || !document.getElementById('gameContainer').classList.contains('active')) return;
            const [r, c] = gameState.selected;
            const num = parseInt(e.key);
            if (num >= 1 && num <= 9) {
                placeNumber(r, c, num);
            } else if (e.key === '0' || e.key === 'Backspace' || e.key === 'Delete') {
                clearCell(r, c);
            } else if (e.key === 'ArrowUp' && r > 0) {
                selectCell(r - 1, c);
            } else if (e.key === 'ArrowDown' && r < 8) {
                selectCell(r + 1, c);
            } else if (e.key === 'ArrowLeft' && c > 0) {
                selectCell(r, c - 1);
            } else if (e.key === 'ArrowRight' && c < 8) {
                selectCell(r, c + 1);
            }
        });
    </script>
</body>
</html>
