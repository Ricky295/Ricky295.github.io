<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>6x6 Sudoku Favicon</title>
<link id="favicon" rel="icon" type="image/png" href="">
<style>
  body {
    font-family: monospace;
    padding: 1rem;
  }
  #controls {
    margin-bottom: 1rem;
  }
  #timer {
    font-weight: bold;
  }
</style>
</head>
<body>

<div id="controls">
  <label for="cluesRange">Clues: <span id="cluesCount">15</span></label>
  <input id="cluesRange" type="range" min="10" max="20" value="15" />
  <button id="generateBtn">Generate</button>
  <button id="checkBtn">Check</button>
  <span> Timer: <span id="timer">00:00</span></span>
</div>

<div>
  <small>Use keys 1-6 to fill cell. Shift+1-6 to toggle candidates.</small><br/>
  <small>Arrow keys to move. Enter to check solution.</small>
</div>

<script src="sudoku6x6.js"></script>
<script>
(() => {
  const SIZE = 6;
  const CELL_SIZE = 5;
  const BORDER_WIDTH = 1;
  const FAVICON_SIZE = 32;

  const canvas = document.createElement('canvas');
  canvas.width = FAVICON_SIZE;
  canvas.height = FAVICON_SIZE;
  const ctx = canvas.getContext('2d');

  const faviconLink = document.getElementById('favicon');

  // Sudoku state
  let puzzle = null;      // 2D array with clues and blanks (0)
  let solution = null;    // solved board 2D array
  let userBoard = null;   // current board with user input (2D array)
  let candidates = null;  // array of sets per cell storing candidate digits (1-6)
  let selectedCell = {r: 0, c: 0};
  let cluesCount = 15;

  // Timer
  let startTime = null;
  let timerInterval = null;

  // Best times storage key
  const STORAGE_KEY = 'favicon6x6_besttimes';

  // Helpers
  function createEmptyCandidates() {
    const c = [];
    for(let r=0; r<SIZE; r++){
      c[r] = [];
      for(let c2=0; c2<SIZE; c2++){
        c[r][c2] = new Set();
      }
    }
    return c;
  }

  function cloneBoard(board) {
    return board.map(row => row.slice());
  }

  function isCellGiven(r, c) {
    return puzzle[r][c] !== 0;
  }

  // Convert board to string for displaying candidates in favicon
  // We'll draw main digit large center, and candidates as small pixels at corners
  // Candidates as digits 1-6 shown as single pixels arranged in 2x3 grid inside cell

  // Drawing functions
  function drawGrid() {
    ctx.fillStyle = '#fff';
    ctx.fillRect(0, 0, FAVICON_SIZE, FAVICON_SIZE);

    // Draw cells
    for(let r=0; r<SIZE; r++){
      for(let c=0; c<SIZE; c++){
        const x = c * CELL_SIZE + Math.floor(c/3); // add 1px gap after col 2
        const y = r * CELL_SIZE + Math.floor(r/2); // add 1px gap after row 1,3
        // Cell background
        ctx.fillStyle = (selectedCell.r === r && selectedCell.c === c) ? '#fffbcc' : '#fff';
        ctx.fillRect(x, y, CELL_SIZE, CELL_SIZE);

        // Cell border - inner borders 1px thick
        ctx.strokeStyle = '#444';
        ctx.lineWidth = 1;
        ctx.strokeRect(x, y, CELL_SIZE, CELL_SIZE);
      }
    }

    // Draw bold outer grid borders (2px)
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 2;
    // Horizontal thick lines after rows 1 and 3
    [2,4].forEach(row => {
      const y = row * CELL_SIZE + Math.floor(row/2);
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(FAVICON_SIZE, y);
      ctx.stroke();
    });
    // Vertical thick lines after cols 2 and 5 (3x2 blocks)
    [3].forEach(col => {
      const x = col * CELL_SIZE + Math.floor(col/3);
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, FAVICON_SIZE);
      ctx.stroke();
    });
  }

  function drawDigit(r, c, digit, given=false) {
    if(digit === 0) return;

    const x = c * CELL_SIZE + Math.floor(c/3);
    const y = r * CELL_SIZE + Math.floor(r/2);

    ctx.fillStyle = given ? '#000' : '#333';
    ctx.font = 'bold 4px monospace';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(digit, x + CELL_SIZE/2, y + CELL_SIZE/2 + 0.5);
  }

  function drawCandidates(r, c, candidateSet) {
    if(candidateSet.size === 0) return;

    const x = c * CELL_SIZE + Math.floor(c/3);
    const y = r * CELL_SIZE + Math.floor(r/2);

    // Arrange candidates in 2 cols x 3 rows (max 6 digits)
    // pixel positions inside cell (relative)
    const positions = [
      [1,1], [3,1],
      [1,2], [3,2],
      [1,3], [3,3]
    ];

    ctx.fillStyle = '#999';
    ctx.font = '3px monospace';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    [...candidateSet].sort().forEach((digit, idx) => {
      if(idx >= 6) return;
      const [dx, dy] = positions[idx];
      ctx.fillText(digit, x + dx, y + dy);
    });
  }

  function render() {
    drawGrid();

    for(let r=0; r<SIZE; r++){
      for(let c=0; c<SIZE; c++){
        const given = isCellGiven(r,c);
        if(userBoard[r][c] !== 0) {
          drawDigit(r, c, userBoard[r][c], given);
        } else if(candidates[r][c].size > 0) {
          drawCandidates(r, c, candidates[r][c]);
        }
      }
    }

    updateFavicon();
  }

  function updateFavicon() {
    const url = canvas.toDataURL('image/png');
    if(faviconLink) {
      faviconLink.href = url;
    } else {
      const link = document.createElement('link');
      link.id = 'favicon';
      link.rel = 'icon';
      link.type = 'image/png';
      link.href = url;
      document.head.appendChild(link);
    }
  }

  // Input handling
  function selectCell(r,c) {
    if(r<0) r=0; if(r>=SIZE) r=SIZE-1;
    if(c<0) c=0; if(c>=SIZE) c=SIZE-1;
    selectedCell = {r,c};
    render();
  }

  function clearCandidatesAt(r,c) {
    candidates[r][c].clear();
  }

  function toggleCandidate(r,c, digit) {
    if(candidates[r][c].has(digit)) {
      candidates[r][c].delete(digit);
    } else {
      candidates[r][c].add(digit);
    }
  }

  function setCellValue(r,c,digit) {
    if(isCellGiven(r,c)) return; // no edit givens
    userBoard[r][c] = digit;
    clearCandidatesAt(r,c);
  }

  function onKeyDown(e) {
    if(document.activeElement.tagName === 'INPUT') return; // avoid typing in controls

    const r = selectedCell.r;
    const c = selectedCell.c;

    if(e.key === "ArrowUp") {
      selectCell(r-1,c);
      e.preventDefault();
      return;
    }
    if(e.key === "ArrowDown") {
      selectCell(r+1,c);
      e.preventDefault();
      return;
    }
    if(e.key === "ArrowLeft") {
      selectCell(r,c-1);
      e.preventDefault();
      return;
    }
    if(e.key === "ArrowRight") {
      selectCell(r,c+1);
      e.preventDefault();
      return;
    }

    if(e.key >= '1' && e.key <= '6') {
      const digit = parseInt(e.key);
      if(e.shiftKey) {
        // Toggle candidate
        if(isCellGiven(r,c)) return;
        toggleCandidate(r,c,digit);
      } else {
        setCellValue(r,c,digit);
        // Move cursor right automatically
        selectCell(r, c+1);
      }
      render();
      e.preventDefault();
      return;
    }

    if(e.key === 'Backspace' || e.key === 'Delete' || e.key === '0') {
      if(isCellGiven(r,c)) return;
      userBoard[r][c] = 0;
      clearCandidatesAt(r,c);
      render();
      e.preventDefault();
      return;
    }

    if(e.key === 'Enter') {
      checkSolution();
      e.preventDefault();
      return;
    }
  }

  // Generate new puzzle from clues slider
  function generateNewPuzzle() {
    cluesCount = parseInt(document.getElementById('cluesRange').value);
    document.getElementById('cluesCount').textContent = cluesCount;

    puzzle = generateSudoku(cluesCount, false);
    solution = solveFromArray(puzzle);

    userBoard = cloneBoard(puzzle);
    candidates = createEmptyCandidates();
    selectCell(0,0);

    startTimer();
    render();
  }

  // Timer functions
  function startTimer() {
    startTime = Date.now();
    clearInterval(timerInterval);
    timerInterval = setInterval(() => {
      const elapsed = Math.floor((Date.now() - startTime) / 1000);
      const minutes = String(Math.floor(elapsed/60)).padStart(2,'0');
      const seconds = String(elapsed % 60).padStart(2,'0');
      document.getElementById('timer').textContent = `${minutes}:${seconds}`;
    }, 1000);
  }

  function stopTimer() {
    clearInterval(timerInterval);
  }

  // Check if userBoard matches solution
  function checkSolution() {
    for(let r=0; r<SIZE; r++){
      for(let c=0; c<SIZE; c++){
        if(userBoard[r][c] !== solution[r][c]) {
          alert('Incorrect solution, keep trying!');
          return;
        }
      }
    }
    stopTimer();
    alert('Congratulations! You solved it!');

    saveBestTime();
  }

  // Best time localStorage handling
  function loadBestTimes() {
    const json = localStorage.getItem(STORAGE_KEY);
    if(!json) return {};
    try {
      return JSON.parse(json);
    } catch {
      return {};
    }
  }
  function saveBestTimes(times) {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(times));
  }

  function saveBestTime() {
    const elapsed = Math.floor((Date.now() - startTime) / 1000);
    let times = loadBestTimes();
    if(!times[cluesCount] || elapsed < times[cluesCount]) {
      times[cluesCount] = elapsed;
      saveBestTimes(times);
      alert(`New best time for ${cluesCount} clues: ${elapsed} seconds!`);
    }
  }

  // Init event listeners
  document.getElementById('generateBtn').addEventListener('click', generateNewPuzzle);
  document.getElementById('checkBtn').addEventListener('click', checkSolution);
  document.getElementById('cluesRange').addEventListener('input', (e) => {
    document.getElementById('cluesCount').textContent = e.target.value;
  });
  window.addEventListener('keydown', onKeyDown);

  // Initial puzzle generation
  generateNewPuzzle();

})();
</script>

</body>
</html>
