<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Favicon Sudoku</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f0f0f0;
        }
        
        .game-container {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        .controls {
            margin-bottom: 20px;
        }
        
        .control-group {
            margin: 10px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        label {
            min-width: 100px;
        }
        
        button {
            padding: 8px 16px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        button:hover {
            background: #0056b3;
        }
        
        .timer {
            font-size: 18px;
            font-weight: bold;
            color: #333;
        }
        
        .status {
            margin: 10px 0;
            padding: 10px;
            border-radius: 4px;
            background: #e9ecef;
        }
        
        .favicon-display {
            margin: 20px 0;
            text-align: center;
        }
        
        .favicon-preview {
            width: 128px;
            height: 128px;
            border: 2px solid #333;
            margin: 0 auto;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }
        
        .instructions {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            margin-top: 20px;
        }
        
        .instructions h3 {
            margin-top: 0;
        }
        
        .key-combo {
            background: #e9ecef;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>Favicon Sudoku</h1>
        
        <div class="controls">
            <div class="control-group">
                <label>Timer:</label>
                <span class="timer" id="timer">00:00</span>
            </div>
            
            <div class="control-group">
                <label>Clues:</label>
                <input type="range" id="clueSlider" min="10" max="20" value="15">
                <span id="clueCount">15</span>
            </div>
            
            <div class="control-group">
                <button onclick="generatePuzzle()" id="generateBtn">Generate New Puzzle</button>
                <button onclick="checkSolution()" id="checkBtn">Check Solution</button>
            </div>
            
            <div class="status" id="status">Press Generate to start a new game</div>
        </div>
        
        <div class="favicon-display">
            <h3>Favicon Game (32x32)</h3>
            <canvas id="faviconCanvas" width="32" height="32" class="favicon-preview"></canvas>
        </div>
        
        <div class="instructions">
            <h3>Controls:</h3>
            <ul>
                <li><span class="key-combo">Arrow Keys</span> - Move cursor</li>
                <li><span class="key-combo">1-6</span> - Enter digit</li>
                <li><span class="key-combo">Ctrl + 1-6</span> - Add candidate (pixel)</li>
                <li><span class="key-combo">Alt + 1-6</span> - Highlight digit</li>
                <li><span class="key-combo">Alt + Ctrl + 1-6</span> - Highlight digit and candidates</li>
                <li><span class="key-combo">0 / Backspace / Delete</span> - Clear number</li>
                <li><span class="key-combo">Enter</span> - Check solution</li>
            </ul>
        </div>
    </div>

    <script>
        // Sudoku6x6 Generator Class (ensures unique solutions)
        class Sudoku6x6 {
            constructor() {
                this.size = 6;
                this.blockRows = 2;
                this.blockCols = 3;
                this.nums = [1, 2, 3, 4, 5, 6];
            }

            shuffle(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }

            isSafe(board, row, col, num) {
                for (let i = 0; i < this.size; i++) {
                    if (board[row][i] === num) return false;
                    if (board[i][col] === num) return false;
                }
                const startRow = row - (row % this.blockRows);
                const startCol = col - (col % this.blockCols);
                for (let r = 0; r < this.blockRows; r++) {
                    for (let c = 0; c < this.blockCols; c++) {
                        if (board[startRow + r][startCol + c] === num) return false;
                    }
                }
                return true;
            }

            solve(board, countSolutions = false, limit = 2) {
                let solutions = 0;

                const helper = () => {
                    for (let r = 0; r < this.size; r++) {
                        for (let c = 0; c < this.size; c++) {
                            if (board[r][c] === 0) {
                                for (let num of this.nums) {
                                    if (this.isSafe(board, r, c, num)) {
                                        board[r][c] = num;
                                        if (helper()) return true;
                                        board[r][c] = 0;
                                    }
                                }
                                return false;
                            }
                        }
                    }
                    solutions++;
                    if (!countSolutions) return true;
                    return solutions >= limit;
                };

                const result = helper();
                if (countSolutions) return solutions;
                return result;
            }

            generateSudoku(clues = 15) {
                let board = Array.from({ length: this.size }, () =>
                    Array(this.size).fill(0)
                );
                this.solve(board);

                let cells = [];
                for (let r = 0; r < this.size; r++) {
                    for (let c = 0; c < this.size; c++) {
                        cells.push([r, c]);
                    }
                }
                this.shuffle(cells);

                let cluesLeft = this.size * this.size;
                for (let [r, c] of cells) {
                    if (cluesLeft <= clues) break;

                    let backup = board[r][c];
                    board[r][c] = 0;

                    const boardCopy = board.map(row => row.slice());
                    const solutions = this.solve(boardCopy, true, 2);
                    if (solutions !== 1) {
                        board[r][c] = backup;
                    } else {
                        cluesLeft--;
                    }
                }

                return board;
            }
        }
        const DIGIT_FONTS = {
            1: [
                [0,1,0],
                [1,1,0],
                [0,1,0],
                [0,1,0],
                [1,1,1]
            ],
            2: [
                [1,1,1],
                [0,0,1],
                [1,1,1],
                [1,0,0],
                [1,1,1]
            ],
            3: [
                [1,1,1],
                [0,0,1],
                [1,1,1],
                [0,0,1],
                [1,1,1]
            ],
            4: [
                [1,0,1],
                [1,0,1],
                [1,1,1],
                [0,0,1],
                [0,0,1]
            ],
            5: [
                [1,1,1],
                [1,0,0],
                [1,1,1],
                [0,0,1],
                [1,1,1]
            ],
            6: [
                [1,1,1],
                [1,0,0],
                [1,1,1],
                [1,0,1],
                [1,1,1]
            ]
        };

        class FaviconSudoku {
            constructor() {
                this.canvas = document.getElementById('faviconCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.ctx.imageSmoothingEnabled = false;
                
                this.sudokuGenerator = new Sudoku6x6();
                
                this.grid = Array(6).fill().map(() => Array(6).fill(0));
                this.solution = Array(6).fill().map(() => Array(6).fill(0));
                this.given = Array(6).fill().map(() => Array(6).fill(false));
                this.candidates = Array(6).fill().map(() => Array(6).fill().map(() => new Set()));
                
                this.cursorX = 0;
                this.cursorY = 0;
                this.highlightDigit = 0;
                this.highlightCandidates = false;
                
                this.startTime = 0;
                this.timerInterval = null;
                
                this.setupEventListeners();
                this.render();
                
                // Update favicon
                this.updateFavicon();
            }
            
            autoRemoveCandidates(row, col, num) {
                // Remove from same row
                for (let i = 0; i < 6; i++) {
                    this.candidates[row][i].delete(num);
                }
                
                // Remove from same column
                for (let i = 0; i < 6; i++) {
                    this.candidates[i][col].delete(num);
                }
                
                // Remove from same 2x3 box
                const boxRow = Math.floor(row / 2) * 2;
                const boxCol = Math.floor(col / 3) * 3;
                for (let i = boxRow; i < boxRow + 2; i++) {
                    for (let j = boxCol; j < boxCol + 3; j++) {
                        this.candidates[i][j].delete(num);
                    }
                }
            }
            
            setupEventListeners() {
                document.addEventListener('keydown', (e) => this.handleKeyPress(e));
                
                const clueSlider = document.getElementById('clueSlider');
                clueSlider.addEventListener('input', (e) => {
                    document.getElementById('clueCount').textContent = e.target.value;
                });
            }
            
            generateValidSolution() {
                // Reset grid
                this.solution = Array(6).fill().map(() => Array(6).fill(0));
                
                // Fill grid using backtracking
                this.solveSudoku(this.solution);
            }
            
            solveSudoku(grid) {
                for (let row = 0; row < 6; row++) {
                    for (let col = 0; col < 6; col++) {
                        if (grid[row][col] === 0) {
                            const numbers = [1, 2, 3, 4, 5, 6].sort(() => Math.random() - 0.5);
                            for (let num of numbers) {
                                if (this.isValidMove(grid, row, col, num)) {
                                    grid[row][col] = num;
                                    if (this.solveSudoku(grid)) {
                                        return true;
                                    }
                                    grid[row][col] = 0;
                                }
                            }
                            return false;
                        }
                    }
                }
                return true;
            }
            
            isValidMove(grid, row, col, num) {
                // Check row
                for (let i = 0; i < 6; i++) {
                    if (grid[row][i] === num) return false;
                }
                
                // Check column
                for (let i = 0; i < 6; i++) {
                    if (grid[i][col] === num) return false;
                }
                
                // Check 2x3 box
                const boxRow = Math.floor(row / 2) * 2;
                const boxCol = Math.floor(col / 3) * 3;
                for (let i = boxRow; i < boxRow + 2; i++) {
                    for (let j = boxCol; j < boxCol + 3; j++) {
                        if (grid[i][j] === num) return false;
                    }
                }
                
                return true;
            }
            
            handleKeyPress(e) {
                if (!this.startTime) return;
                
                const key = e.key;
                const ctrl = e.ctrlKey;
                const alt = e.altKey;
                
                e.preventDefault();
                
                // Movement
                if (key === 'ArrowUp' && this.cursorY > 0) this.cursorY--;
                else if (key === 'ArrowDown' && this.cursorY < 5) this.cursorY++;
                else if (key === 'ArrowLeft' && this.cursorX > 0) this.cursorX--;
                else if (key === 'ArrowRight' && this.cursorX < 5) this.cursorX++;
                
                // Number input
                else if (key >= '1' && key <= '6') {
                    const num = parseInt(key);
                    
                    if (alt && ctrl) {
                        // Highlight digit and candidates
                        this.highlightDigit = num;
                        this.highlightCandidates = true;
                    } else if (alt) {
                        // Highlight digit only
                        this.highlightDigit = num;
                        this.highlightCandidates = false;
                    } else if (ctrl) {
                        // Add/remove candidate
                        if (!this.given[this.cursorY][this.cursorX]) {
                            if (this.candidates[this.cursorY][this.cursorX].has(num)) {
                                this.candidates[this.cursorY][this.cursorX].delete(num);
                            } else {
                                this.candidates[this.cursorY][this.cursorX].add(num);
                            }
                        }
                    } else {
                        // Enter digit
                        if (!this.given[this.cursorY][this.cursorX]) {
                            this.grid[this.cursorY][this.cursorX] = num;
                            this.candidates[this.cursorY][this.cursorX].clear();
                            this.autoRemoveCandidates(this.cursorY, this.cursorX, num);
                        }
                    }
                }
                
                // Clear
                else if (key === '0' || key === 'Backspace' || key === 'Delete') {
                    if (!this.given[this.cursorY][this.cursorX]) {
                        this.grid[this.cursorY][this.cursorX] = 0;
                        this.candidates[this.cursorY][this.cursorX].clear();
                    }
                }
                
                // Check solution
                else if (key === 'Enter') {
                    checkSolution();
                }
                
                this.render();
                this.updateFavicon();
            }
            
            render() {
                this.ctx.fillStyle = '#ffffff';
                this.ctx.fillRect(0, 0, 32, 32);
                
                // Draw only region borders (1 pixel)
                this.ctx.fillStyle = '#000000';
                
                // Vertical region border (between left and right 3-column groups)
                this.ctx.fillRect(16, 0, 1, 32);
                
                // Horizontal region borders (after rows 2 and 4)
                this.ctx.fillRect(0, 11, 32, 1);  // After 2nd row
                this.ctx.fillRect(0, 22, 32, 1);  // After 4th row
                
                // Draw numbers and candidates
                for (let row = 0; row < 6; row++) {
                    for (let col = 0; col < 6; col++) {
                        // Calculate cell position based on new layout
                        let cellY;
                        if (row <= 1) {
                            cellY = row * 5 + 1;  // rows 1-5, 6-10
                        } else if (row <= 3) {
                            cellY = (row - 2) * 5 + 12;  // rows 12-16, 17-21
                        } else {
                            cellY = (row - 4) * 5 + 23;  // rows 23-27, 28-32
                        }
                        
                        const cellX = col < 3 ? col * 5 + 1 : col * 5 + 2; // Account for vertical border
                        const cellW = 5;
                        const cellH = 5;
                        
                        // Highlight if needed
                        if (this.highlightDigit > 0) {
                            const hasDigit = this.grid[row][col] === this.highlightDigit;
                            const hasCandidate = this.highlightCandidates && 
                                               this.candidates[row][col].has(this.highlightDigit);
                            
                            if (hasDigit || hasCandidate) {
                                this.ctx.fillStyle = '#ffff00';
                                this.ctx.fillRect(cellX, cellY, cellW, cellH);
                            }
                        }
                        
                        // Draw cursor
                        if (row === this.cursorY && col === this.cursorX) {
                            this.ctx.fillStyle = '#0080ff';
                            this.ctx.fillRect(cellX, cellY, cellW, cellH);
                        }
                        
                        // Draw number
                        if (this.grid[row][col] > 0) {
                            this.ctx.fillStyle = this.given[row][col] ? '#000000' : '#0000ff';
                            this.drawDigit(this.grid[row][col], cellX + 1, cellY);
                        } else {
                            // Draw candidates as tiny pixels
                            this.ctx.fillStyle = '#808080';
                            for (let candidate of this.candidates[row][col]) {
                                const px = cellX + ((candidate - 1) % 3) + 1;
                                const py = cellY + Math.floor((candidate - 1) / 3) + 1;
                                this.ctx.fillRect(px, py, 1, 1);
                            }
                        }
                    }
                }
            }
            
            drawDigit(digit, x, y) {
                const font = DIGIT_FONTS[digit];
                if (!font) return;
                
                for (let row = 0; row < 5; row++) {
                    for (let col = 0; col < 3; col++) {
                        if (font[row][col]) {
                            this.ctx.fillRect(x + col, y + row, 1, 1);
                        }
                    }
                }
            }
            
            updateFavicon() {
                const link = document.querySelector("link[rel*='icon']") || document.createElement('link');
                link.type = 'image/png';
                link.rel = 'shortcut icon';
                link.href = this.canvas.toDataURL();
                document.getElementsByTagName('head')[0].appendChild(link);
            }
            
            startTimer() {
                this.startTime = Date.now();
                this.timerInterval = setInterval(() => {
                    const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
                    const minutes = Math.floor(elapsed / 60);
                    const seconds = elapsed % 60;
                    document.getElementById('timer').textContent = 
                        `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                }, 1000);
            }
            
            stopTimer() {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                    this.timerInterval = null;
                }
            }
        }
        
        let game;
        
        function generatePuzzle() {
            if (game && game.timerInterval) {
                game.stopTimer();
            }
            
            game = new FaviconSudoku();
            
            const clueCount = parseInt(document.getElementById('clueSlider').value);
            
            // Generate puzzle with unique solution using the proper generator
            const puzzle = game.sudokuGenerator.generateSudoku(clueCount);
            
            // Get solution by solving the complete grid
            const solutionBoard = Array.from({ length: 6 }, () => Array(6).fill(0));
            game.sudokuGenerator.solve(solutionBoard);
            
            // Set up the game state
            for (let i = 0; i < 6; i++) {
                for (let j = 0; j < 6; j++) {
                    game.grid[i][j] = puzzle[i][j];
                    game.solution[i][j] = solutionBoard[i][j];
                    game.given[i][j] = puzzle[i][j] !== 0;
                }
            }
            
            // Reset candidates
            game.candidates = Array(6).fill().map(() => Array(6).fill().map(() => new Set()));
            
            game.render();
            game.updateFavicon();
            game.startTimer();
            
            document.getElementById('status').textContent = `New unique-solution puzzle generated with ${clueCount} clues. Good luck!`;
        }
        
        function checkSolution() {
            if (!game || !game.startTime) {
                document.getElementById('status').textContent = 'Generate a puzzle first!';
                return;
            }
            
            // Check if puzzle is complete
            for (let i = 0; i < 6; i++) {
                for (let j = 0; j < 6; j++) {
                    if (game.grid[i][j] === 0) {
                        document.getElementById('status').textContent = 'Puzzle is not complete yet!';
                        return;
                    }
                }
            }
            
            // Check if solution is correct
            let correct = true;
            for (let i = 0; i < 6; i++) {
                for (let j = 0; j < 6; j++) {
                    if (game.grid[i][j] !== game.solution[i][j]) {
                        correct = false;
                        break;
                    }
                }
                if (!correct) break;
            }
            
            if (correct) {
                game.stopTimer();
                const elapsed = Math.floor((Date.now() - game.startTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                document.getElementById('status').textContent = 
                    `🎉 Congratulations! Puzzle solved in ${minutes}:${seconds.toString().padStart(2, '0')}!`;
            } else {
                document.getElementById('status').textContent = 'Solution is incorrect. Keep trying!';
            }
        }
        
        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            game = new FaviconSudoku();
        });
    </script>
</body>
</html>
