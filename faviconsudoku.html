<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>6x6 Sudoku</title>
<style>
  body {
    font-family: Arial, sans-serif;
    max-width: 400px;
    margin: 20px auto;
    text-align: center;
  }
  table {
    border-collapse: collapse;
    margin: 0 auto 10px;
  }
  td {
    border: 1px solid #333;
    width: 40px;
    height: 40px;
    text-align: center;
    vertical-align: middle;
    font-size: 24px;
    position: relative;
  }
  input {
    width: 100%;
    height: 100%;
    border: none;
    text-align: center;
    font-size: 24px;
    font-weight: bold;
    background-color: transparent;
  }
  input:focus {
    outline: 2px solid #007bff;
  }
  /* Block borders for 2x3 blocks */
  td.block-right {
    border-right: 3px solid #000;
  }
  td.block-bottom {
    border-bottom: 3px solid #000;
  }
  button {
    margin: 5px;
    padding: 8px 16px;
    font-size: 16px;
  }
</style>
</head>
<body>

<h1>6x6 Sudoku</h1>

<table id="sudoku-grid"></table>

<button id="generate-btn">Generate New Puzzle</button>
<button id="solve-btn">Solve Puzzle</button>

<script>
  // Paste your Sudoku6x6 class here, or import it if separate
  class Sudoku6x6 {
    constructor() {
      this.size = 6;
      this.blockRows = 2;
      this.blockCols = 3;
      this.nums = [1, 2, 3, 4, 5, 6];
    }
    shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }
    isSafe(board, row, col, num) {
      for (let i = 0; i < this.size; i++) {
        if (board[row][i] === num) return false;
        if (board[i][col] === num) return false;
      }
      const startRow = row - (row % this.blockRows);
      const startCol = col - (col % this.blockCols);
      for (let r = 0; r < this.blockRows; r++) {
        for (let c = 0; c < this.blockCols; c++) {
          if (board[startRow + r][startCol + c] === num) return false;
        }
      }
      return true;
    }
    solve(board, countSolutions = false, limit = 2) {
      let solutions = 0;
      const helper = () => {
        for (let r = 0; r < this.size; r++) {
          for (let c = 0; c < this.size; c++) {
            if (board[r][c] === 0) {
              for (let num of this.nums) {
                if (this.isSafe(board, r, c, num)) {
                  board[r][c] = num;
                  if (helper()) return true;
                  board[r][c] = 0;
                }
              }
              return false;
            }
          }
        }
        solutions++;
        if (!countSolutions) return true;
        return solutions >= limit;
      };
      const result = helper();
      if (countSolutions) return solutions;
      return result;
    }
    generateSudoku(clues = 15, asString = false) {
      let board = Array.from({ length: this.size }, () =>
        Array(this.size).fill(0)
      );
      this.solve(board);
      let cells = [];
      for (let r = 0; r < this.size; r++) {
        for (let c = 0; c < this.size; c++) {
          cells.push([r, c]);
        }
      }
      this.shuffle(cells);
      let cluesLeft = this.size * this.size;
      for (let [r, c] of cells) {
        if (cluesLeft <= clues) break;
        let backup = board[r][c];
        board[r][c] = 0;
        const boardCopy = board.map(row => row.slice());
        const solutions = this.solve(boardCopy, true, 2);
        if (solutions !== 1) {
          board[r][c] = backup;
        } else {
          cluesLeft--;
        }
      }
      return asString ? this.convertToString(board) : board;
    }
    convertToString(board) {
      return board.flat().map(n => (n === 0 ? "." : n)).join("");
    }
    convertToArray(s) {
      if (s.length !== this.size * this.size)
        throw new Error("Input string length must be 36");
      let board = [];
      for (let i = 0; i < this.size; i++) {
        let row = [];
        for (let j = 0; j < this.size; j++) {
          const ch = s[i * this.size + j];
          if (ch === "." || ch === "0") row.push(0);
          else {
            const n = parseInt(ch, 10);
            if (n < 1 || n > 6) throw new Error("Invalid digit in input");
            row.push(n);
          }
        }
        board.push(row);
      }
      return board;
    }
    solveFromString(s) {
      const board = this.convertToArray(s);
      if (this.solve(board)) return board;
      else throw new Error("No solution found");
    }
    solveFromArray(board) {
      const copy = board.map(row => row.slice());
      if (this.solve(copy)) return copy;
      else throw new Error("No solution found");
    }
  }

  const sudoku = new Sudoku6x6();

  const grid = document.getElementById("sudoku-grid");
  let currentPuzzle = [];

  // Create grid inputs
  function createGrid() {
    grid.innerHTML = "";
    for (let r = 0; r < sudoku.size; r++) {
      const row = document.createElement("tr");
      for (let c = 0; c < sudoku.size; c++) {
        const cell = document.createElement("td");
        // Add thick borders for blocks
        if ((c + 1) % sudoku.blockCols === 0 && c !== sudoku.size - 1)
          cell.classList.add("block-right");
        if ((r + 1) % sudoku.blockRows === 0 && r !== sudoku.size - 1)
          cell.classList.add("block-bottom");

        const input = document.createElement("input");
        input.type = "text";
        input.maxLength = 1;
        input.dataset.row = r;
        input.dataset.col = c;
        input.autocomplete = "off";
        input.pattern = "[1-6]";
        input.inputMode = "numeric";

        // Allow only numbers 1-6 on input
        input.addEventListener("input", (e) => {
          let val = e.target.value;
          if (!/^[1-6]$/.test(val)) {
            e.target.value = "";
          }
        });

        cell.appendChild(input);
        row.appendChild(cell);
      }
      grid.appendChild(row);
    }
  }

  // Fill grid with puzzle numbers, disable inputs for clues
  function fillGrid(puzzle) {
    currentPuzzle = puzzle.map(row => row.slice());
    for (let r = 0; r < sudoku.size; r++) {
      for (let c = 0; c < sudoku.size; c++) {
        const input = grid.rows[r].cells[c].firstChild;
        input.value = puzzle[r][c] === 0 ? "" : puzzle[r][c];
        input.disabled = puzzle[r][c] !== 0;
        input.style.color = puzzle[r][c] !== 0 ? "black" : "#007bff";
      }
    }
  }

  // Read user inputs into board array
  function readGrid() {
    let board = [];
    for (let r = 0; r < sudoku.size; r++) {
      let row = [];
      for (let c = 0; c < sudoku.size; c++) {
        const val = grid.rows[r].cells[c].firstChild.value;
        row.push(val === "" ? 0 : parseInt(val, 10));
      }
      board.push(row);
    }
    return board;
  }

  // Check if user's solution is correct
  function checkSolution() {
    const userBoard = readGrid();
    try {
      if (sudoku.solveFromArray(userBoard)) {
        alert("Congratulations! The solution is valid.");
      } else {
        alert("The solution is not correct.");
      }
    } catch {
      alert("The solution is not correct.");
    }
  }

  // Solve current puzzle and fill grid with solution
  function solvePuzzle() {
    try {
      const solved = sudoku.solveFromArray(currentPuzzle);
      fillGrid(solved);
      // Disable all inputs after solving
      for (let r = 0; r < sudoku.size; r++) {
        for (let c = 0; c < sudoku.size; c++) {
          grid.rows[r].cells[c].firstChild.disabled = true;
          grid.rows[r].cells[c].firstChild.style.color = "black";
        }
      }
    } catch (e) {
      alert("No solution found!");
    }
  }

  // Generate new puzzle and fill grid
  function generatePuzzle() {
    const puzzle = sudoku.generateSudoku(15);
    fillGrid(puzzle);
  }

  document.getElementById("generate-btn").addEventListener("click", generatePuzzle);
  document.getElementById("solve-btn").addEventListener("click", solvePuzzle);

  // Initialize grid and puzzle on page load
  createGrid();
  generatePuzzle();
</script>

</body>
</html>
