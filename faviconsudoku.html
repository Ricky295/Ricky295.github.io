<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>6x6 Sudoku Favicon</title>
<link id="favicon" rel="icon" type="image/png" href="">
<style>
  body {
    font-family: monospace;
    padding: 1rem;
  }
  #controls {
    margin-bottom: 1rem;
  }
  #timer {
    font-weight: bold;
  }
</style>
</head>
<body>

<div id="controls">
  <label for="cluesRange">Clues: <span id="cluesCount">15</span></label>
  <input id="cluesRange" type="range" min="10" max="20" value="15" />
  <button id="generateBtn">Generate</button>
  <button id="checkBtn">Check</button>
  <span> Timer: <span id="timer">00:00</span></span>
</div>

<div>
  <small>Use keys 1-6 to fill cell. Shift+1-6 to toggle candidates.</small><br/>
  <small>Arrow keys to move. Enter to check solution.</small>
</div>

<script src="sudoku6x6.js"></script> <!-- your sudoku lib -->
<script>
  
(() => {
  const SIZE = 6;
  const CELL_SIZE = 5;
  const FAVICON_SIZE = 32;

  const canvas = document.createElement('canvas');
  canvas.width = FAVICON_SIZE;
  canvas.height = FAVICON_SIZE;
  const ctx = canvas.getContext('2d');

  const faviconLink = document.getElementById('favicon');

  // Sudoku state
  let puzzle = null;
  let solution = null;
  let userBoard = null;
  let candidates = null;
  let selectedCell = {r: 0, c: 0};
  let cluesCount = 15;

  // Timer
  let startTime = null;
  let timerInterval = null;

  // Local storage key
  const STORAGE_KEY = 'favicon6x6_besttimes';

  // Helper functions
  function createEmptyCandidates() {
    return Array.from({length: SIZE}, () => Array.from({length: SIZE}, () => new Set()));
  }

  function cloneBoard(board) {
    return board.map(row => row.slice());
  }

  function isCellGiven(r, c) {
    return puzzle[r][c] !== 0;
  }

  // Drawing functions
  function drawGrid() {
    ctx.fillStyle = '#fff';
    ctx.fillRect(0, 0, FAVICON_SIZE, FAVICON_SIZE);

    for(let r=0; r<SIZE; r++){
      for(let c=0; c<SIZE; c++){
        const x = c * CELL_SIZE + Math.floor(c/3);
        const y = r * CELL_SIZE + Math.floor(r/2);
        ctx.fillStyle = (selectedCell.r === r && selectedCell.c === c) ? '#fffbcc' : '#fff';
        ctx.fillRect(x, y, CELL_SIZE, CELL_SIZE);

        ctx.strokeStyle = '#444';
        ctx.lineWidth = 1;
        ctx.strokeRect(x, y, CELL_SIZE, CELL_SIZE);
      }
    }

    ctx.strokeStyle = '#000';
    ctx.lineWidth = 2;
    [2,4].forEach(row => {
      const y = row * CELL_SIZE + Math.floor(row/2);
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(FAVICON_SIZE, y);
      ctx.stroke();
    });
    [3].forEach(col => {
      const x = col * CELL_SIZE + Math.floor(col/3);
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, FAVICON_SIZE);
      ctx.stroke();
    });
  }

  function drawDigit(r, c, digit, given=false) {
    if(digit === 0) return;
    const x = c * CELL_SIZE + Math.floor(c/3);
    const y = r * CELL_SIZE + Math.floor(r/2);
    ctx.fillStyle = given ? '#000' : '#333';
    ctx.font = 'bold 4px monospace';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(digit, x + CELL_SIZE/2, y + CELL_SIZE/2 + 0.5);
  }

  function drawCandidates(r, c, candidateSet) {
    if(candidateSet.size === 0) return;
    const x = c * CELL_SIZE + Math.floor(c/3);
    const y = r * CELL_SIZE + Math.floor(r/2);

    const positions = [
      [1,1], [3,1],
      [1,2], [3,2],
      [1,3], [3,3]
    ];

    ctx.fillStyle = '#999';
    ctx.font = '3px monospace';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    [...candidateSet].sort().forEach((digit, idx) => {
      if(idx >= 6) return;
      const [dx, dy] = positions[idx];
      ctx.fillText(digit, x + dx, y + dy);
    });
  }

  function render() {
    drawGrid();
    for(let r=0; r<SIZE; r++){
      for(let c=0; c<SIZE; c++){
        const given = isCellGiven(r,c);
        if(userBoard[r][c] !== 0) {
          drawDigit(r, c, userBoard[r][c], given);
        } else if(candidates[r][c].size > 0) {
          drawCandidates(r, c, candidates[r][c]);
        }
      }
    }
    updateFavicon();
  }

  function updateFavicon() {
    const url = canvas.toDataURL('image/png');
    if(faviconLink) {
      faviconLink.href = url;
    } else {
      const link = document.createElement('link');
      link.id = 'favicon';
      link.rel = 'icon';
      link.type = 'image/png';
      link.href = url;
      document.head.appendChild(link);
    }
  }

  // Input handlers
  function selectCell(r,c) {
    if(r<0) r=0; if(r>=SIZE) r=SIZE-1;
    if(c<0) c=0; if(c>=SIZE) c=SIZE-1;
    selectedCell = {r,c};
    render();
  }

  function clearCandidatesAt(r,c) {
    candidates[r][c].clear();
  }

  function toggleCandidate(r,c, digit) {
    if(candidates[r][c].has(digit)) {
      candidates[r][c].delete(digit);
    } else {
      candidates[r][c].add(digit);
    }
  }

  function setCellValue(r,c,digit) {
    if(isCellGiven(r,c)) return;
    userBoard[r][c] = digit;
    clearCandidatesAt(r,c);
  }

  function onKeyDown(e) {
    if(document.activeElement.tagName === 'INPUT') return;

    const r = selectedCell.r;
    const c = selectedCell.c;

    switch(e.key) {
      case "ArrowUp": selectCell(r-1,c); e.preventDefault(); return;
      case "ArrowDown": selectCell(r+1,c); e.preventDefault(); return;
      case "ArrowLeft": selectCell(r,c-1); e.preventDefault(); return;
      case "ArrowRight": selectCell(r,c+1); e.preventDefault(); return;
      case "Enter": checkSolution(); e.preventDefault(); return;
      case "Backspace":
      case "Delete":
      case "0":
        if(isCellGiven(r,c)) return;
        userBoard[r][c] = 0;
        clearCandidatesAt(r,c);
        render();
        e.preventDefault();
        return;
    }

    if(e.key >= '1' && e.key <= '6') {
      const digit = parseInt(e.key);
      if(e.shiftKey) {
        if(isCellGiven(r,c)) return;
        toggleCandidate(r,c,digit);
      } else {
        setCellValue(r,c,digit);
        selectCell(r, c+1);
      }
      render();
      e.preventDefault();
    }
  }

  // Puzzle generation
  function generateNewPuzzle() {
    cluesCount = parseInt(document.getElementById('cluesRange').value);
    document.getElementById('cluesCount').textContent = cluesCount;

    puzzle = sudoku.generateSudoku(cluesCount);  // from sudoku6x6.js
    solution = sudoku.solveFromArray(puzzle);     // from sudoku6x6.js

    userBoard = cloneBoard(puzzle);
    candidates = createEmptyCandidates();
    selectCell(0,0);

    startTimer();
    render();
  }

  // Timer
  function startTimer() {
    startTime = Date.now();
    clearInterval(timerInterval);
    timerInterval = setInterval(() => {
      const elapsed = Math.floor((Date.now() - startTime) / 1000);
      const m = String(Math.floor(elapsed/60)).padStart(2,'0');
      const s = String(elapsed % 60).padStart(2,'0');
      document.getElementById('timer').textContent = `${m}:${s}`;
    }, 1000);
  }

  function checkSolution() {
    // Check if userBoard matches solution exactly
    for(let r=0; r<SIZE; r++) {
      for(let c=0; c<SIZE; c++) {
        if(userBoard[r][c] !== solution[r][c]) {
          alert("Incorrect or incomplete solution.");
          return false;
        }
      }
    }
    clearInterval(timerInterval);
    alert("Congratulations! Puzzle solved.");
    return true;
  }

  // Event listeners
  document.getElementById('generateBtn').addEventListener('click', generateNewPuzzle);
  document.getElementById('checkBtn').addEventListener('click', checkSolution);
  document.getElementById('cluesRange').addEventListener('input', (e) => {
    document.getElementById('cluesCount').textContent = e.target.value;
  });

  window.addEventListener('keydown', onKeyDown);

  // Initialize
  generateNewPuzzle();

})();
</script>

</body>
</html>
