<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DuoDoku Constructor</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 1400px;
      margin: 0 auto;
      padding: 15px;
      color: #eeeeee;
      background-color: #1a1a1a;
    }
    
    h1 {
      text-align: center;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 20px;
    }
    
    .info-box {
      text-align: center;
      margin: 10px 0;
      padding: 10px;
      background-color: #333;
      border-radius: 5px;
      font-size: 14px;
    }
    
    .container {
      display: flex;
      flex-direction: row;
      gap: 20px;
      justify-content: center;
      align-items: flex-start;
    }
    
    table {
      border-collapse: collapse;
    }
    
    td {
      width: 50px;
      height: 50px;
      text-align: center;
      border: 1px solid #eeeeee;
      font-size: 24px;
      cursor: pointer;
    }
    
    td:nth-child(4n) { border-right: 3px solid #eeeeee; }
    td:nth-child(1) { border-left: 3px solid #eeeeee; }
    tr:nth-child(2n) td { border-bottom: 3px solid #eeeeee; }
    tr:nth-child(1) td { border-top: 3px solid #eeeeee; }
    
    .cell-div {
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: #1a1a1a;
      position: relative;
    }
    
    .selected-cell {
      outline: 2px solid #0066cc;
    }
    
    .redundant {
      border-radius: 50%;
      border: 3px solid #0066cc;
    }
    
    .candidates {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      grid-template-rows: repeat(2, 1fr);
      width: 100%;
      height: 100%;
      font-size: 10px;
      color: #666;
    }
    
    .candidate {
      display: flex;
      justify-content: center;
      align-items: center;
    }
    
    .controls {
      display: flex;
      flex-direction: column;
      gap: 15px;
      min-width: 250px;
    }
    
    .summary-panel {
      background-color: #333;
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 15px;
    }
    
    .summary-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 8px 0;
      font-size: 14px;
    }
    
    .summary-label {
      font-weight: bold;
    }
    
    .difficulty-bar {
      width: 100px;
      height: 20px;
      background: linear-gradient(to right, #4CAF50, #FFEB3B, #FF9800, #F44336);
      border-radius: 10px;
      position: relative;
      margin: 5px 0;
    }
    
    .difficulty-indicator {
      position: absolute;
      top: -2px;
      width: 4px;
      height: 24px;
      background-color: #000;
      border-radius: 2px;
    }
    
    .technique-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 2px;
      margin: 5px 0;
    }
    
    .technique-cell {
      width: 20px;
      height: 15px;
      border: 1px solid #666;
      background-color: #555;
    }
    
    .technique-cell.used { background-color: #4CAF50; }
    .technique-cell.medium { background-color: #FFEB3B; }
    .technique-cell.hard { background-color: #FF9800; }
    .technique-cell.unfair { background-color: #F44336; }
    
    .numpad {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
    }
    
    .btn {
      padding: 12px;
      font-size: 16px;
      cursor: pointer;
      background-color: #f2f2f2;
      border: 1px solid #ccc;
      color: #1a1a1a;
      border-radius: 5px;
      text-align: center;
    }
    
    .btn:active { background-color: #d9d9d9; }
    
    .btn-group {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    
    .btn-clear { background-color: #ffcccc; }
    .btn-analyze { background-color: #ccffcc; }
    .btn-export { background-color: #cceeff; }
    
    .paste-input {
      width: 100%;
      padding: 8px;
      font-size: 14px;
      border: 1px solid #666;
      border-radius: 5px;
      background-color: #333;
      color: #eee;
      margin-bottom: 10px;
    }
    
    .status {
      font-weight: bold;
      padding: 10px;
      border-radius: 5px;
      text-align: center;
    }
    
    .status.unique { background-color: #d4edda; color: #155724; }
    .status.multiple { background-color: #fff3cd; color: #856404; }
    .status.none { background-color: #f8d7da; color: #721c24; }
    
    @media (max-width: 768px) {
      .container {
        flex-direction: column;
        align-items: center;
      }
      
      td {
        width: 40px;
        height: 40px;
        font-size: 20px;
      }
      
      .controls {
        width: 100%;
        max-width: 400px;
      }
      
      .numpad {
        grid-template-columns: repeat(4, 1fr);
      }
    }
  </style>
</head>
<body>
  <h1>DuoDoku Constructor</h1>
  
  <div class="info-box">
    <strong>Rules:</strong> Use digits 1–4 exactly twice per row, column, and 2×4 box. No same digits may touch orthogonally.
  </div>
  
  <div class="container">
    <div>
      <table id="puzzleTable"></table>
      <div class="info-box">
        <div>Givens: <span id="givens">0</span>/64</div>
        <div>Solutions: <span id="solutions">Unknown</span></div>
      </div>
    </div>
    
    <div class="controls">
      <!-- Summary Panel -->
      <div class="summary-panel">
        <div class="summary-row">
          <span class="summary-label">Number of solutions:</span>
          <span id="solutionCount">1</span>
        </div>
        <div class="summary-row">
          <span class="summary-label">Given digits:</span>
          <span id="givenDigits">22</span>
        </div>
        <div class="summary-row">
          <span class="summary-label">Tediousness:</span>
          <div class="difficulty-bar">
            <div class="difficulty-indicator" id="difficultyIndicator" style="left: 25%;"></div>
          </div>
        </div>
        <div class="summary-row">
          <span class="summary-label">Techniques:</span>
          <div class="technique-grid" id="techniqueGrid">
            <!-- Will be populated by JavaScript -->
          </div>
        </div>
        <div class="summary-row">
          <span class="summary-label">Difficulty:</span>
          <span id="difficultyText">Easy</span>
        </div>
      </div>

      <!-- Paste Input -->
      <input type="text" class="paste-input" id="pasteInput" placeholder="Paste 64-character puzzle string (0 for empty cells)">
      <div class="btn btn-analyze" id="pastePuzzle">Paste Puzzle</div>
      
      <div class="numpad">
        <div class="btn" data-value="1">1</div>
        <div class="btn" data-value="2">2</div>
        <div class="btn" data-value="3">3</div>
        <div class="btn" data-value="4">4</div>
      </div>
      
      <div class="btn-group">
        <div class="btn btn-clear" id="clear">Clear</div>
        <div class="btn btn-analyze" id="analyze">Analyze</div>
        <div class="btn" id="showCandidates">Show Candidates</div>
        <div class="btn" id="findRedundant">Find Redundant</div>
        <div class="btn" id="getHint">Get Hint</div>
        <div class="btn btn-export" id="exportPlay">Export to Play</div>
        <div class="btn btn-export" id="copyString">Copy String</div>
        <div class="btn" id="clearAll">Clear All</div>
      </div>
      
      <div id="status" class="status"></div>
    </div>
  </div>

  <script>
    // Include the DuoDoku Difficulties implementation
    const Difficulty = {
        EASY: 1,
        MEDIUM: 2, 
        HARD: 3,
        UNFAIR: 4
    };

    const blocks = [
        [[0, 0], [0, 1], [0, 2], [0, 3], [1, 0], [1, 1], [1, 2], [1, 3]], // block0
        [[0, 4], [0, 5], [0, 6], [0, 7], [1, 4], [1, 5], [1, 6], [1, 7]], // block1
        [[2, 0], [2, 1], [2, 2], [2, 3], [3, 0], [3, 1], [3, 2], [3, 3]], // block2
        [[2, 4], [2, 5], [2, 6], [2, 7], [3, 4], [3, 5], [3, 6], [3, 7]], // block3
        [[4, 0], [4, 1], [4, 2], [4, 3], [5, 0], [5, 1], [5, 2], [5, 3]], // block4
        [[4, 4], [4, 5], [4, 6], [4, 7], [5, 4], [5, 5], [5, 6], [5, 7]], // block5
        [[6, 0], [6, 1], [6, 2], [6, 3], [7, 0], [7, 1], [7, 2], [7, 3]], // block6
        [[6, 4], [6, 5], [6, 6], [6, 7], [7, 4], [7, 5], [7, 6], [7, 7]]  // block7
    ];

    function rG(b, j) {
        return blocks[b][j][0];
    }

    function cG(b, j) {
        return blocks[b][j][1];
    }

    // Simplified DuoDoKu Generator for validation
    class DuoDoKuGenerator {
      isNotDuplicated(row, col, num, grid) {
        // Check row constraint (max 2 of each digit)
        let rowCount = 0;
        for (let c = 0; c < 8; c++) {
          if (grid[row][c] === num) rowCount++;
        }
        if (rowCount >= 2) return false;
        
        // Check column constraint
        let colCount = 0;
        for (let r = 0; r < 8; r++) {
          if (grid[r][col] === num) colCount++;
        }
        if (colCount >= 2) return false;
        
        // Check 2x4 box constraint
        const boxRow = Math.floor(row / 2) * 2;
        const boxCol = Math.floor(col / 4) * 4;
        let boxCount = 0;
        for (let r = 0; r < 2; r++) {
          for (let c = 0; c < 4; c++) {
            if (grid[boxRow + r][boxCol + c] === num) boxCount++;
          }
        }
        if (boxCount >= 2) return false;
        
        // Check adjacent constraint
        const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
        for (const [dr, dc] of directions) {
          const newRow = row + dr;
          const newCol = col + dc;
          if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
            if (grid[newRow][newCol] === num) return false;
          }
        }
        
        return true;
      }
    }

    // Include DuoDoku Difficulties class (condensed version)
    class duodokudifficulties {
        constructor() {
            this.smartHint = false;
            this.hintString = "";
            this.techniquesUsed = {
                fullHouse: 0,
                lastTwin: 0,
                hiddenSingle: 0,
                hiddenTwin: 0,
                nakedSingle: 0,
                almostHiddenTwin: 0,
                combinations: 0
            };
        }

        refreshCandidates(x, ps) {
            const gen = new DuoDoKuGenerator(); 
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (x[r][c] !== 0) continue;
                    const toRemove = [];
                    for (const candidate of ps[r][c]) {
                        if (!gen.isNotDuplicated(r, c, candidate, x)) {
                            toRemove.push(candidate);
                        }
                    }
                    ps[r][c] = ps[r][c].filter(candidate => !toRemove.includes(candidate));
                }
            }
        }

        fullHouse(x, ps) {
            // Row
            for (let r = 0; r < 8; r++) {
                let house = [1, 1, 2, 2, 3, 3, 4, 4];
                let cIndex = -1;
                for (let c = 0; c < 8; c++) {
                    if (x[r][c] !== 0) {
                        const index = house.indexOf(x[r][c]);
                        if (index > -1) house.splice(index, 1);
                    } else {
                        cIndex = c;
                    }
                }
                if (house.length === 1) {
                    if (!this.smartHint) {
                        x[r][cIndex] = house[0];
                        this.refreshCandidates(x, ps);
                        this.techniquesUsed.fullHouse++;
                    } else {
                        this.hintString = `Last digit in Row ${r + 1}. Missing digit ${house[0]}.`;
                    }
                    return true;
                }
            }

            // Similar for columns and blocks...
            return false;
        }

        hiddenSingle(x, ps) {
            // Implementation similar to original but tracking techniques
            for (let r = 0; r < 8; r++) {
                const cIndices = Array.from({ length: 4 }, () => []);
                for (let c = 0; c < 8; c++) {
                    if (x[r][c] !== 0) continue;
                    for (const candidate of ps[r][c]) {
                        cIndices[candidate - 1].push(c);
                    }
                }
                for (let j = 0; j < 4; j++) {
                    if (cIndices[j].length === 1) {
                        if (!this.smartHint) {
                            x[r][cIndices[j][0]] = j + 1;
                            this.refreshCandidates(x, ps);
                            this.techniquesUsed.hiddenSingle++;
                        } else {
                            this.hintString = `Hidden single in Row ${r + 1}. Digit ${j + 1} in C${cIndices[j][0] + 1}.`;
                        }
                        return true;
                    }
                }
            }
            return false;
        }

        nakedSingle(x, ps) {
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (x[r][c] !== 0) continue;
                    if (ps[r][c].length === 1) {
                        if (!this.smartHint) {
                            x[r][c] = ps[r][c][0];
                            this.refreshCandidates(x, ps);
                            this.techniquesUsed.nakedSingle++;
                        } else {
                            this.hintString = `Naked single at R${r + 1}C${c + 1}, digit ${ps[r][c][0]}.`;
                        }
                        return true;
                    }
                }
            }
            return false;
        }

        // Simplified solve method
        solve(x, ps) {
            const originalSmartHint = this.smartHint;
            this.smartHint = false;
            this.techniquesUsed = {
                fullHouse: 0,
                lastTwin: 0,
                hiddenSingle: 0,
                hiddenTwin: 0,
                nakedSingle: 0,
                almostHiddenTwin: 0,
                combinations: 0
            };
            
            let difficulty = Difficulty.EASY;
            let maxIterations = 100;
            let iterations = 0;

            while (iterations < maxIterations) {
                iterations++;
                let progress = false;

                if (this.fullHouse(x, ps)) {
                    progress = true;
                    continue;
                }
                if (this.hiddenSingle(x, ps)) {
                    progress = true;
                    continue;
                }
                if (this.nakedSingle(x, ps)) {
                    if (difficulty < Difficulty.MEDIUM) {
                        difficulty = Difficulty.MEDIUM;
                    }
                    progress = true;
                    continue;
                }

                if (!progress) break;
            }

            this.smartHint = originalSmartHint;

            // Check if puzzle is complete
            let isComplete = true;
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (x[r][c] === 0) {
                        isComplete = false;
                        break;
                    }
                }
                if (!isComplete) break;
            }

            return isComplete ? difficulty : Difficulty.UNFAIR;
        }

        getStep(x, ps) {
            this.smartHint = true;
            
            if (this.fullHouse(x, ps)) return true;
            if (this.hiddenSingle(x, ps)) return true;
            if (this.nakedSingle(x, ps)) return true;
            
            this.hintString = "No more basic techniques available.";
            return false;
        }
    }
    
    // Simplified DuoDoKu Solver
    class SimpleSolver {
      constructor() {
        this.solutions = [];
        this.maxSolutions = 1000;
      }
      
      solve(grid) {
        this.solutions = [];
        this.grid = grid.map(row => [...row]);
        this.backtrack(0, 0);
        return this.solutions;
      }
      
      backtrack(row, col) {
        if (this.solutions.length >= this.maxSolutions) return;
        
        if (row === 8) {
          this.solutions.push(this.grid.map(row => [...row]));
          return;
        }
        
        const [nextRow, nextCol] = col === 7 ? [row + 1, 0] : [row, col + 1];
        
        if (this.grid[row][col] !== 0) {
          this.backtrack(nextRow, nextCol);
          return;
        }
        
        for (let num = 1; num <= 4; num++) {
          if (this.isValid(row, col, num)) {
            this.grid[row][col] = num;
            this.backtrack(nextRow, nextCol);
            this.grid[row][col] = 0;
          }
        }
      }
      
      isValid(row, col, num) {
        // Check row constraint (max 2 of each digit)
        let rowCount = 0;
        for (let c = 0; c < 8; c++) {
          if (this.grid[row][c] === num) rowCount++;
        }
        if (rowCount >= 2) return false;
        
        // Check column constraint
        let colCount = 0;
        for (let r = 0; r < 8; r++) {
          if (this.grid[r][col] === num) colCount++;
        }
        if (colCount >= 2) return false;
        
        // Check 2x4 box constraint
        const boxRow = Math.floor(row / 2) * 2;
        const boxCol = Math.floor(col / 4) * 4;
        let boxCount = 0;
        for (let r = 0; r < 2; r++) {
          for (let c = 0; c < 4; c++) {
            if (this.grid[boxRow + r][boxCol + c] === num) boxCount++;
          }
        }
        if (boxCount >= 2) return false;
        
        // Check adjacent constraint
        const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
        for (const [dr, dc] of directions) {
          const newRow = row + dr;
          const newCol = col + dc;
          if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
            if (this.grid[newRow][newCol] === num) return false;
          }
        }
        
        return true;
      }
      
      getCandidates(row, col) {
        if (this.grid[row][col] !== 0) return [];
        
        const candidates = [];
        for (let num = 1; num <= 4; num++) {
          if (this.isValid(row, col, num)) {
            candidates.push(num);
          }
        }
        return candidates;
      }
    }
    
    // App state
    let grid = Array(8).fill().map(() => Array(8).fill(0));
    let selectedCell = null;
    let showingCandidates = false;
    let redundantCells = new Set();
    const solver = new SimpleSolver();
    const difficulty = new duodokudifficulties();
    
    // Initialize
    function init() {
      renderTable();
      setupEventListeners();
      updateStatus();
      initializeTechniqueGrid();
    }
    
    function initializeTechniqueGrid() {
      const grid = document.getElementById('techniqueGrid');
      // Create 25 cells (5x5 grid, but using 4x6 for better layout)
      for (let i = 0; i < 24; i++) {
        const cell = document.createElement('div');
        cell.className = 'technique-cell';
        grid.appendChild(cell);
      }
    }
    
    function updateTechniqueVisualization(techniques) {
      const cells = document.querySelectorAll('.technique-cell');
      
      // Reset all cells
      cells.forEach(cell => {
        cell.className = 'technique-cell';
      });
      
      // Color cells based on techniques used
      let cellIndex = 0;
      
      // Full House (Easy - Green)
      for (let i = 0; i < techniques.fullHouse && cellIndex < cells.length; i++) {
        cells[cellIndex++].classList.add('used');
      }
      
      // Hidden Single (Easy - Green)  
      for (let i = 0; i < techniques.hiddenSingle && cellIndex < cells.length; i++) {
        cells[cellIndex++].classList.add('used');
      }
      
      // Naked Single (Medium - Yellow)
      for (let i = 0; i < techniques.nakedSingle && cellIndex < cells.length; i++) {
        cells[cellIndex++].classList.add('medium');
      }
      
      // Other techniques would follow...
    }
    
    function renderTable() {
      const table = document.getElementById('puzzleTable');
      let html = '';
      
      for (let row = 0; row < 8; row++) {
        html += '<tr>';
        for (let col = 0; col < 8; col++) {
          const value = grid[row][col];
          const isRedundant = redundantCells.has(`${row}-${col}`);
          
          html += `
            <td>
              <div class="cell-div${isRedundant ? ' redundant' : ''}" 
                   data-row="${row}" data-col="${col}">
                ${value || ''}
                <div class="candidates" style="display: none">
                  <div class="candidate" data-value="1"></div>
                  <div class="candidate" data-value="2"></div>
                  <div class="candidate" data-value="3"></div>
                  <div class="candidate" data-value="4"></div>
                </div>
              </div>
            </td>`;
        }
        html += '</tr>';
      }
      
      table.innerHTML = html;
      setupCellListeners();
    }
    
    function setupCellListeners() {
      document.querySelectorAll('.cell-div').forEach(cell => {
        cell.addEventListener('click', function() {
          if (selectedCell) {
            selectedCell.classList.remove('selected-cell');
          }
          selectedCell = this;
          selectedCell.classList.add('selected-cell');
        });
      });
    }
    
    function setupEventListeners() {
      // Paste puzzle
      document.getElementById('pastePuzzle').addEventListener('click', function() {
        const puzzleString = document.getElementById('pasteInput').value.trim();
        if (puzzleString.length === 64) {
          for (let i = 0; i < 64; i++) {
            const row = Math.floor(i / 8);
            const col = i % 8;
            const digit = parseInt(puzzleString[i]) || 0;
            if (digit >= 0 && digit <= 4) {
              grid[row][col] = digit;
            }
          }
          renderTable();
          updateStatus();
          document.getElementById('status').textContent = 'Puzzle pasted successfully!';
          document.getElementById('status').className = 'status unique';
        } else {
          document.getElementById('status').textContent = 'Invalid puzzle string. Must be 64 characters.';
          document.getElementById('status').className = 'status none';
        }
      });
      
      // Numpad
      document.querySelectorAll('.numpad .btn').forEach(btn => {
        btn.addEventListener('click', function() {
          if (selectedCell) {
            const value = parseInt(this.dataset.value);
            const row = parseInt(selectedCell.dataset.row);
            const col = parseInt(selectedCell.dataset.col);
            
            grid[row][col] = grid[row][col] === value ? 0 : value;
            renderTable();
            updateStatus();
          }
        });
      });
      
      // Clear current cell
      document.getElementById('clear').addEventListener('click', function() {
        if (selectedCell) {
          const row = parseInt(selectedCell.dataset.row);
          const col = parseInt(selectedCell.dataset.col);
          grid[row][col] = 0;
          renderTable();
          updateStatus();
        }
      });
      
      // Analyze
      document.getElementById('analyze').addEventListener('click', analyze);
      
      // Get Hint
      document.getElementById('getHint').addEventListener('click', getHint);
      
      // Show candidates
      document.getElementById('showCandidates').addEventListener('click', toggleCandidates);
      
      // Find redundant
      document.getElementById('findRedundant').addEventListener('click', findRedundant);
      
      // Export
      document.getElementById('exportPlay').addEventListener('click', exportToPlay);
      document.getElementById('copyString').addEventListener('click', copyString);
      
      // Clear all
      document.getElementById('clearAll').addEventListener('click', function() {
        grid = Array(8).fill().map(() => Array(8).fill(0));
        redundantCells.clear();
        renderTable();
        updateStatus();
      });
      
      // Keyboard
      document.addEventListener('keydown', function(e) {
        if (!selectedCell) return;
        
        const row = parseInt(selectedCell.dataset.row);
        const col = parseInt(selectedCell.dataset.col);
        
        if (['1', '2', '3', '4'].includes(e.key)) {
          const value = parseInt(e.key);
          grid[row][col] = grid[row][col] === value ? 0 : value;
          renderTable();
          updateStatus();
        } else if (e.key === 'Delete' || e.key === 'Backspace') {
          grid[row][col] = 0;
          renderTable();
          updateStatus();
        }
      });
    }
    
    function updateStatus() {
      const givens = grid.flat().filter(x => x !== 0).length;
      document.getElementById('givens').textContent = givens;
      document.getElementById('givenDigits').textContent = givens;
    }
    
    function getHint() {
      // Create candidates array
      const candidates = Array(8).fill().map(() => Array(8).fill().map(() => [1, 2, 3, 4]));
      const testGrid = grid.map(row => [...row]);
      
      difficulty.refreshCandidates(testGrid, candidates);
      
      if (difficulty.getStep(testGrid, candidates)) {
        document.getElementById('status').textContent = difficulty.hintString;
        document.getElementById('status').className = 'status unique';
      } else {
        document.getElementById('status').textContent = 'No hints available with current techniques.';
        document.getElementById('status').className = 'status none';
      }
    }
    
    function analyze() {
      const solutions = solver.solve(grid);
      const count = solutions.length >= solver.maxSolutions ? `${solver.maxSolutions}+` : solutions.length;
      
      document.getElementById('solutions').textContent = count;
      document.getElementById('solutionCount').textContent = count;
      
      // Analyze difficulty if unique solution
      if (solutions.length === 1) {
        const candidates = Array(8).fill().map(() => Array(8).fill().map(() => [1, 2, 3, 4]));
        const testGrid = grid.map(row => [...row]);
        
        difficulty.refreshCandidates(testGrid, candidates);
        const finalDifficulty = difficulty.solve(testGrid, candidates);
        
        updateDifficultyDisplay(finalDifficulty);
        updateTechniqueVisualization(difficulty.techniquesUsed);
      } else {
        // Reset difficulty display for non-unique solutions
        updateDifficultyDisplay(Difficulty.UNFAIR);
        updateTechniqueVisualization({});
      }
      
      const status = document.getElementById('status');
      if (solutions.length === 0) {
        status.textContent = 'No valid solutions';
        status.className = 'status none';
      } else if (solutions.length === 1) {
        status.textContent = 'Unique solution!';
        status.className = 'status unique';
      } else {
        status.textContent = `Multiple solutions (${count})`;
        status.className = 'status multiple';
      }
    }
    
    function updateDifficultyDisplay(difficultyLevel) {
      const indicator = document.getElementById('difficultyIndicator');
      const text = document.getElementById('difficultyText');
      
      switch (difficultyLevel) {
        case Difficulty.EASY:
          indicator.style.left = '10%';
          text.textContent = 'Easy';
          break;
        case Difficulty.MEDIUM:
          indicator.style.left = '35%';
          text.textContent = 'Medium';
          break;
        case Difficulty.HARD:
          indicator.style.left = '65%';
          text.textContent = 'Hard';
          break;
        case Difficulty.UNFAIR:
          indicator.style.left = '90%';
          text.textContent = 'Unfair';
          break;
        default:
          indicator.style.left = '50%';
          text.textContent = 'Unknown';
      }
    }
    
    function toggleCandidates() {
      showingCandidates = !showingCandidates;
      const btn = document.getElementById('showCandidates');
      
      if (showingCandidates) {
        solver.grid = grid.map(row => [...row]);
        
        document.querySelectorAll('.cell-div').forEach(cell => {
          const row = parseInt(cell.dataset.row);
          const col = parseInt(cell.dataset.col);
          
          if (grid[row][col] === 0) {
            const candidates = solver.getCandidates(row, col);
            const candidatesDiv = cell.querySelector('.candidates');
            candidatesDiv.style.display = 'grid';
            
            candidatesDiv.querySelectorAll('.candidate').forEach(candEl => {
              const value = parseInt(candEl.dataset.value);
              candEl.textContent = candidates.includes(value) ? value : '';
            });
          }
        });
        
        btn.textContent = 'Hide Candidates';
      } else {
        document.querySelectorAll('.candidates').forEach(c => {
          c.style.display = 'none';
        });
        btn.textContent = 'Show Candidates';
      }
    }
    
    function findRedundant() {
      const solutions = solver.solve(grid);
      if (solutions.length !== 1) {
        alert('Must have exactly one solution to find redundant givens');
        return;
      }
      
      redundantCells.clear();
      
      // Test removing each given
      for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
          if (grid[row][col] !== 0) {
            const original = grid[row][col];
            grid[row][col] = 0;
            
            const testSolutions = solver.solve(grid);
            if (testSolutions.length === 1) {
              redundantCells.add(`${row}-${col}`);
            }
            
            grid[row][col] = original;
          }
        }
      }
      
      renderTable();
      
      if (redundantCells.size > 0) {
        document.getElementById('status').textContent = `Found ${redundantCells.size} redundant givens (circled)`;
        document.getElementById('status').className = 'status unique';
      } else {
        document.getElementById('status').textContent = 'No redundant givens found';
        document.getElementById('status').className = 'status none';
      }
    }
    
    function exportToPlay() {
      const puzzleString = grid.flat().join('');
      const url = `duodokuplay.html?puzzle=${puzzleString}&zoom=50`;
      window.open(url, '_blank');
    }
    
    function copyString() {
      const puzzleString = grid.flat().join('');
      navigator.clipboard.writeText(puzzleString).then(() => {
        document.getElementById('status').textContent = 'Puzzle string copied to clipboard!';
        document.getElementById('status').className = 'status unique';
      });
    }
    
    init();
