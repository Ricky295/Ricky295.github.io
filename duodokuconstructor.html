<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DuoDoKu Constructor</title>
  <script src="duodokudifficulties.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 15px;
      color: #eeeeee;
      background-color: #1a1a1a;
    }
    h1 {
      text-align: center;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 20px;
    }
    .info-box {
      text-align: center;
      margin: 10px 0;
      padding: 10px;
      background-color: #333;
      border-radius: 5px;
      font-size: 14px;
    }
    .container {
      display: flex;
      flex-direction: row;
      gap: 20px;
      justify-content: center;
      align-items: flex-start;
    }
    table {
      border-collapse: collapse;
    }
    td {
      width: 50px;
      height: 50px;
      text-align: center;
      border: 1px solid #eeeeee;
      font-size: 24px;
      cursor: pointer;
    }
    td:nth-child(4n) { border-right: 3px solid #eeeeee; }
    td:nth-child(1) { border-left: 3px solid #eeeeee; }
    tr:nth-child(2n) td { border-bottom: 3px solid #eeeeee; }
    tr:nth-child(1) td { border-top: 3px solid #eeeeee; }
    .cell-div {
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: #1a1a1a;
      position: relative;
    }
    .selected-cell {
      outline: 2px solid #0066cc;
    }
    .redundant {
      border-radius: 50%;
      border: 3px solid #0066cc;
    }
    .candidates {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      grid-template-rows: repeat(2, 1fr);
      width: 100%;
      height: 100%;
      font-size: 10px;
      color: #666;
    }
    .candidate {
      display: flex;
      justify-content: center;
      align-items: center;
    }
    .controls {
      display: flex;
      flex-direction: column;
      gap: 15px;
      min-width: 200px;
    }
    .numpad {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
    }
    .btn {
      padding: 12px;
      font-size: 16px;
      cursor: pointer;
      background-color: #f2f2f2;
      border: 1px solid #ccc;
      color: #1a1a1a;
      border-radius: 5px;
      text-align: center;
    }
    .btn:active { background-color: #d9d9d9; }
    .btn-group {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .btn-clear { background-color: #ffcccc; }
    .btn-analyze { background-color: #ccffcc; }
    .btn-export { background-color: #cceeff; }
    .status {
      font-weight: bold;
      padding: 10px;
      border-radius: 5px;
      text-align: center;
    }
    .status.unique { background-color: #d4edda; color: #155724; }
    .status.multiple { background-color: #fff3cd; color: #856404; }
    .status.none { background-color: #f8d7da; color: #721c24; }
    
    /* Difficulty Display */
    .difficulty-display {
      background-color: #2a2a2a;
      border-radius: 8px;
      padding: 15px;
      margin: 10px 0;
      text-align: center;
    }
    
    .difficulty-badge {
      display: inline-block;
      padding: 8px 16px;
      border-radius: 20px;
      font-weight: bold;
      font-size: 14px;
      margin-bottom: 10px;
    }
    
    .difficulty-1 { background-color: #28a745; color: white; }
    .difficulty-2 { background-color: #ffc107; color: #212529; }
    .difficulty-3 { background-color: #fd7e14; color: white; }
    .difficulty-4 { background-color: #dc3545; color: white; }
    .difficulty-unknown { background-color: #6c757d; color: white; }
    
    /* Technique Bar */
    .technique-bar-container {
      margin-top: 10px;
    }
    
    .technique-bar {
      height: 20px;
      border-radius: 10px;
      overflow: hidden;
      display: flex;
      border: 1px solid #555;
      background-color: #000;
    }
    
    .technique-segment {
      height: 100%;
      position: relative;
      transition: all 0.3s ease;
    }
    
    .technique-segment:hover {
      filter: brightness(1.2);
      cursor: pointer;
    }
    
    /* Technique Colors */
    .tech-fullhouse { background-color: #0066cc; }
    .tech-lasttwin { background-color: #4da6ff; }
    .tech-hiddensingle { background-color: #28a745; }
    .tech-nakedsingle { background-color: #ffc107; }
    .tech-hiddentwins { background-color: #fd7e14; }
    .tech-aht { background-color: #dc3545; }
    .tech-combinations { background-color: #800000; }
    .tech-unknown { background-color: #000000; }
    
    .technique-legend {
      margin-top: 8px;
      font-size: 12px;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 5px;
    }
    
    .legend-item {
      display: flex;
      align-items: center;
      gap: 5px;
    }
    
    .legend-color {
      width: 12px;
      height: 12px;
      border-radius: 2px;
      display: inline-block;
    }
    
    @media (max-width: 768px) {
      .container {
        flex-direction: column;
        align-items: center;
      }
      td {
        width: 40px;
        height: 40px;
        font-size: 20px;
      }
      .controls {
        width: 100%;
        max-width: 400px;
      }
      .numpad {
        grid-template-columns: repeat(4, 1fr);
      }
    }
  </style>
</head>
<body>
  <h1>Sufufu Constructor</h1>
  <div class="info-box">
    <strong>Rules:</strong> Use digits 1–4 exactly twice per row, column, and 2×4 box. No same digits may touch orthogonally.
  </div>
  <div class="container">
    <div>
      <table id="puzzleTable"></table>
      <div class="info-box">
        <div>Givens: <span id="givens">0</span>/64</div>
        <div>Solutions: <span id="solutions">Unknown</span></div>
      </div>
      
      <!-- Difficulty and Techniques Display -->
      <div class="difficulty-display">
        <div class="difficulty-badge difficulty-unknown" id="difficultyBadge">
          Difficulty: Unknown
        </div>
        <div class="technique-bar-container">
          <div class="technique-bar" id="techniqueBar"></div>
          <div class="technique-legend" id="techniqueLegend"></div>
        </div>
      </div>
    </div>
    <div class="controls">
      <div class="numpad">
        <div class="btn" data-value="1">1</div>
        <div class="btn" data-value="2">2</div>
        <div class="btn" data-value="3">3</div>
        <div class="btn" data-value="4">4</div>
      </div>
      <div class="btn-group">
        <div class="btn btn-clear" id="clear">Clear</div>
        <div class="btn btn-analyze" id="analyze">Analyze</div>
        <div class="btn" id="showCandidates">Show Candidates</div>
        <div class="btn" id="pastePuzzle">Paste Puzzle String</div>
        <div class="btn" id="findRedundant">Find Redundant</div>
        <div class="btn btn-export" id="exportPlay">Export to Play</div>
        <div class="btn btn-export" id="copyString">Copy String</div>
        <div class="btn" id="clearAll">Clear All</div>
      </div>
      <div id="status" class="status"></div>
    </div>
  </div>
  <script>
    // Mock DuoDoKuGenerator class for compatibility
    class DuoDoKuGenerator {
      isNotDuplicated(row, col, value, grid) {
        // Check row constraint
        let rowCount = 0;
        for (let c = 0; c < 8; c++) {
          if (grid[row][c] === value) rowCount++;
        }
        if (rowCount >= 2) return false;

        // Check column constraint  
        let colCount = 0;
        for (let r = 0; r < 8; r++) {
          if (grid[r][col] === value) colCount++;
        }
        if (colCount >= 2) return false;

        // Check block constraint
        const blockRow = Math.floor(row / 2) * 2;
        const blockCol = Math.floor(col / 4) * 4;
        let blockCount = 0;
        for (let r = 0; r < 2; r++) {
          for (let c = 0; c < 4; c++) {
            if (grid[blockRow + r][blockCol + c] === value) blockCount++;
          }
        }
        if (blockCount >= 2) return false;

        // Check adjacency constraint
        const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
        for (const [dr, dc] of directions) {
          const newRow = row + dr;
          const newCol = col + dc;
          if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8 && grid[newRow][newCol] === value) {
            return false;
          }
        }

        return true;
      }
    }

    // Simplified DuoDoKu Solver
    class SimpleSolver {
      constructor() {
        this.solutions = [];
        this.maxSolutions = 1000; // Limit for performance
      }
      solve(grid) {
        this.solutions = [];
        this.grid = grid.map(row => [...row]);
        this.backtrack(0, 0);
        return this.solutions;
      }
      backtrack(row, col) {
        if (this.solutions.length >= this.maxSolutions) return;
        if (row === 8) {
          this.solutions.push(this.grid.map(row => [...row]));
          return;
        }
        const [nextRow, nextCol] = col === 7 ? [row + 1, 0] : [row, col + 1];
        if (this.grid[row][col] !== 0) {
          this.backtrack(nextRow, nextCol);
          return;
        }
        for (let num = 1; num <= 4; num++) {
          if (this.isValid(row, col, num)) {
            this.grid[row][col] = num;
            this.backtrack(nextRow, nextCol);
            this.grid[row][col] = 0;
          }
        }
      }
      isValid(row, col, num) {
        // Check row constraint (max 2 of each digit)
        let rowCount = 0;
        for (let c = 0; c < 8; c++) {
          if (this.grid[row][c] === num) rowCount++;
        }
        if (rowCount >= 2) return false;
        // Check column constraint
        let colCount = 0;
        for (let r = 0; r < 8; r++) {
          if (this.grid[r][col] === num) colCount++;
        }
        if (colCount >= 2) return false;
        // Check 2x4 box constraint
        const boxRow = Math.floor(row / 2) * 2;
        const boxCol = Math.floor(col / 4) * 4;
        let boxCount = 0;
        for (let r = 0; r < 2; r++) {
          for (let c = 0; c < 4; c++) {
            if (this.grid[boxRow + r][boxCol + c] === num) boxCount++;
          }
        }
        if (boxCount >= 2) return false;
        // Check adjacent constraint
        const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
        for (const [dr, dc] of directions) {
          const newRow = row + dr;
          const newCol = col + dc;
          if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
            if (this.grid[newRow][newCol] === num) return false;
          }
        }
        return true;
      }
      
      // Helper function to check if a number is a candidate based on constraints only
      getPossibleCandidates(row, col) {
        if (this.grid[row][col] !== 0) return [];
        const candidates = [];
        for (let num = 1; num <= 4; num++) {
          if (this.isValid(row, col, num)) {
            candidates.push(num);
          }
        }
        return candidates;
      }
      
      // Function to get actual candidates from all solutions
      getActualCandidatesFromSolutions(row, col, solutions) {
        if (this.grid[row][col] !== 0 || solutions.length === 0) return [];
        
        const candidateSet = new Set();
        for (const solution of solutions) {
            candidateSet.add(solution[row][col]);
        }
        // Return sorted array of unique candidates found in solutions
        return Array.from(candidateSet).sort((a, b) => a - b);
      }
    }
    
    // App state
    let grid = Array(8).fill().map(() => Array(8).fill(0));
    let selectedCell = null;
    let showingCandidates = false;
    let redundantCells = new Set();
    const solver = new SimpleSolver();
    let lastAnalysisSolutions = []; // Store solutions from last analysis
    let techniqueStats = {}; // Store technique usage statistics
    
    // Initialize
    function init() {
      renderTable();
      setupEventListeners();
      updateStatus();
      analyzeDifficultyAndTechniques();
    }
    
    function renderTable() {
      const table = document.getElementById('puzzleTable');
      let html = '';
      for (let row = 0; row < 8; row++) {
        html += '<tr>';
        for (let col = 0; col < 8; col++) {
          const value = grid[row][col];
          const isRedundant = redundantCells.has(`${row}-${col}`);
          html += `
            <td>
              <div class="cell-div${isRedundant ? ' redundant' : ''}" 
                   data-row="${row}" data-col="${col}">
                ${value || ''}
                <div class="candidates" style="display: none">
                  <div class="candidate" data-value="1"></div>
                  <div class="candidate" data-value="2"></div>
                  <div class="candidate" data-value="3"></div>
                  <div class="candidate" data-value="4"></div>
                </div>
              </div>
            </td>`;
        }
        html += '</tr>';
      }
      table.innerHTML = html;
      setupCellListeners();
    }
    
    function setupCellListeners() {
      document.querySelectorAll('.cell-div').forEach(cell => {
        cell.addEventListener('click', function() {
          if (selectedCell) {
            selectedCell.classList.remove('selected-cell');
          }
          selectedCell = this;
          selectedCell.classList.add('selected-cell');
        });
      });
    }
    
    function setupEventListeners() {
      // Numpad
      document.querySelectorAll('.numpad .btn').forEach(btn => {
        btn.addEventListener('click', function() {
          if (selectedCell) {
            const value = parseInt(this.dataset.value);
            const row = parseInt(selectedCell.dataset.row);
            const col = parseInt(selectedCell.dataset.col);
            grid[row][col] = grid[row][col] === value ? 0 : value;
            renderTable();
            updateStatus();
            analyzeDifficultyAndTechniques();
          }
        });
      });
      // Clear current cell
      document.getElementById('clear').addEventListener('click', function() {
        if (selectedCell) {
          const row = parseInt(selectedCell.dataset.row);
          const col = parseInt(selectedCell.dataset.col);
          grid[row][col] = 0;
          renderTable();
          updateStatus();
          analyzeDifficultyAndTechniques();
        }
      });
      // Analyze
      document.getElementById('analyze').addEventListener('click', analyze);
      // Show candidates
      document.getElementById('showCandidates').addEventListener('click', toggleCandidates);
      // Paste Puzzle String
      document.getElementById('pastePuzzle').addEventListener('click', pasteString);
      // Find redundant
      document.getElementById('findRedundant').addEventListener('click', findRedundant);
      // Export
      document.getElementById('exportPlay').addEventListener('click', exportToPlay);
      document.getElementById('copyString').addEventListener('click', copyString);
      // Clear all
      document.getElementById('clearAll').addEventListener('click', function() {
        grid = Array(8).fill().map(() => Array(8).fill(0));
        redundantCells.clear();
        lastAnalysisSolutions = [];
        techniqueStats = {};
        renderTable();
        updateStatus();
        analyzeDifficultyAndTechniques();
      });
      // Keyboard
      document.addEventListener('keydown', function(e) {
        if (!selectedCell) return;
        const row = parseInt(selectedCell.dataset.row);
        const col = parseInt(selectedCell.dataset.col);
        if (['1', '2', '3', '4'].includes(e.key)) {
          const value = parseInt(e.key);
          grid[row][col] = grid[row][col] === value ? 0 : value;
          renderTable();
          updateStatus();
          analyzeDifficultyAndTechniques();
        } else if (e.key === 'Delete' || e.key === 'Backspace') {
          grid[row][col] = 0;
          renderTable();
          updateStatus();
          analyzeDifficultyAndTechniques();
        }
      });
    }
    
    function updateStatus() {
      const givens = grid.flat().filter(x => x !== 0).length;
      document.getElementById('givens').textContent = givens;
    }
    
    function analyze() {
      const solutions = solver.solve(grid);
      lastAnalysisSolutions = solutions; // Store solutions for candidate display
      const count = solutions.length >= solver.maxSolutions ? `${solver.maxSolutions}+` : solutions.length;
      document.getElementById('solutions').textContent = count;
      const status = document.getElementById('status');
      if (solutions.length === 0) {
        status.textContent = 'No valid solutions';
        status.className = 'status none';
      } else if (solutions.length === 1) {
        status.textContent = 'Unique solution!';
        status.className = 'status unique';
      } else {
        status.textContent = `Multiple solutions (${count})`;
        status.className = 'status multiple';
      }
      
      // Update difficulty and techniques
      analyzeDifficultyAndTechniques();
    }
    
    function analyzeDifficultyAndTechniques() {
      try {
        // Create copies for analysis
        const gridCopy = grid.map(row => [...row]);
        const candidatesCopy = initializeCandidatesArray();
        
        // Initialize difficulty analyzer
        const analyzer = new duodokudifficulties();
        analyzer.refreshCandidates(gridCopy, candidatesCopy);
        
        // Track techniques used
        techniqueStats = {
          fullHouse: 0,
          lastTwin: 0,
          hiddenSingle: 0,
          nakedSingle: 0,
          hiddenTwin: 0,
          almostHiddenTwin: 0,
          combinations: 0,
          unknown: 0
        };
        
        let difficulty = 1; // Start with EASY
        let stepsProcessed = 0;
        const maxSteps = 100; // Prevent infinite loops
        
        // Enable hint mode to track techniques
        analyzer.smartHint = true;
        
        // Count empty cells initially
        let emptyCells = 0;
        for (let r = 0; r < 8; r++) {
          for (let c = 0; c < 8; c++) {
            if (gridCopy[r][c] === 0) emptyCells++;
          }
        }
        
        // Simulate solving step by step
        while (stepsProcessed < maxSteps) {
          let stepFound = false;
          
          // Try each technique in order and actually apply the moves
          analyzer.smartHint = false; // Disable hint mode to actually make moves
          
          if (analyzer.fullHouse(gridCopy, candidatesCopy)) {
            techniqueStats.fullHouse++;
            stepFound = true;
          } else if (analyzer.lastTwin(gridCopy, candidatesCopy)) {
            techniqueStats.lastTwin++;
            stepFound = true;
          } else if (analyzer.hiddenSingle(gridCopy, candidatesCopy)) {
            techniqueStats.hiddenSingle++;
            stepFound = true;
          } else if (analyzer.hiddenTwin(gridCopy, candidatesCopy)) {
            techniqueStats.hiddenTwin++;
            if (difficulty < 2) difficulty = 2; // MEDIUM
            stepFound = true;
          } else if (analyzer.nakedSingle(gridCopy, candidatesCopy)) {
            techniqueStats.nakedSingle++;
            if (difficulty < 2) difficulty = 2; // MEDIUM
            stepFound = true;
          } else if (analyzer.almostHiddenTwin(gridCopy, candidatesCopy)) {
            techniqueStats.almostHiddenTwin++;
            if (difficulty < 3) difficulty = 3; // HARD
            stepFound = true;
          } else {
            // Try combinations
            let combinationFound = false;
            for (let size = 3; size <= 6; size++) {
              if (analyzer.combinations(gridCopy, candidatesCopy, size)) {
                techniqueStats.combinations++;
                if (difficulty < 3) difficulty = 3; // HARD
                combinationFound = true;
                stepFound = true;
                break;
              }
            }
            if (!combinationFound) {
              // Count remaining empty cells as "unknown"
              let currentEmpty = 0;
              for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                  if (gridCopy[r][c] === 0) currentEmpty++;
                }
              }
              if (currentEmpty > 0) {
                techniqueStats.unknown += currentEmpty;
                difficulty = 4; // UNFAIR
              }
              break;
            }
          }
          
          if (!stepFound) break;
          
          // After each successful technique, refresh candidates
          // This is automatically done by the technique methods when smartHint = false
          
          stepsProcessed++;
        }
        
        updateDifficultyDisplay(difficulty);
        updateTechniqueBar();
        
      } catch (error) {
        console.error('Error analyzing difficulty and techniques:', error);
        document.getElementById('difficultyBadge').textContent = 'Difficulty: Error';
        document.getElementById('difficultyBadge').className = 'difficulty-badge difficulty-unknown';
      }
    }
    
    function initializeCandidatesArray() {
      const candidates = [];
      for (let r = 0; r < 8; r++) {
        candidates[r] = [];
        for (let c = 0; c < 8; c++) {
          if (grid[r][c] === 0) {
            candidates[r][c] = [1, 2, 3, 4];
          } else {
            candidates[r][c] = [];
          }
        }
      }
      return candidates;
    }
    
    function updateDifficultyDisplay(difficulty) {
      const difficultyNames = {
        1: 'EASY',
        2: 'MEDIUM', 
        3: 'HARD',
        4: 'UNFAIR'
      };
      
      const badge = document.getElementById('difficultyBadge');
      badge.textContent = `Difficulty: ${difficultyNames[difficulty] || 'Unknown'}`;
      badge.className = `difficulty-badge difficulty-${difficulty}`;
    }
    
    function updateTechniqueBar() {
      const bar = document.getElementById('techniqueBar');
      const legend = document.getElementById('techniqueLegend');
      
      // Calculate sqrt lengths
      const techniques = [
        { name: 'Full House', key: 'fullHouse', class: 'tech-fullhouse', count: techniqueStats.fullHouse },
        { name: 'Last Twin', key: 'lastTwin', class: 'tech-lasttwin', count: techniqueStats.lastTwin },
        { name: 'Hidden Single', key: 'hiddenSingle', class: 'tech-hiddensingle', count: techniqueStats.hiddenSingle },
        { name: 'Naked Single', key: 'nakedSingle', class: 'tech-nakedsingle', count: techniqueStats.nakedSingle },
        { name: 'Hidden Twin', key: 'hiddenTwin', class: 'tech-hiddentwins', count: techniqueStats.hiddenTwin },
        { name: 'Almost Hidden Twin', key: 'almostHiddenTwin', class: 'tech-aht', count: techniqueStats.almostHiddenTwin },
        { name: 'Combinations', key: 'combinations', class: 'tech-combinations', count: techniqueStats.combinations },
        { name: 'Unknown', key: 'unknown', class: 'tech-unknown', count: techniqueStats.unknown }
      ];
      
      const lengths = techniques.map(tech => ({
        ...tech,
        length: tech.count > 0 ? Math.sqrt(tech.count) : 0
      }));
      
      const totalLength = lengths.reduce((sum, tech) => sum + tech.length, 0);
      
      // Build bar segments
      let barHTML = '';
      let legendHTML = '';
      
      if (totalLength > 0) {
        lengths.forEach(tech => {
          if (tech.length > 0) {
            const percentage = (tech.length / totalLength) * 100;
            barHTML += `<div class="technique-segment ${tech.class}" 
                           style="width: ${percentage}%" 
                           title="${tech.name}: ${tech.count} uses"></div>`;
          }
        });
        
        // Create legend
        techniques.forEach(tech => {
          if (tech.count > 0) {
            legendHTML += `
              <div class="legend-item">
                <div class="legend-color ${tech.class}"></div>
                <span>${tech.name} (${tech.count})</span>
              </div>
            `;
          }
        });
      } else {
        barHTML = '<div class="technique-segment tech-unknown" style="width: 100%" title="No analysis available"></div>';
        legendHTML = '<div class="legend-item"><div class="legend-color tech-unknown"></div><span>No techniques analyzed</span></div>';
      }
      
      bar.innerHTML = barHTML;
      legend.innerHTML = legendHTML;
    }
    
    function toggleCandidates() {
      showingCandidates = !showingCandidates;
      const btn = document.getElementById('showCandidates');
      if (showingCandidates) {
        // Use the solutions from the last analysis if available
        let solutionsToUse = lastAnalysisSolutions;
        let solutionsCount = solutionsToUse.length;
        
        // If no previous analysis or too many solutions, re-analyze
        if (solutionsToUse.length === 0 || solutionsCount >= solver.maxSolutions) {
            solutionsToUse = solver.solve(grid);
            solutionsCount = solutionsToUse.length;
        }
        
        solver.grid = grid.map(row => [...row]); // Update solver's grid reference
        
        document.querySelectorAll('.cell-div').forEach(cell => {
          const row = parseInt(cell.dataset.row);
          const col = parseInt(cell.dataset.col);
          if (grid[row][col] === 0) {
            const candidatesDiv = cell.querySelector('.candidates');
            candidatesDiv.style.display = 'grid';
            
            if (solutionsCount >= solver.maxSolutions) {
                // Too many solutions, show possible candidates based on constraints only
                const possibleCandidates = solver.getPossibleCandidates(row, col);
                candidatesDiv.querySelectorAll('.candidate').forEach(candEl => {
                    const value = parseInt(candEl.dataset.value);
                    candEl.textContent = possibleCandidates.includes(value) ? value : '';
                    candEl.style.color = '#666'; // Gray color for possible candidates
                });
            } else if (solutionsCount === 0) {
                // No solutions, show possible candidates based on constraints only
                const possibleCandidates = solver.getPossibleCandidates(row, col);
                candidatesDiv.querySelectorAll('.candidate').forEach(candEl => {
                    const value = parseInt(candEl.dataset.value);
                    candEl.textContent = possibleCandidates.includes(value) ? value : '';
                    candEl.style.color = '#666';
                });
            } else {
                // Valid number of solutions, show actual candidates from solutions
                const actualCandidates = solver.getActualCandidatesFromSolutions(row, col, solutionsToUse);
                candidatesDiv.querySelectorAll('.candidate').forEach(candEl => {
                    const value = parseInt(candEl.dataset.value);
                    if (actualCandidates.includes(value)) {
                        candEl.textContent = value;
                        candEl.style.color = '#eeeeee'; // Normal color for actual candidates
                    } else {
                        candEl.textContent = '';
                    }
                });
            }
          }
        });
        btn.textContent = 'Hide Candidates';
      } else {
        document.querySelectorAll('.candidates').forEach(c => {
          c.style.display = 'none';
        });
        btn.textContent = 'Show Candidates';
      }
    }

    // Updated pasteString function
    function pasteString() {
      try {
        const string = prompt("Insert the 64-character puzzle string here:");
        if (string === null) return; // User cancelled

        if (string.length !== 64) {
           throw new Error("Puzzle string must be exactly 64 characters long.");
        }

        // Validate characters (digits 1-4 or 0/'.' for empty)
        for (let i = 0; i < string.length; i++) {
            const char = string[i];
            if (char !== '0' && char !== '.' && (char < '1' || char > '4')) {
                 throw new Error(`Invalid character '${char}' at position ${i + 1}. Only digits 0, 1, 2, 3, 4, or '.' are allowed.`);
            }
        }

        // Clear previous redundant cells and cached solutions
        redundantCells.clear();
        lastAnalysisSolutions = [];
        techniqueStats = {};

        // Update the grid
        for (let i = 0; i < 64; i++) {
            const row = Math.floor(i / 8);
            const col = i % 8;
            const char = string[i];
            // Convert '.' to 0 for empty cells, otherwise parse the digit
            grid[row][col] = (char === '.' || char === '0') ? 0 : parseInt(char, 10);
        }

        // Re-render the table and update status
        renderTable();
        updateStatus();
        document.getElementById('solutions').textContent = 'Unknown'; // Reset solution count display
        analyzeDifficultyAndTechniques();

        // Provide feedback
        document.getElementById('status').textContent = 'Puzzle string pasted successfully!';
        document.getElementById('status').className = 'status unique';

      } catch (error) {
         alert("Error pasting puzzle string: " + error.message);
         console.error("Paste String Error:", error);
      }
    }

    function findRedundant() {
      const solutions = solver.solve(grid);
      if (solutions.length !== 1) {
        alert('Must have exactly one solution to find redundant givens');
        return;
      }
      redundantCells.clear();
      // Test removing each given
      for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
          if (grid[row][col] !== 0) {
            const original = grid[row][col];
            grid[row][col] = 0;
            const testSolutions = solver.solve(grid);
            if (testSolutions.length === 1) {
              redundantCells.add(`${row}-${col}`);
            }
            grid[row][col] = original;
          }
        }
      }
      renderTable();
      if (redundantCells.size > 0) {
        document.getElementById('status').textContent = `Found ${redundantCells.size} redundant givens (circled)`;
        document.getElementById('status').className = 'status unique';
      } else {
        document.getElementById('status').textContent = 'No redundant givens found';
        document.getElementById('status').className = 'status none';
      }
    }
    
    function exportToPlay() {
      const puzzleString = grid.flat().join('');
      const url = `duodokuplay.html?puzzle=${puzzleString}&zoom=50`;
      window.open(url, '_blank');
    }
    
    function copyString() {
      const puzzleString = grid.flat().join('');
      navigator.clipboard.writeText(puzzleString).then(() => {
        document.getElementById('status').textContent = 'Puzzle string copied to clipboard!';
        document.getElementById('status').className = 'status unique';
      }).catch(err => {
        console.error('Failed to copy string: ', err);
        document.getElementById('status').textContent = 'Failed to copy string.';
        document.getElementById('status').className = 'status none';
      });
    }
    
    init();
  </script>
</body>
</html>
