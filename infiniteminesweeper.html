<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infinite Minesweeper</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Courier New', monospace;
            background: #2c3e50;
            color: #ecf0f1;
            overflow: hidden;
            user-select: none;
        }

        .ui {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(52, 73, 94, 0.9);
            backdrop-filter: blur(10px);
            padding: 15px;
            z-index: 1000;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #34495e;
        }

        .score {
            font-size: 18px;
            font-weight: bold;
            color: #3498db;
        }

        .status {
            font-size: 16px;
            color: #2ecc71;
        }

        .controls {
            font-size: 14px;
            color: #95a5a6;
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .mode-toggle {
            background: #34495e;
            border: 2px solid #3498db;
            color: #ecf0f1;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            transition: all 0.2s;
        }

        .mode-toggle:hover {
            background: #3498db;
            transform: scale(1.05);
        }

        .mode-toggle.chaos {
            border-color: #e74c3c;
        }

        .mode-toggle.chaos:hover {
            background: #e74c3c;
        }

        .game-container {
            position: absolute;
            top: 60px;
            left: 0;
            width: 100vw;
            height: calc(100vh - 60px);
            overflow: hidden;
            cursor: grab;
        }

        .game-container.dragging {
            cursor: grabbing;
        }

        .game-board {
            position: relative;
            transform-origin: 0 0;
        }

        .cell {
            position: absolute;
            width: 24px;
            height: 24px;
            border: 2px solid #7f8c8d;
            background: #95a5a6;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.1s ease;
        }

        .cell:hover {
            border-color: #3498db;
            transform: scale(1.05);
        }

        .cell.revealed {
            background: #ecf0f1;
            border-color: #bdc3c7;
            color: #2c3e50;
            cursor: pointer;
        }

        .cell.revealed:hover {
            border-color: #3498db;
            background: #dde4e6;
        }

        .cell.flagged {
            background: #e74c3c;
            color: #fff;
        }

        .cell.mine {
            background: #e74c3c;
            color: #fff;
        }

        .cell.mine-exploded {
            background: #c0392b;
            animation: explode 0.3s ease-out;
        }

        @keyframes explode {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); }
            100% { transform: scale(1); }
        }

        .cell-1 { color: #3498db; }
        .cell-2 { color: #27ae60; }
        .cell-3 { color: #e74c3c; }
        .cell-4 { color: #8e44ad; }
        .cell-5 { color: #f39c12; }
        .cell-6 { color: #e67e22; }
        .cell-7 { color: #2c3e50; }
        .cell-8 { color: #95a5a6; }
    </style>
</head>
<body>
    <div class="ui">
        <div class="score">Cells Discovered: <span id="score">0</span></div>
        <div class="status" id="status">Click revealed numbers to chord! | Left Click: Reveal | Right Click: Flag | Drag: Pan</div>
        <div class="controls">
            <button class="mode-toggle" id="modeToggle">Mode: Random</button>
            <span>Chunks: <span id="chunk-count">1</span></span>
        </div>
    </div>
    
    <div class="game-container" id="gameContainer">
        <div class="game-board" id="gameBoard"></div>
    </div>

    <script>
        class InfiniteMinesweeper {
            constructor() {
                this.board = new Map(); // Stores all generated cells with their state
                this.chunks = new Map();
                this.chunkSize = 16;
                this.mineRatio = 0.15;
                this.cellSize = 28;
                
                this.score = 0;
                this.gameOver = false;
                this.firstClick = true;
                this.safeZone = new Set();
                this.chaosMode = false;
                
                // View state
                this.viewX = 0;
                this.viewY = 0;
                this.isDragging = false;
                this.dragStartX = 0;
                this.dragStartY = 0;
                this.dragThreshold = 5;
                this.hasDragged = false;
                
                this.gameBoard = document.getElementById('gameBoard');
                this.gameContainer = document.getElementById('gameContainer');
                this.scoreElement = document.getElementById('score');
                this.statusElement = document.getElementById('status');
                this.chunkCountElement = document.getElementById('chunk-count');
                this.modeToggle = document.getElementById('modeToggle');
                
                this.initializeGame();
                this.setupEventListeners();
                this.gameLoop();
            }
            
            initializeGame() {
                this.generateChunk(0, 0);
                this.updateView();
            }
            
            setupEventListeners() {
                this.gameContainer.addEventListener('mousedown', (e) => {
                    if (e.button === 0) {
                        this.isDragging = true;
                        this.hasDragged = false;
                        this.dragStartX = e.clientX;
                        this.dragStartY = e.clientY;
                        this.gameContainer.classList.add('dragging');
                    }
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (this.isDragging) {
                        const deltaX = e.clientX - this.dragStartX;
                        const deltaY = e.clientY - this.dragStartY;
                        
                        if (Math.abs(deltaX) > this.dragThreshold || Math.abs(deltaY) > this.dragThreshold) {
                            this.hasDragged = true;
                        }
                        
                        this.viewX += deltaX;
                        this.viewY += deltaY;
                        
                        this.dragStartX = e.clientX;
                        this.dragStartY = e.clientY;
                        
                        this.updateView();
                    }
                });
                
                document.addEventListener('mouseup', (e) => {
                    if (e.button === 0) {
                        this.isDragging = false;
                        this.gameContainer.classList.remove('dragging');
                        
                        setTimeout(() => {
                            this.hasDragged = false;
                        }, 50);
                    }
                });
                
                this.gameContainer.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                });

                this.modeToggle.addEventListener('click', () => {
                    this.chaosMode = !this.chaosMode;
                    if (this.chaosMode) {
                        this.modeToggle.textContent = 'Mode: Chaos';
                        this.modeToggle.classList.add('chaos');
                    } else {
                        this.modeToggle.textContent = 'Mode: Random';
                        this.modeToggle.classList.remove('chaos');
                    }
                    this.resetGame();
                });
            }

            resetGame() {
                // Clear the board
                for (let [cellKey, cell] of this.board) {
                    if (cell.element) {
                        cell.element.remove();
                    }
                }
                this.board.clear();
                this.chunks.clear();
                this.safeZone.clear();
                
                // Reset game state
                this.score = 0;
                this.gameOver = false;
                this.firstClick = true;
                this.scoreElement.textContent = '0';
                this.statusElement.textContent = 'Click revealed numbers to chord! | Left Click: Reveal | Right Click: Flag | Drag: Pan';
                this.statusElement.style.color = '#2ecc71';
                
                // Reinitialize
                this.initializeGame();
            }
            
            // Get or create a cell - this is where we use randomness ONCE per cell
            getOrCreateCell(worldX, worldY) {
                const cellKey = `${worldX},${worldY}`;
                let cell = this.board.get(cellKey);
                
                if (!cell) {
                    const isSafe = this.safeZone.has(cellKey);
                    let isMine;
                    
                    if (isSafe) {
                        isMine = false;
                    } else if (this.chaosMode) {
                        // Chaos mode - use the buggy hash
                        isMine = this.chaosRandom(worldX, worldY) < this.mineRatio;
                    } else {
                        // Random mode - use actual Math.random()
                        isMine = Math.random() < this.mineRatio;
                    }
                    
                    cell = {
                        x: worldX,
                        y: worldY,
                        isMine: isMine,
                        isRevealed: false,
                        isFlagged: false,
                        neighborMines: 0,
                        element: null
                    };
                    
                    this.board.set(cellKey, cell);
                }
                
                return cell;
            }
            
            generateChunk(chunkX, chunkY) {
                const chunkKey = `${chunkX},${chunkY}`;
                if (this.chunks.has(chunkKey)) return;
                
                const chunk = {
                    x: chunkX,
                    y: chunkY,
                    generated: true
                };
                
                this.chunks.set(chunkKey, chunk);
                
                // Generate all cells in this chunk
                for (let x = 0; x < this.chunkSize; x++) {
                    for (let y = 0; y < this.chunkSize; y++) {
                        const worldX = chunkX * this.chunkSize + x;
                        const worldY = chunkY * this.chunkSize + y;
                        this.getOrCreateCell(worldX, worldY);
                    }
                }
                
                this.chunkCountElement.textContent = this.chunks.size;
            }
            
            // The old "chaos" random that creates patterns (only used in chaos mode)
            chaosRandom(x, y) {
                let seed = ((x * 73856093) ^ (y * 19349663)) % 1000000;
                seed = (seed * 9301 + 49297) % 233280;
                return seed / 233280;
            }
            
            calculateNeighborMines(chunkX, chunkY) {
                for (let x = 0; x < this.chunkSize; x++) {
                    for (let y = 0; y < this.chunkSize; y++) {
                        const worldX = chunkX * this.chunkSize + x;
                        const worldY = chunkY * this.chunkSize + y;
                        const cell = this.getOrCreateCell(worldX, worldY);
                        
                        if (!cell.isMine) {
                            let mineCount = 0;
                            
                            for (let dx = -1; dx <= 1; dx++) {
                                for (let dy = -1; dy <= 1; dy++) {
                                    if (dx === 0 && dy === 0) continue;
                                    
                                    const neighborX = worldX + dx;
                                    const neighborY = worldY + dy;
                                    const neighbor = this.getOrCreateCell(neighborX, neighborY);
                                    
                                    if (neighbor.isMine) {
                                        mineCount++;
                                    }
                                }
                            }
                            
                            cell.neighborMines = mineCount;
                        }
                    }
                }
            }
            
            updateView() {
                const containerRect = this.gameContainer.getBoundingClientRect();
                const visibleLeft = -this.viewX;
                const visibleTop = -this.viewY;
                const visibleRight = visibleLeft + containerRect.width;
                const visibleBottom = visibleTop + containerRect.height;
                
                const leftChunk = Math.floor(visibleLeft / (this.chunkSize * this.cellSize)) - 1;
                const rightChunk = Math.ceil(visibleRight / (this.chunkSize * this.cellSize)) + 1;
                const topChunk = Math.floor(visibleTop / (this.chunkSize * this.cellSize)) - 1;
                const bottomChunk = Math.ceil(visibleBottom / (this.chunkSize * this.cellSize)) + 1;
                
                for (let chunkX = leftChunk; chunkX <= rightChunk; chunkX++) {
                    for (let chunkY = topChunk; chunkY <= bottomChunk; chunkY++) {
                        this.generateChunk(chunkX, chunkY);
                        this.calculateNeighborMines(chunkX, chunkY);
                    }
                }
                
                this.gameBoard.style.transform = `translate(${this.viewX}px, ${this.viewY}px)`;
                this.updateVisibleCells(visibleLeft, visibleTop, visibleRight, visibleBottom);
            }
            
            updateVisibleCells(left, top, right, bottom) {
                const buffer = this.cellSize * 5;
                
                for (let [cellKey, cell] of this.board) {
                    if (cell.element) {
                        const cellLeft = cell.x * this.cellSize;
                        const cellTop = cell.y * this.cellSize;
                        
                        if (cellLeft < left - buffer || cellLeft > right + buffer || 
                            cellTop < top - buffer || cellTop > bottom + buffer) {
                            cell.element.remove();
                            cell.element = null;
                        }
                    }
                }
                
                for (let [cellKey, cell] of this.board) {
                    if (!cell.element) {
                        const cellLeft = cell.x * this.cellSize;
                        const cellTop = cell.y * this.cellSize;
                        
                        if (cellLeft >= left - buffer && cellLeft <= right + buffer && 
                            cellTop >= top - buffer && cellTop <= bottom + buffer) {
                            this.createCellElement(cell);
                        }
                    }
                }
            }
            
            createCellElement(cell) {
                const element = document.createElement('div');
                element.className = 'cell';
                element.style.left = (cell.x * this.cellSize) + 'px';
                element.style.top = (cell.y * this.cellSize) + 'px';
                
                element.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (!this.hasDragged && !this.gameOver) {
                        if (!cell.isRevealed && !cell.isFlagged) {
                            // Normal click - reveal cell
                            if (this.firstClick) {
                                this.makeFirstClickSafe(cell);
                                this.firstClick = false;
                            }
                            this.revealCell(cell);
                        } else if (cell.isRevealed && cell.neighborMines > 0) {
                            // Chord click - reveal neighbors if flags match
                            this.chordCell(cell);
                        }
                    }
                });
                
                element.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (!this.hasDragged && !this.gameOver) {
                        this.flagCell(cell);
                    }
                });
                
                this.updateCellDisplay(cell, element);
                cell.element = element;
                this.gameBoard.appendChild(element);
            }
            
            chordCell(cell) {
                // Count flagged neighbors
                let flaggedCount = 0;
                const neighbors = [];
                
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        if (dx === 0 && dy === 0) continue;
                        
                        const neighborX = cell.x + dx;
                        const neighborY = cell.y + dy;
                        const neighbor = this.getOrCreateCell(neighborX, neighborY);
                        
                        neighbors.push(neighbor);
                        if (neighbor.isFlagged) {
                            flaggedCount++;
                        }
                    }
                }
                
                // If flagged count matches neighbor mines, reveal all unflagged neighbors
                if (flaggedCount === cell.neighborMines) {
                    for (const neighbor of neighbors) {
                        if (!neighbor.isFlagged && !neighbor.isRevealed) {
                            this.revealCell(neighbor);
                        }
                    }
                }
            }
            
            makeFirstClickSafe(cell) {
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        const safeX = cell.x + dx;
                        const safeY = cell.y + dy;
                        const safeKey = `${safeX},${safeY}`;
                        this.safeZone.add(safeKey);
                        
                        const existingCell = this.getOrCreateCell(safeX, safeY);
                        if (existingCell.isMine) {
                            existingCell.isMine = false;
                        }
                    }
                }
                
                const chunkX = Math.floor(cell.x / this.chunkSize);
                const chunkY = Math.floor(cell.y / this.chunkSize);
                
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        this.calculateNeighborMines(chunkX + dx, chunkY + dy);
                    }
                }
            }
            
            updateCellDisplay(cell, element = cell.element) {
                if (!element) return;
                
                element.className = 'cell';
                element.textContent = '';
                
                if (cell.isFlagged) {
                    element.classList.add('flagged');
                    element.textContent = 'ðŸš©';
                } else if (cell.isRevealed) {
                    element.classList.add('revealed');
                    if (cell.isMine) {
                        element.classList.add('mine');
                        element.textContent = 'ðŸ’£';
                    } else if (cell.neighborMines > 0) {
                        element.textContent = cell.neighborMines;
                        element.classList.add(`cell-${cell.neighborMines}`);
                    }
                }
            }
            
            revealCell(cell, depth = 0) {
                if (cell.isRevealed || cell.isFlagged || this.gameOver || depth > 100) return;
                
                cell.isRevealed = true;
                this.score++;
                this.scoreElement.textContent = this.score;
                
                if (cell.isMine) {
                    this.gameOver = true;
                    this.statusElement.textContent = 'ðŸ’¥ Game Over! Click mode button to restart';
                    this.statusElement.style.color = '#e74c3c';
                    if (cell.element) {
                        cell.element.classList.add('mine-exploded');
                    }
                } else {
                    if (cell.neighborMines === 0) {
                        this.revealNeighbors(cell, depth);
                    }
                }
                
                this.updateCellDisplay(cell);
            }
            
            revealNeighbors(cell, depth = 0) {
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        if (dx === 0 && dy === 0) continue;
                        
                        const neighborX = cell.x + dx;
                        const neighborY = cell.y + dy;
                        
                        const neighborChunkX = Math.floor(neighborX / this.chunkSize);
                        const neighborChunkY = Math.floor(neighborY / this.chunkSize);
                        this.generateChunk(neighborChunkX, neighborChunkY);
                        
                        const neighbor = this.getOrCreateCell(neighborX, neighborY);
                        if (!neighbor.isRevealed && !neighbor.isFlagged) {
                            this.revealCell(neighbor, depth + 1);
                        }
                    }
                }
            }
            
            flagCell(cell) {
                if (cell.isRevealed || this.gameOver) return;
                
                cell.isFlagged = !cell.isFlagged;
                this.updateCellDisplay(cell);
            }
            
            gameLoop() {
                requestAnimationFrame(() => this.gameLoop());
            }
        }
        
        window.addEventListener('load', () => {
            new InfiniteMinesweeper();
        });
    </script>
</body>
</html>
