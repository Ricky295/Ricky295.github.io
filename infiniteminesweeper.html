<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infinite Minesweeper</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Courier New', monospace;
            background: #2c3e50;
            color: #ecf0f1;
            overflow: hidden;
            user-select: none;
        }

        .ui {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(52, 73, 94, 0.9);
            backdrop-filter: blur(10px);
            padding: 15px;
            z-index: 1000;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #34495e;
        }

        .score {
            font-size: 18px;
            font-weight: bold;
            color: #3498db;
        }

        .status {
            font-size: 16px;
            color: #e74c3c;
        }

        .controls {
            font-size: 14px;
            color: #95a5a6;
        }

        .game-container {
            position: absolute;
            top: 60px;
            left: 0;
            width: 100vw;
            height: calc(100vh - 60px);
            overflow: hidden;
            cursor: grab;
        }

        .game-container:active {
            cursor: grabbing;
        }

        .game-board {
            position: relative;
            transform-origin: 0 0;
        }

        .cell {
            position: absolute;
            width: 24px;
            height: 24px;
            border: 2px solid #7f8c8d;
            background: #95a5a6;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.1s ease;
        }

        .cell:hover {
            border-color: #3498db;
            transform: scale(1.05);
        }

        .cell.revealed {
            background: #ecf0f1;
            border-color: #bdc3c7;
            color: #2c3e50;
            cursor: grab;
        }

        .cell.revealed:hover {
            border-color: #3498db;
            background: #dde4e6;
        }

        .cell.flagged {
            background: #e74c3c;
            color: #fff;
        }

        .cell.mine {
            background: #e74c3c;
            color: #fff;
        }

        .cell.mine-exploded {
            background: #c0392b;
            animation: explode 0.3s ease-out;
        }

        @keyframes explode {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); }
            100% { transform: scale(1); }
        }

        .cell-1 { color: #3498db; }
        .cell-2 { color: #27ae60; }
        .cell-3 { color: #e74c3c; }
        .cell-4 { color: #8e44ad; }
        .cell-5 { color: #f39c12; }
        .cell-6 { color: #e67e22; }
        .cell-7 { color: #2c3e50; }
        .cell-8 { color: #95a5a6; }

        .chunk-border {
            position: absolute;
            border: 1px dashed rgba(52, 152, 219, 0.3);
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="ui">
        <div class="score">Cells Discovered: <span id="score">0</span></div>
        <div class="status" id="status">Playing - Left Click: Reveal | Right Click: Flag | Drag: Click revealed cells</div>
        <div class="controls">Drag to move | Chunks: <span id="chunk-count">1</span></div>
    </div>
    
    <div class="game-container" id="gameContainer">
        <div class="game-board" id="gameBoard"></div>
    </div>

    <script>
        class InfiniteMinesweeper {
            constructor() {
                this.board = new Map(); // Stores cell data by "x,y" key
                this.chunks = new Map(); // Stores generated chunks by "chunkX,chunkY" key
                this.chunkSize = 16; // 16x16 cells per chunk
                this.mineRatio = 0.15; // 15% chance of mine
                this.cellSize = 28; // Including border
                
                this.score = 0;
                this.gameOver = false;
                this.gameWon = false;
                
                // View state
                this.viewX = 0;
                this.viewY = 0;
                this.isDragging = false;
                this.lastMouseX = 0;
                this.lastMouseY = 0;
                
                this.gameBoard = document.getElementById('gameBoard');
                this.gameContainer = document.getElementById('gameContainer');
                this.scoreElement = document.getElementById('score');
                this.statusElement = document.getElementById('status');
                this.chunkCountElement = document.getElementById('chunk-count');
                
                this.initializeGame();
                this.setupEventListeners();
                this.gameLoop();
            }
            
            initializeGame() {
                // Generate initial chunk around origin
                this.generateChunk(0, 0);
                this.updateView();
            }
            
            setupEventListeners() {
                // Mouse events for dragging - now only from revealed cells
                this.gameContainer.addEventListener('mousedown', (e) => {
                    e.preventDefault(); // Prevent default drag behavior
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (this.isDragging) {
                        const deltaX = e.clientX - this.lastMouseX;
                        const deltaY = e.clientY - this.lastMouseY;
                        
                        this.viewX += deltaX;
                        this.viewY += deltaY;
                        
                        this.lastMouseX = e.clientX;
                        this.lastMouseY = e.clientY;
                        
                        this.updateView();
                        e.preventDefault();
                    }
                });
                
                document.addEventListener('mouseup', (e) => {
                    if (e.button === 0) {
                        this.isDragging = false;
                        this.gameContainer.style.cursor = 'default';
                    }
                });
                
                // Prevent context menu
                this.gameContainer.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                });
            }
            
            generateChunk(chunkX, chunkY) {
                const chunkKey = `${chunkX},${chunkY}`;
                if (this.chunks.has(chunkKey)) return;
                
                // Create chunk data
                const chunk = {
                    x: chunkX,
                    y: chunkY,
                    generated: true
                };
                
                this.chunks.set(chunkKey, chunk);
                
                // Generate cells for this chunk
                for (let x = 0; x < this.chunkSize; x++) {
                    for (let y = 0; y < this.chunkSize; y++) {
                        const worldX = chunkX * this.chunkSize + x;
                        const worldY = chunkY * this.chunkSize + y;
                        const cellKey = `${worldX},${worldY}`;
                        
                        if (!this.board.has(cellKey)) {
                            // Use seeded random based on position for consistent generation
                            const isMine = this.seededRandom(worldX, worldY) < this.mineRatio;
                            
                            this.board.set(cellKey, {
                                x: worldX,
                                y: worldY,
                                isMine: isMine,
                                isRevealed: false,
                                isFlagged: false,
                                neighborMines: 0,
                                element: null
                            });
                        }
                    }
                }
                
                this.chunkCountElement.textContent = this.chunks.size;
            }
            
            seededRandom(x, y) {
                // Simple hash function for consistent pseudo-random values
                let seed = ((x * 73856093) ^ (y * 19349663)) % 1000000;
                seed = (seed * 9301 + 49297) % 233280;
                return seed / 233280;
            }
            
            calculateNeighborMines(chunkX, chunkY) {
                for (let x = 0; x < this.chunkSize; x++) {
                    for (let y = 0; y < this.chunkSize; y++) {
                        const worldX = chunkX * this.chunkSize + x;
                        const worldY = chunkY * this.chunkSize + y;
                        const cellKey = `${worldX},${worldY}`;
                        const cell = this.board.get(cellKey);
                        
                        if (cell && !cell.isMine) {
                            let mineCount = 0;
                            
                            // Check all 8 neighbors
                            for (let dx = -1; dx <= 1; dx++) {
                                for (let dy = -1; dy <= 1; dy++) {
                                    if (dx === 0 && dy === 0) continue;
                                    
                                    const neighborX = worldX + dx;
                                    const neighborY = worldY + dy;
                                    const neighborKey = `${neighborX},${neighborY}`;
                                    
                                    // Check if neighbor exists, generate it if not
                                    let neighbor = this.board.get(neighborKey);
                                    if (!neighbor) {
                                        // Generate single cell without recursive chunk generation
                                        const isMine = this.seededRandom(neighborX, neighborY) < this.mineRatio;
                                        neighbor = {
                                            x: neighborX,
                                            y: neighborY,
                                            isMine: isMine,
                                            isRevealed: false,
                                            isFlagged: false,
                                            neighborMines: 0,
                                            element: null
                                        };
                                        this.board.set(neighborKey, neighbor);
                                    }
                                    
                                    if (neighbor.isMine) {
                                        mineCount++;
                                    }
                                }
                            }
                            
                            cell.neighborMines = mineCount;
                        }
                    }
                }
            }
            
            updateView() {
                // Calculate visible area
                const containerRect = this.gameContainer.getBoundingClientRect();
                const visibleLeft = -this.viewX;
                const visibleTop = -this.viewY;
                const visibleRight = visibleLeft + containerRect.width;
                const visibleBottom = visibleTop + containerRect.height;
                
                // Calculate which chunks we need
                const leftChunk = Math.floor(visibleLeft / (this.chunkSize * this.cellSize));
                const rightChunk = Math.ceil(visibleRight / (this.chunkSize * this.cellSize));
                const topChunk = Math.floor(visibleTop / (this.chunkSize * this.cellSize));
                const bottomChunk = Math.ceil(visibleBottom / (this.chunkSize * this.cellSize));
                
                // Generate needed chunks
                for (let chunkX = leftChunk; chunkX <= rightChunk; chunkX++) {
                    for (let chunkY = topChunk; chunkY <= bottomChunk; chunkY++) {
                        this.generateChunk(chunkX, chunkY);
                    }
                }
                
                // Calculate neighbor mines for newly generated chunks
                for (let chunkX = leftChunk; chunkX <= rightChunk; chunkX++) {
                    for (let chunkY = topChunk; chunkY <= bottomChunk; chunkY++) {
                        this.calculateNeighborMines(chunkX, chunkY);
                    }
                }
                
                // Update board transform
                this.gameBoard.style.transform = `translate(${this.viewX}px, ${this.viewY}px)`;
                
                // Update visible cells
                this.updateVisibleCells(visibleLeft, visibleTop, visibleRight, visibleBottom);
            }
            
            updateVisibleCells(left, top, right, bottom) {
                // Remove cells that are no longer visible
                const elementsToRemove = [];
                for (let [cellKey, cell] of this.board) {
                    if (cell.element) {
                        const cellLeft = cell.x * this.cellSize;
                        const cellTop = cell.y * this.cellSize;
                        const cellRight = cellLeft + this.cellSize;
                        const cellBottom = cellTop + this.cellSize;
                        
                        if (cellRight < left || cellLeft > right || 
                            cellBottom < top || cellTop > bottom) {
                            elementsToRemove.push(cellKey);
                        }
                    }
                }
                
                elementsToRemove.forEach(cellKey => {
                    const cell = this.board.get(cellKey);
                    if (cell.element) {
                        cell.element.remove();
                        cell.element = null;
                    }
                });
                
                // Add visible cells that don't have elements
                for (let [cellKey, cell] of this.board) {
                    if (!cell.element) {
                        const cellLeft = cell.x * this.cellSize;
                        const cellTop = cell.y * this.cellSize;
                        const cellRight = cellLeft + this.cellSize;
                        const cellBottom = cellTop + this.cellSize;
                        
                        if (cellRight >= left && cellLeft <= right && 
                            cellBottom >= top && cellTop <= bottom) {
                            this.createCellElement(cell);
                        }
                    }
                }
            }
            
            createCellElement(cell) {
                const element = document.createElement('div');
                element.className = 'cell';
                element.style.left = (cell.x * this.cellSize) + 'px';
                element.style.top = (cell.y * this.cellSize) + 'px';
                
                element.addEventListener('mousedown', (e) => {
                    if (e.button === 0) { // Left click
                        e.stopPropagation();
                        
                        if (cell.isRevealed && !this.gameOver) {
                            // Start dragging from revealed cells
                            this.isDragging = true;
                            this.lastMouseX = e.clientX;
                            this.lastMouseY = e.clientY;
                            this.gameContainer.style.cursor = 'grabbing';
                            e.preventDefault();
                        }
                    }
                });
                
                element.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (!this.isDragging && !this.gameOver && !cell.isRevealed) {
                        // Only reveal if not dragging and cell is not revealed
                        this.revealCell(cell);
                    }
                });
                
                element.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (!this.isDragging && !this.gameOver) {
                        this.flagCell(cell);
                    }
                });
                
                this.updateCellDisplay(cell, element);
                cell.element = element;
                this.gameBoard.appendChild(element);
            }
            
            updateCellDisplay(cell, element = cell.element) {
                if (!element) return;
                
                element.className = 'cell';
                element.textContent = '';
                
                if (cell.isFlagged) {
                    element.classList.add('flagged');
                    element.textContent = '🚩';
                } else if (cell.isRevealed) {
                    element.classList.add('revealed');
                    if (cell.isMine) {
                        element.classList.add('mine');
                        element.textContent = '💣';
                    } else if (cell.neighborMines > 0) {
                        element.textContent = cell.neighborMines;
                        element.classList.add(`cell-${cell.neighborMines}`);
                    }
                }
            }
            
            revealCell(cell, depth = 0) {
                if (cell.isRevealed || cell.isFlagged || this.gameOver || depth > 100) return;
                
                cell.isRevealed = true;
                this.score++;
                this.scoreElement.textContent = this.score;
                
                if (cell.isMine) {
                    this.gameOver = true;
                    this.statusElement.textContent = '💥 Game Over! Refresh to play again';
                    this.statusElement.style.color = '#e74c3c';
                    if (cell.element) {
                        cell.element.classList.add('mine-exploded');
                    }
                } else {
                    // Auto-reveal empty neighbors
                    if (cell.neighborMines === 0) {
                        this.revealNeighbors(cell, depth);
                    }
                }
                
                this.updateCellDisplay(cell);
            }
            
            revealNeighbors(cell, depth = 0) {
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        if (dx === 0 && dy === 0) continue;
                        
                        const neighborX = cell.x + dx;
                        const neighborY = cell.y + dy;
                        const neighborKey = `${neighborX},${neighborY}`;
                        
                        // Generate neighbor chunk if needed
                        const neighborChunkX = Math.floor(neighborX / this.chunkSize);
                        const neighborChunkY = Math.floor(neighborY / this.chunkSize);
                        this.generateChunk(neighborChunkX, neighborChunkY);
                        
                        const neighbor = this.board.get(neighborKey);
                        if (neighbor && !neighbor.isRevealed && !neighbor.isFlagged) {
                            this.revealCell(neighbor, depth + 1);
                        }
                    }
                }
            }
            
            flagCell(cell) {
                if (cell.isRevealed || this.gameOver) return;
                
                cell.isFlagged = !cell.isFlagged;
                this.updateCellDisplay(cell);
            }
            
            gameLoop() {
                // Update view periodically
                this.updateView();
                requestAnimationFrame(() => this.gameLoop());
            }
        }
        
        // Start the game
        window.addEventListener('load', () => {
            new InfiniteMinesweeper();
        });
    </script>
</body>
</html>