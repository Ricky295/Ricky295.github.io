<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>5x5x5 Cubic Sudoku</title>
    <style>
        *{margin:0;padding:0;box-sizing:border-box}body{font-family:monospace;background:#1a1a1a;color:#fff;overflow-x:auto}.container{max-width:1400px;margin:0 auto;padding:20px}.header{text-align:center;margin-bottom:20px}.controls{display:flex;justify-content:center;gap:15px;margin-bottom:20px;flex-wrap:wrap}.btn{padding:12px 20px;border:none;border-radius:8px;cursor:pointer;font-size:16px;font-weight:bold;transition:all 0.3s;user-select:none;-webkit-user-select:none;-webkit-tap-highlight-color:transparent}.btn-primary{background:#007bff;color:white}.btn-secondary{background:#6c757d;color:white}.btn-success{background:#28a745;color:white}.btn-danger{background:#dc3545;color:white}.btn-warning{background:#ffc107;color:#212529}.btn:hover{opacity:0.8;transform:translateY(-1px)}.btn:active{transform:translateY(0);opacity:0.9}.btn.active{background:#28a745}@media (max-width:768px){.btn{padding:14px 18px;font-size:16px;min-height:48px}}.timer{font-size:18px;font-weight:bold;color:#ffd700}.difficulty-slider{display:flex;align-items:center;gap:10px}.difficulty-slider label{color:#ffd700;font-weight:bold}.slider{width:150px;height:6px;border-radius:3px;background:#333;outline:none}.slider::-webkit-slider-thumb{appearance:none;width:20px;height:20px;border-radius:50%;background:#007bff;cursor:pointer}.board-container{display:flex;justify-content:center;gap:20px;flex-wrap:wrap}.layer{border:3px solid #444;margin:5px;background:#2a2a2a;border-radius:8px;padding:10px}.layer-title{text-align:center;margin-bottom:10px;color:#ffd700;font-weight:bold}.grid{display:grid;grid-template-columns:repeat(5,1fr);gap:2px}.cell{width:40px;height:40px;border:1px solid #666;background:#333;display:flex;align-items:center;justify-content:center;cursor:pointer;font-size:16px;font-weight:bold;position:relative;transition:all 0.2s;user-select:none;-webkit-user-select:none;-webkit-tap-highlight-color:transparent}.cell:hover{background:#444}.cell:active{background:#555;transform:scale(0.95)}@media (max-width:768px){.cell{width:45px;height:45px;font-size:18px}}.cell.selected{background:#007bff!important;box-shadow:0 0 10px rgba(0,123,255,0.5)}.cell.given{background:#4a4a4a;color:#ffd700}.cell.error{background:#dc3545!important;animation:shake 0.5s}.cell.completed{background:#28a745!important}.cell.candidate-mode{background:#6c5ce7!important}.cell.related{background:#555!important}.cell.conflict{background:#8b0000!important}.candidates{font-size:8px;position:absolute;top:2px;left:2px;color:#ffd700;line-height:1.1;max-width:36px;word-wrap:break-word}.floating-keypad{position:fixed;bottom:20px;right:20px;background:#2a2a2a;border:2px solid #444;border-radius:12px;padding:12px;box-shadow:0 8px 24px rgba(0,0,0,0.6);z-index:1000;user-select:none;-webkit-user-select:none;touch-action:none}.floating-keypad.dragging{cursor:grabbing;transform:scale(1.02)}.keypad-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;padding:4px 8px;background:#333;border-radius:6px;cursor:grab}.keypad-header:active{cursor:grabbing}.keypad-title{color:#ffd700;font-size:12px;font-weight:bold}.keypad-toggle{background:none;border:none;color:#ffd700;cursor:pointer;font-size:14px;padding:2px 6px;border-radius:4px;transition:background 0.2s}.keypad-toggle:hover{background:#444}.number-pad{display:grid;grid-template-columns:repeat(3,1fr);gap:6px;max-width:none}.number-pad.minimized{display:none}.num-btn{width:50px;height:50px;border:2px solid #666;background:#333;color:#fff;cursor:pointer;display:flex;align-items:center;justify-content:center;font-size:18px;font-weight:bold;border-radius:8px;transition:all 0.2s;user-select:none;-webkit-user-select:none;-webkit-tap-highlight-color:transparent}.num-btn:hover{background:#444;transform:scale(1.05)}.num-btn:active{background:#555;transform:scale(0.95);border-color:#007bff}.num-btn.clear{background:#dc3545;border-color:#dc3545}.num-btn.clear:hover{background:#c82333}@media (max-width:768px){.floating-keypad{bottom:10px;right:10px}.num-btn{width:55px;height:55px;font-size:20px}}.mode-indicator{text-align:center;margin-bottom:10px;font-size:14px;color:#ffd700;font-weight:bold}.hint-display{text-align:center;margin:10px 0;font-size:14px;color:#00ff00;min-height:20px}.stats{display:flex;justify-content:center;gap:20px;margin-top:20px}.stat{text-align:center}.modal{display:none;position:fixed;z-index:1000;left:0;top:0;width:100%;height:100%;background:rgba(0,0,0,0.8)}.modal-content{background:#2a2a2a;margin:15% auto;padding:20px;border-radius:8px;width:300px;text-align:center}.instructions{background:#2a2a2a;padding:15px;border-radius:8px;margin-bottom:20px;font-size:14px;line-height:1.4}.instructions h3{color:#ffd700;margin-bottom:10px}.instructions ul{margin-left:20px}.instructions li{margin-bottom:5px}@keyframes shake{0%,100%{transform:translateX(0)}25%{transform:translateX(-2px)}75%{transform:translateX(2px)}}
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>5x5x5 Cubic Sudoku</h1>
            <div class="timer">Time: <span id="timer">00:00</span></div>
        </div>
        
        <div class="instructions">
            <h3>How to play:</h3>
            <ul>
                <li><strong>Number Mode:</strong> Click cell + number to fill • <strong>Candidate Mode:</strong> Toggle possible numbers</li>
                <li><strong>Keys:</strong> 1-5 (numbers) • Space (mode) • Del/Backspace (clear) • H (hint)</li>
                <li><strong>Smart Hints:</strong> Detects naked singles, hidden singles, and conflicts</li>
            </ul>
        </div>
        
        <div class="controls">
            <button class="btn btn-primary" onclick="newGame()">New Game</button>
            <button class="btn btn-warning" id="candidateBtn" onclick="toggleCandidateMode()">Candidate Mode</button>
            <button class="btn btn-success" onclick="smartHint()">Smart Hint</button>
            <button class="btn btn-danger" onclick="resetGame()">Reset</button>
            <div class="difficulty-slider">
                <label for="clues">Clues: <span id="clues-value">50</span></label>
                <input type="range" id="clues" min="10" max="100" value="50" class="slider">
            </div>
        </div>
        
        <div class="mode-indicator" id="modeIndicator">Mode: Number Entry</div>
        <div class="hint-display" id="hintDisplay"></div>
        
        <div class="board-container" id="board-container"></div>
        
        <div class="floating-keypad" id="floatingKeypad">
            <div class="keypad-header" id="keypadHeader">
                <span class="keypad-title">Keypad</span>
                <button class="keypad-toggle" onclick="toggleKeypad()">−</button>
            </div>
            <div class="number-pad" id="numberPad">
                <div class="num-btn" onclick="selectNumber(1)" ontouchstart="">1</div>
                <div class="num-btn" onclick="selectNumber(2)" ontouchstart="">2</div>
                <div class="num-btn" onclick="selectNumber(3)" ontouchstart="">3</div>
                <div class="num-btn" onclick="selectNumber(4)" ontouchstart="">4</div>
                <div class="num-btn" onclick="selectNumber(5)" ontouchstart="">5</div>
                <div class="num-btn clear" onclick="selectNumber(0)" ontouchstart="">✕</div>
            </div>
        </div>
        
        <div class="stats">
            <div class="stat"><div>Filled</div><div id="filled">0/125</div></div>
            <div class="stat"><div>Hints Used</div><div id="hints">0</div></div>
        </div>
    </div>
    
    <div id="winModal" class="modal">
        <div class="modal-content">
            <h2>Congratulations!</h2>
            <p>You solved the puzzle!</p>
            <p>Time: <span id="finalTime"></span></p>
            <button class="btn btn-primary" onclick="closeModal()">New Game</button>
        </div>
    </div>

    <script>
        const SIZE=5,VALUES=[1,2,3,4,5];
        let board=[],solution=[],candidates={},selectedCell=null,startTime=null,timerInterval=null,candidateMode=false,hintsUsed=0,gameWon=false;
        let keypadMinimized=false,isDragging=false,dragOffset={x:0,y:0};
        
        function createBoard(){return Array(SIZE).fill().map(()=>Array(SIZE).fill().map(()=>Array(SIZE).fill(0)))}
        
        function getRelatedCoords(x,y,z){
            const coords=new Set();
            for(let i=0;i<SIZE;i++){
                coords.add(`${x},${y},${i}`);
                coords.add(`${x},${i},${z}`);
                coords.add(`${i},${y},${z}`);
            }
            coords.delete(`${x},${y},${z}`);
            return Array.from(coords).map(s=>s.split(',').map(Number));
        }
        
        function isValidMove(board,x,y,z,val){
            return !getRelatedCoords(x,y,z).some(([rx,ry,rz])=>board[rz][ry][rx]===val);
        }
        
        function solve(board){
            const emptyCells=[];
            for(let z=0;z<SIZE;z++)for(let y=0;y<SIZE;y++)for(let x=0;x<SIZE;x++)if(board[z][y][x]===0)emptyCells.push([x,y,z]);
            if(!emptyCells.length)return true;
            const[x,y,z]=emptyCells[0],values=[...VALUES];
            shuffleArray(values);
            for(const val of values){
                if(isValidMove(board,x,y,z,val)){
                    board[z][y][x]=val;
                    if(solve(board))return true;
                    board[z][y][x]=0;
                }
            }
            return false;
        }
        
        function generateSolution(){const board=createBoard();solve(board);return board}
        
        function generatePuzzle(targetClues){
            const sol=generateSolution(),puzzle=sol.map(layer=>layer.map(row=>[...row])),allCells=[];
            for(let z=0;z<SIZE;z++)for(let y=0;y<SIZE;y++)for(let x=0;x<SIZE;x++)allCells.push([x,y,z]);
            shuffleArray(allCells);
            let currentClues=SIZE*SIZE*SIZE;
            while(currentClues>targetClues&&allCells.length>0){
                const[x,y,z]=allCells.pop();
                puzzle[z][y][x]=0;
                currentClues--;
            }
            return{puzzle,solution:sol};
        }
        
        function shuffleArray(array){for(let i=array.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[array[i],array[j]]=[array[j],array[i]]}}
        
        function getCandidateKey(x,y,z){return`${x},${y},${z}`}
        
        function toggleCandidate(x,y,z,num){
            const key=getCandidateKey(x,y,z);
            if(!candidates[key])candidates[key]=new Set();
            candidates[key].has(num)?candidates[key].delete(num):candidates[key].add(num);
            if(candidates[key].size===0)delete candidates[key];
        }
        
        function getCandidates(x,y,z){
            const key=getCandidateKey(x,y,z);
            return candidates[key]?Array.from(candidates[key]).sort():[];
        }
        
        function clearCandidates(x,y,z){delete candidates[getCandidateKey(x,y,z)]}
        
        function autoRemoveCandidates(x,y,z,num){
            if(num===0)return;
            getRelatedCoords(x,y,z).forEach(([rx,ry,rz])=>{
                if(board[rz][ry][rx]===0){
                    const key=getCandidateKey(rx,ry,rz);
                    if(candidates[key]&&candidates[key].has(num)){
                        candidates[key].delete(num);
                        if(candidates[key].size===0)delete candidates[key];
                    }
                }
            });
        }
        
        function getPossibleValues(x,y,z){
            if(board[z][y][x]!==0)return[];
            const used=new Set();
            getRelatedCoords(x,y,z).forEach(([rx,ry,rz])=>{
                if(board[rz][ry][rx]!==0)used.add(board[rz][ry][rx]);
            });
            return VALUES.filter(v=>!used.has(v));
        }
        
        function findNakedSingles(){
            const singles=[];
            for(let z=0;z<SIZE;z++)for(let y=0;y<SIZE;y++)for(let x=0;x<SIZE;x++){
                if(board[z][y][x]===0){
                    const possible=getPossibleValues(x,y,z);
                    if(possible.length===1)singles.push({x,y,z,value:possible[0],type:'naked'});
                }
            }
            return singles;
        }
        
        function findHiddenSingles(){
            const singles=[];
            for(let z=0;z<SIZE;z++)for(let y=0;y<SIZE;y++)for(let x=0;x<SIZE;x++){
                if(board[z][y][x]===0){
                    const possible=getPossibleValues(x,y,z);
                    for(const val of possible){
                        const relatedEmpty=getRelatedCoords(x,y,z).filter(([rx,ry,rz])=>board[rz][ry][rx]===0);
                        const canPlaceElsewhere=relatedEmpty.some(([rx,ry,rz])=>getPossibleValues(rx,ry,rz).includes(val));
                        if(!canPlaceElsewhere)singles.push({x,y,z,value:val,type:'hidden'});
                    }
                }
            }
            return singles;
        }
        
        function findConflicts(){
            const conflicts=[];
            for(let z=0;z<SIZE;z++)for(let y=0;y<SIZE;y++)for(let x=0;x<SIZE;x++){
                if(board[z][y][x]!==0&&!isValidMove(board,x,y,z,board[z][y][x])){
                    board[z][y][x]=0;
                    if(!isValidMove(board,x,y,z,board[z][y][x]))conflicts.push({x,y,z});
                    board[z][y][x]=board[z][y][x]||1;
                }
            }
            return conflicts;
        }
        
        function smartHint(){
            if(gameWon)return;
            const hintDisplay=document.getElementById('hintDisplay');
            
            const conflicts=findConflicts();
            if(conflicts.length>0){
                hintDisplay.textContent='❌ Conflicts detected! Check highlighted cells.';
                highlightCells(conflicts);
                return;
            }
            
            const nakedSingles=findNakedSingles();
            if(nakedSingles.length>0){
                const hint=nakedSingles[0];
                hintDisplay.textContent=`💡 Naked Single: Cell (${hint.x+1},${hint.y+1},${hint.z+1}) can only be ${hint.value}`;
                highlightCells([hint]);
                return;
            }
            
            const hiddenSingles=findHiddenSingles();
            if(hiddenSingles.length>0){
                const hint=hiddenSingles[0];
                hintDisplay.textContent=`🔍 Hidden Single: Only cell (${hint.x+1},${hint.y+1},${hint.z+1}) can have ${hint.value}`;
                highlightCells([hint]);
                return;
            }
            
            if(selectedCell){
                const{x,y,z}=selectedCell;
                if(board[z][y][x]===0){
                    board[z][y][x]=solution[z][y][x];
                    clearCandidates(x,y,z);
                    autoRemoveCandidates(x,y,z,solution[z][y][x]);
                    hintsUsed++;
                    hintDisplay.textContent=`💡 Hint: Placed ${solution[z][y][x]} in selected cell`;
                    updateBoard();
                    return;
                }
            }
            
            hintDisplay.textContent='🤔 No obvious moves found. Try analyzing candidates!';
        }
        
        function highlightCells(cells){
            document.querySelectorAll('.cell').forEach(cell=>cell.classList.remove('conflict'));
            cells.forEach(({x,y,z})=>{
                const cell=document.querySelector(`[data-x="${x}"][data-y="${y}"][data-z="${z}"]`);
                if(cell)cell.classList.add('conflict');
            });
            setTimeout(()=>document.querySelectorAll('.cell').forEach(cell=>cell.classList.remove('conflict')),3000);
        }
        
        function createVisualBoard(){
            const container=document.getElementById('board-container');
            container.innerHTML='';
            for(let z=0;z<SIZE;z++){
                const layerDiv=document.createElement('div');
                layerDiv.className='layer';
                layerDiv.innerHTML=`<div class="layer-title">Layer ${z+1}</div>`;
                const gridDiv=document.createElement('div');
                gridDiv.className='grid';
                for(let y=0;y<SIZE;y++)for(let x=0;x<SIZE;x++){
                    const cell=document.createElement('div');
                    cell.className='cell';
                    cell.dataset.x=x;
                    cell.dataset.y=y;
                    cell.dataset.z=z;
                    cell.onclick=()=>selectCell(x,y,z);
                    gridDiv.appendChild(cell);
                }
                layerDiv.appendChild(gridDiv);
                container.appendChild(layerDiv);
            }
        }
        
        function updateBoard(){
            const cells=document.querySelectorAll('.cell');
            cells.forEach(cell=>{
                const x=parseInt(cell.dataset.x),y=parseInt(cell.dataset.y),z=parseInt(cell.dataset.z),val=board[z][y][x];
                cell.className='cell';
                cell.innerHTML='';
                
                if(val!==0){
                    cell.textContent=val;
                    cell.classList.add(solution[z][y][x]===val?'completed':'error');
                }else{
                    const userCandidates=getCandidates(x,y,z);
                    if(userCandidates.length>0)cell.innerHTML=`<div class="candidates">${userCandidates.join('')}</div>`;
                }
                
                if(selectedCell&&selectedCell.x===x&&selectedCell.y===y&&selectedCell.z===z){
                    cell.classList.add(candidateMode&&val===0?'candidate-mode':'selected');
                    // Highlight related cells
                    if(!candidateMode||val!==0){
                        getRelatedCoords(x,y,z).forEach(([rx,ry,rz])=>{
                            const relatedCell=document.querySelector(`[data-x="${rx}"][data-y="${ry}"][data-z="${rz}"]`);
                            if(relatedCell)relatedCell.classList.add('related');
                        });
                    }
                }
            });
            updateStats();
            checkWin();
        }
        
        function selectCell(x,y,z){
            selectedCell={x,y,z};
            document.getElementById('hintDisplay').textContent='';
            updateBoard();
        }
        
        function toggleCandidateMode(){
            candidateMode=!candidateMode;
            const btn=document.getElementById('candidateBtn'),indicator=document.getElementById('modeIndicator');
            if(candidateMode){
                btn.classList.add('active');
                btn.textContent='Number Mode';
                indicator.textContent='Mode: Candidate Entry';
            }else{
                btn.classList.remove('active');
                btn.textContent='Candidate Mode';
                indicator.textContent='Mode: Number Entry';
            }
            updateBoard();
        }
        
        function selectNumber(num){
            if(!selectedCell||gameWon)return;
            const{x,y,z}=selectedCell;
            document.getElementById('hintDisplay').textContent='';
            
            if(num===0){
                board[z][y][x]=0;
                clearCandidates(x,y,z);
            }else if(candidateMode){
                if(board[z][y][x]===0)toggleCandidate(x,y,z,num);
            }else{
                board[z][y][x]=num;
                clearCandidates(x,y,z);
                autoRemoveCandidates(x,y,z,num);
            }
            updateBoard();
        }
        
        function newGame(){
            const clues=parseInt(document.getElementById('clues').value),{puzzle,solution:sol}=generatePuzzle(clues);
            board=puzzle;
            solution=sol;
            candidates={};
            selectedCell=null;
            hintsUsed=0;
            gameWon=false;
            document.getElementById('hintDisplay').textContent='';
            startTimer();
            updateBoard();
        }
        
        function resetGame(){
            for(let z=0;z<SIZE;z++)for(let y=0;y<SIZE;y++)for(let x=0;x<SIZE;x++){
                if(board[z][y][x]!==solution[z][y][x]){
                    board[z][y][x]=0;
                    clearCandidates(x,y,z);
                }
            }
            selectedCell=null;
            document.getElementById('hintDisplay').textContent='';
            updateBoard();
        }
        
        function startTimer(){
            startTime=Date.now();
            clearInterval(timerInterval);
            timerInterval=setInterval(updateTimer,1000);
        }
        
        function updateTimer(){
            if(!startTime)return;
            const elapsed=Math.floor((Date.now()-startTime)/1000),minutes=Math.floor(elapsed/60),seconds=elapsed%60;
            document.getElementById('timer').textContent=`${minutes.toString().padStart(2,'0')}:${seconds.toString().padStart(2,'0')}`;
        }
        
        function updateStats(){
            let filled=0;
            for(let z=0;z<SIZE;z++)for(let y=0;y<SIZE;y++)for(let x=0;x<SIZE;x++)if(board[z][y][x]!==0)filled++;
            document.getElementById('filled').textContent=`${filled}/${SIZE*SIZE*SIZE}`;
            document.getElementById('hints').textContent=hintsUsed;
        }
        
        function checkWin(){
            for(let z=0;z<SIZE;z++)for(let y=0;y<SIZE;y++)for(let x=0;x<SIZE;x++)if(board[z][y][x]!==solution[z][y][x])return false;
            gameWon=true;
            clearInterval(timerInterval);
            document.getElementById('finalTime').textContent=document.getElementById('timer').textContent;
            document.getElementById('winModal').style.display='block';
        }
        
        function closeModal(){
            document.getElementById('winModal').style.display='none';
            newGame();
        }
        
        function toggleKeypad(){
            keypadMinimized=!keypadMinimized;
            const numberPad=document.getElementById('numberPad');
            const toggleBtn=document.querySelector('.keypad-toggle');
            
            if(keypadMinimized){
                numberPad.classList.add('minimized');
                toggleBtn.textContent='+';
            }else{
                numberPad.classList.remove('minimized');
                toggleBtn.textContent='−';
            }
        }
        
        function initKeypadDrag(){
            const keypad=document.getElementById('floatingKeypad');
            const header=document.getElementById('keypadHeader');
            
            function startDrag(e){
                isDragging=true;
                keypad.classList.add('dragging');
                
                const rect=keypad.getBoundingClientRect();
                const clientX=e.touches?e.touches[0].clientX:e.clientX;
                const clientY=e.touches?e.touches[0].clientY:e.clientY;
                
                dragOffset.x=clientX-rect.left;
                dragOffset.y=clientY-rect.top;
                
                e.preventDefault();
            }
            
            function drag(e){
                if(!isDragging)return;
                
                const clientX=e.touches?e.touches[0].clientX:e.clientX;
                const clientY=e.touches?e.touches[0].clientY:e.clientY;
                
                const newX=clientX-dragOffset.x;
                const newY=clientY-dragOffset.y;
                
                const maxX=window.innerWidth-keypad.offsetWidth;
                const maxY=window.innerHeight-keypad.offsetHeight;
                
                const clampedX=Math.max(0,Math.min(maxX,newX));
                const clampedY=Math.max(0,Math.min(maxY,newY));
                
                keypad.style.left=clampedX+'px';
                keypad.style.top=clampedY+'px';
                keypad.style.right='auto';
                keypad.style.bottom='auto';
                
                e.preventDefault();
            }
            
            function stopDrag(){
                isDragging=false;
                keypad.classList.remove('dragging');
            }
            
            header.addEventListener('mousedown',startDrag);
            header.addEventListener('touchstart',startDrag);
            
            document.addEventListener('mousemove',drag);
            document.addEventListener('touchmove',drag);
            
            document.addEventListener('mouseup',stopDrag);
            document.addEventListener('touchend',stopDrag);
        }
        
        document.addEventListener('keydown',e=>{
            if(e.key>='1'&&e.key<='5')selectNumber(parseInt(e.key));
            else if(e.key==='Delete'||e.key==='Backspace')selectNumber(0);
            else if(e.key===' '){e.preventDefault();toggleCandidateMode();}
            else if(e.key.toLowerCase()==='h')smartHint();
        });
        
        document.getElementById('clues').addEventListener('input',function(){
            document.getElementById('clues-value').textContent=this.value;
        });
        
        window.addEventListener('load',()=>{
            createVisualBoard();
            initKeypadDrag();
            newGame();
        });
    </script>
</body>
</html>
