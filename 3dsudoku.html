<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>5x5x5 Cubic Sudoku</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Courier New', monospace; background: #1a1a1a; color: #fff; overflow-x: auto; }
        .container { max-width: 1400px; margin: 0 auto; padding: 20px; }
        .header { text-align: center; margin-bottom: 20px; }
        .controls { display: flex; justify-content: center; gap: 15px; margin-bottom: 20px; flex-wrap: wrap; }
        .btn { padding: 8px 16px; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; transition: all 0.3s; }
        .btn-primary { background: #007bff; color: white; }
        .btn-secondary { background: #6c757d; color: white; }
        .btn-success { background: #28a745; color: white; }
        .btn-danger { background: #dc3545; color: white; }
        .btn-warning { background: #ffc107; color: #212529; }
        .btn:hover { opacity: 0.8; transform: translateY(-1px); }
        .btn.active { background: #28a745; }
        .timer { font-size: 18px; font-weight: bold; color: #ffd700; }
        .difficulty-slider { display: flex; align-items: center; gap: 10px; }
        .difficulty-slider label { color: #ffd700; font-weight: bold; }
        .slider { width: 150px; height: 6px; border-radius: 3px; background: #333; outline: none; }
        .slider::-webkit-slider-thumb { appearance: none; width: 20px; height: 20px; border-radius: 50%; background: #007bff; cursor: pointer; }
        .slider::-moz-range-thumb { width: 20px; height: 20px; border-radius: 50%; background: #007bff; cursor: pointer; border: none; }
        .board-container { display: flex; justify-content: center; gap: 20px; flex-wrap: wrap; }
        .layer { border: 3px solid #444; margin: 5px; background: #2a2a2a; border-radius: 8px; padding: 10px; }
        .layer-title { text-align: center; margin-bottom: 10px; color: #ffd700; font-weight: bold; }
        .grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 2px; }
        .cell { 
            width: 40px; height: 40px; border: 1px solid #666; background: #333; 
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; font-size: 16px; font-weight: bold; position: relative;
            transition: all 0.2s;
        }
        .cell:hover { background: #444; }
        .cell.selected { background: #007bff !important; }
        .cell.given { background: #4a4a4a; color: #ffd700; }
        .cell.error { background: #dc3545 !important; }
        .cell.completed { background: #28a745 !important; }
        .cell.candidate-mode { background: #6c5ce7 !important; }
        .candidates { 
            font-size: 8px; 
            position: absolute; 
            top: 2px; 
            left: 2px; 
            color: #ffd700;
            line-height: 1.1;
            max-width: 36px;
            word-wrap: break-word;
        }
        .number-pad { display: grid; grid-template-columns: repeat(6, 1fr); gap: 5px; margin: 20px auto; max-width: 300px; }
        .num-btn { width: 40px; height: 40px; border: 1px solid #666; background: #333; color: #fff; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 16px; border-radius: 4px; }
        .num-btn:hover { background: #444; }
        .mode-indicator { 
            text-align: center; 
            margin-bottom: 10px; 
            font-size: 14px; 
            color: #ffd700;
            font-weight: bold;
        }
        .stats { display: flex; justify-content: center; gap: 20px; margin-top: 20px; }
        .stat { text-align: center; }
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); }
        .modal-content { background: #2a2a2a; margin: 15% auto; padding: 20px; border-radius: 8px; width: 300px; text-align: center; }
        .instructions { 
            background: #2a2a2a; 
            padding: 15px; 
            border-radius: 8px; 
            margin-bottom: 20px; 
            font-size: 14px; 
            line-height: 1.4;
        }
        .instructions h3 { color: #ffd700; margin-bottom: 10px; }
        .instructions ul { margin-left: 20px; }
        .instructions li { margin-bottom: 5px; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>5x5x5 Cubic Sudoku</h1>
            <div class="timer">Time: <span id="timer">00:00</span></div>
        </div>
        
        <div class="instructions">
            <h3>How to play:</h3>
            <ul>
                <li><strong>Number Mode:</strong> Click a cell and enter numbers 1-5 to fill cells</li>
                <li><strong>Candidate Mode:</strong> Click a cell and enter numbers to add/remove candidates</li>
                <li><strong>Toggle modes:</strong> Use the "Candidate Mode" button or press 'Space' key</li>
                <li><strong>Clear:</strong> Use the ✕ button or Delete/Backspace key</li>
                <li><strong>Keyboard:</strong> Use number keys 1-5 to enter values</li>
            </ul>
        </div>
        
        <div class="controls">
            <button class="btn btn-primary" onclick="newGame()">New Game</button>
            <button class="btn btn-warning" id="candidateBtn" onclick="toggleCandidateMode()">Candidate Mode</button>
            <button class="btn btn-success" onclick="hint()">Hint</button>
            <button class="btn btn-danger" onclick="resetGame()">Reset</button>
            <div class="difficulty-slider">
                <label for="clues">Clues: <span id="clues-value">50</span></label>
                <input type="range" id="clues" min="10" max="100" value="50" class="slider">
            </div>
        </div>
        
        <div class="mode-indicator" id="modeIndicator">Mode: Number Entry</div>
        
        <div class="board-container" id="board-container"></div>
        
        <div class="number-pad">
            <div class="num-btn" onclick="selectNumber(1)">1</div>
            <div class="num-btn" onclick="selectNumber(2)">2</div>
            <div class="num-btn" onclick="selectNumber(3)">3</div>
            <div class="num-btn" onclick="selectNumber(4)">4</div>
            <div class="num-btn" onclick="selectNumber(5)">5</div>
            <div class="num-btn" onclick="selectNumber(0)">✕</div>
        </div>
        
        <div class="stats">
            <div class="stat">
                <div>Filled</div>
                <div id="filled">0/125</div>
            </div>
            <div class="stat">
                <div>Hints Used</div>
                <div id="hints">0</div>
            </div>
        </div>
    </div>
    
    <div id="winModal" class="modal">
        <div class="modal-content">
            <h2>Congratulations!</h2>
            <p>You solved the puzzle!</p>
            <p>Time: <span id="finalTime"></span></p>
            <button class="btn btn-primary" onclick="closeModal()">New Game</button>
        </div>
    </div>

    <script>
        const SIZE = 5;
        const VALUES = [1, 2, 3, 4, 5];
        
        let board = [];
        let solution = [];
        let candidates = {}; // Store user-entered candidates
        let selectedCell = null;
        let startTime = null;
        let timerInterval = null;
        let candidateMode = false;
        let hintsUsed = 0;
        let gameWon = false;
        
        // Initialize empty board
        function createBoard() {
            return Array(SIZE).fill().map(() => 
                Array(SIZE).fill().map(() => 
                    Array(SIZE).fill(0)
                )
            );
        }
        
        // Get coordinates that share constraints with (x,y,z)
        function getRelatedCoords(x, y, z) {
            const coords = new Set();
            for (let i = 0; i < SIZE; i++) {
                coords.add(`${x},${y},${i}`); // same z-line
                coords.add(`${x},${i},${z}`); // same y-line  
                coords.add(`${i},${y},${z}`); // same x-line
            }
            coords.delete(`${x},${y},${z}`);
            return Array.from(coords).map(s => s.split(',').map(Number));
        }
        
        // Check if placing val at (x,y,z) is valid
        function isValidMove(board, x, y, z, val) {
            const related = getRelatedCoords(x, y, z);
            for (const [rx, ry, rz] of related) {
                if (board[rz][ry][rx] === val) return false;
            }
            return true;
        }
        
        // Simple backtracking solver with randomization
        function solve(board) {
            const emptyCells = [];
            for (let z = 0; z < SIZE; z++) {
                for (let y = 0; y < SIZE; y++) {
                    for (let x = 0; x < SIZE; x++) {
                        if (board[z][y][x] === 0) {
                            emptyCells.push([x, y, z]);
                        }
                    }
                }
            }
            
            if (emptyCells.length === 0) return true;
            
            // Try first empty cell
            const [x, y, z] = emptyCells[0];
            const values = [...VALUES];
            shuffleArray(values);
            
            for (const val of values) {
                if (isValidMove(board, x, y, z, val)) {
                    board[z][y][x] = val;
                    if (solve(board)) return true;
                    board[z][y][x] = 0;
                }
            }
            return false;
        }
        
        // Generate random complete solution
        function generateSolution() {
            const board = createBoard();
            solve(board);
            return board;
        }
        
        // Generate puzzle by removing cells from solution
        function generatePuzzle(targetClues) {
            const sol = generateSolution();
            const puzzle = sol.map(layer => layer.map(row => [...row]));
            
            const allCells = [];
            for (let z = 0; z < SIZE; z++) {
                for (let y = 0; y < SIZE; y++) {
                    for (let x = 0; x < SIZE; x++) {
                        allCells.push([x, y, z]);
                    }
                }
            }
            shuffleArray(allCells);
            
            let currentClues = SIZE * SIZE * SIZE;
            
            while (currentClues > targetClues && allCells.length > 0) {
                const [x, y, z] = allCells.pop();
                puzzle[z][y][x] = 0;
                currentClues--;
            }
            
            return { puzzle, solution: sol };
        }
        
        // Utility function to shuffle array
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }
        
        // Get key for candidates storage
        function getCandidateKey(x, y, z) {
            return `${x},${y},${z}`;
        }
        
        // Toggle candidate for a cell
        function toggleCandidate(x, y, z, num) {
            const key = getCandidateKey(x, y, z);
            if (!candidates[key]) {
                candidates[key] = new Set();
            }
            
            if (candidates[key].has(num)) {
                candidates[key].delete(num);
            } else {
                candidates[key].add(num);
            }
            
            // Remove empty candidate sets
            if (candidates[key].size === 0) {
                delete candidates[key];
            }
        }
        
        // Get candidates for a cell
        function getCandidates(x, y, z) {
            const key = getCandidateKey(x, y, z);
            return candidates[key] ? Array.from(candidates[key]).sort() : [];
        }
        
        // Clear candidates for a cell
        function clearCandidates(x, y, z) {
            const key = getCandidateKey(x, y, z);
            delete candidates[key];
        }
        
        // Auto-remove candidates when numbers are placed
        function autoRemoveCandidates(x, y, z, num) {
            if (num === 0) return; // Don't remove if clearing cell
            
            const relatedCoords = getRelatedCoords(x, y, z);
            
            // Remove the placed number from candidates in related cells
            for (const [rx, ry, rz] of relatedCoords) {
                if (board[rz][ry][rx] === 0) { // Only affect empty cells
                    const key = getCandidateKey(rx, ry, rz);
                    if (candidates[key] && candidates[key].has(num)) {
                        candidates[key].delete(num);
                        if (candidates[key].size === 0) {
                            delete candidates[key];
                        }
                    }
                }
            }
        }
        
        // Create visual board
        function createVisualBoard() {
            const container = document.getElementById('board-container');
            container.innerHTML = '';
            
            for (let z = 0; z < SIZE; z++) {
                const layerDiv = document.createElement('div');
                layerDiv.className = 'layer';
                layerDiv.innerHTML = `<div class="layer-title">Layer ${z + 1}</div>`;
                
                const gridDiv = document.createElement('div');
                gridDiv.className = 'grid';
                
                for (let y = 0; y < SIZE; y++) {
                    for (let x = 0; x < SIZE; x++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.dataset.x = x;
                        cell.dataset.y = y;
                        cell.dataset.z = z;
                        cell.onclick = () => selectCell(x, y, z);
                        gridDiv.appendChild(cell);
                    }
                }
                
                layerDiv.appendChild(gridDiv);
                container.appendChild(layerDiv);
            }
        }
        
        // Update visual board
        function updateBoard() {
            const cells = document.querySelectorAll('.cell');
            cells.forEach(cell => {
                const x = parseInt(cell.dataset.x);
                const y = parseInt(cell.dataset.y);
                const z = parseInt(cell.dataset.z);
                const val = board[z][y][x];
                
                cell.className = 'cell';
                cell.innerHTML = '';
                
                if (val !== 0) {
                    cell.textContent = val;
                    if (solution[z][y][x] === val) {
                        cell.classList.add('completed');
                    } else {
                        cell.classList.add('error');
                    }
                } else {
                    // Show user candidates
                    const userCandidates = getCandidates(x, y, z);
                    if (userCandidates.length > 0) {
                        cell.innerHTML = `<div class="candidates">${userCandidates.join('')}</div>`;
                    }
                }
                
                if (selectedCell && selectedCell.x === x && selectedCell.y === y && selectedCell.z === z) {
                    if (candidateMode && val === 0) {
                        cell.classList.add('candidate-mode');
                    } else {
                        cell.classList.add('selected');
                    }
                }
            });
            
            updateStats();
            checkWin();
        }
        
        // Select cell
        function selectCell(x, y, z) {
            selectedCell = { x, y, z };
            updateBoard();
        }
        
        // Toggle candidate mode
        function toggleCandidateMode() {
            candidateMode = !candidateMode;
            const btn = document.getElementById('candidateBtn');
            const indicator = document.getElementById('modeIndicator');
            
            if (candidateMode) {
                btn.classList.add('active');
                btn.textContent = 'Number Mode';
                indicator.textContent = 'Mode: Candidate Entry';
            } else {
                btn.classList.remove('active');
                btn.textContent = 'Candidate Mode';
                indicator.textContent = 'Mode: Number Entry';
            }
            
            updateBoard();
        }
        
        // Select number from pad
        function selectNumber(num) {
            if (!selectedCell || gameWon) return;
            
            const { x, y, z } = selectedCell;
            
            if (num === 0) {
                // Clear cell
                board[z][y][x] = 0;
                clearCandidates(x, y, z);
            } else if (candidateMode) {
                // Toggle candidate
                if (board[z][y][x] === 0) {
                    toggleCandidate(x, y, z, num);
                }
            } else {
                // Set number
                board[z][y][x] = num;
                clearCandidates(x, y, z); // Clear candidates when number is set
                autoRemoveCandidates(x, y, z, num); // Auto-remove from related cells
            }
            
            updateBoard();
        }
        
        // New game
        function newGame() {
            const clues = parseInt(document.getElementById('clues').value);
            const { puzzle, solution: sol } = generatePuzzle(clues);
            
            board = puzzle;
            solution = sol;
            candidates = {}; // Clear all candidates
            selectedCell = null;
            hintsUsed = 0;
            gameWon = false;
            
            startTimer();
            updateBoard();
        }
        
        // Hint
        function hint() {
            if (!selectedCell || gameWon) return;
            
            const { x, y, z } = selectedCell;
            if (board[z][y][x] === 0) {
                board[z][y][x] = solution[z][y][x];
                clearCandidates(x, y, z); // Clear candidates when hint is used
                hintsUsed++;
                updateBoard();
            }
        }
        
        // Reset game
        function resetGame() {
            // Reset to initial puzzle state
            for (let z = 0; z < SIZE; z++) {
                for (let y = 0; y < SIZE; y++) {
                    for (let x = 0; x < SIZE; x++) {
                        if (board[z][y][x] !== solution[z][y][x]) {
                            board[z][y][x] = 0;
                            clearCandidates(x, y, z);
                        }
                    }
                }
            }
            selectedCell = null;
            updateBoard();
        }
        
        // Timer functions
        function startTimer() {
            startTime = Date.now();
            clearInterval(timerInterval);
            timerInterval = setInterval(updateTimer, 1000);
        }
        
        function updateTimer() {
            if (!startTime) return;
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            document.getElementById('timer').textContent = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }
        
        // Update stats
        function updateStats() {
            let filled = 0;
            for (let z = 0; z < SIZE; z++) {
                for (let y = 0; y < SIZE; y++) {
                    for (let x = 0; x < SIZE; x++) {
                        if (board[z][y][x] !== 0) filled++;
                    }
                }
            }
            document.getElementById('filled').textContent = `${filled}/${SIZE * SIZE * SIZE}`;
            document.getElementById('hints').textContent = hintsUsed;
        }
        
        // Check win condition
        function checkWin() {
            for (let z = 0; z < SIZE; z++) {
                for (let y = 0; y < SIZE; y++) {
                    for (let x = 0; x < SIZE; x++) {
                        if (board[z][y][x] !== solution[z][y][x]) {
                            return false;
                        }
                    }
                }
            }
            
            // Won!
            gameWon = true;
            clearInterval(timerInterval);
            document.getElementById('finalTime').textContent = 
                document.getElementById('timer').textContent;
            document.getElementById('winModal').style.display = 'block';
        }
        
        // Close modal
        function closeModal() {
            document.getElementById('winModal').style.display = 'none';
            newGame();
        }
        
        // Keyboard support
        document.addEventListener('keydown', (e) => {
            if (e.key >= '1' && e.key <= '5') {
                selectNumber(parseInt(e.key));
            } else if (e.key === 'Delete' || e.key === 'Backspace') {
                selectNumber(0);
            } else if (e.key.toLowerCase() === 'c') {
                toggleCandidateMode();
            }
        });
        
        // Slider update
        document.getElementById('clues').addEventListener('input', function() {
            document.getElementById('clues-value').textContent = this.value;
        });
        
        // Initialize game
        window.addEventListener('load', function() {
            createVisualBoard();
            newGame();
        });
    </script>
</body>
</html>
