<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sudoku Companion App</title>
    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter font from Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* Light blue-gray background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
        }
        .container {
            background-color: #ffffff;
            border-radius: 16px; /* More rounded corners */
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1); /* Softer shadow */
            padding: 30px;
            width: 100%;
            max-width: 600px;
            text-align: center;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        h1 {
            color: #2c3e50; /* Darker title */
            font-size: 2.5rem; /* Larger title */
            font-weight: 700;
            margin-bottom: 20px;
        }
        .sudoku-grid {
            display: grid;
            border: 3px solid #2c3e50; /* Darker border for the main grid */
            margin: 20px auto;
            max-width: 100%;
            aspect-ratio: 1 / 1; /* Keep grid square */
        }
        .sudoku-grid.grid-9x9 {
            grid-template-columns: repeat(9, 1fr);
            grid-template-rows: repeat(9, 1fr);
        }
        .sudoku-grid.grid-6x6 {
            grid-template-columns: repeat(6, 1fr);
            grid-template-rows: repeat(6, 1fr);
        }
        .sudoku-cell {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.2rem;
            font-weight: 600;
            border: 1px solid #d1d5db; /* Light gray border for cells */
            box-sizing: border-box;
            background-color: #f9fafb; /* Very light background for cells */
            color: #374151; /* Dark text for numbers */
        }
        .sudoku-cell.fixed {
            background-color: #e2e8f0; /* Slightly darker for fixed numbers */
            font-weight: 700;
            color: #1f2937; /* Even darker for fixed numbers */
        }
        .sudoku-cell input {
            width: 100%;
            height: 100%;
            text-align: center;
            border: none;
            outline: none;
            font-size: 1.2rem;
            font-weight: 600;
            background-color: transparent;
            color: #4f46e5; /* Purple for user input */
            padding: 0;
            -moz-appearance: textfield; /* Hide arrows for number input in Firefox */
        }
        .sudoku-cell input::-webkit-outer-spin-button,
        .sudoku-cell input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        /* Borders for 3x3 (or 2x3 for 6x6) blocks */
        .sudoku-grid.grid-9x9 .sudoku-cell:nth-child(3n) { border-right: 2px solid #6b7280; }
        .sudoku-grid.grid-9x9 .sudoku-cell:nth-child(9n) { border-right: 3px solid #2c3e50; }
        .sudoku-grid.grid-9x9 .sudoku-cell:nth-child(n):nth-child(3n+1) { border-left: 2px solid #6b7280; }
        .sudoku-grid.grid-9x9 .sudoku-cell:nth-child(n):nth-child(9n+1) { border-left: 3px solid #2c3e50; }
        .sudoku-grid.grid-9x9 .sudoku-cell:nth-child(n + 1):nth-child(-n + 27) { border-top: 3px solid #2c3e50; }
        .sudoku-grid.grid-9x9 .sudoku-cell:nth-child(n + 28):nth-child(-n + 54) { border-top: 2px solid #6b7280; }
        .sudoku-grid.grid-9x9 .sudoku-cell:nth-child(n + 55):nth-child(-n + 81) { border-top: 2px solid #6b7280; }
        .sudoku-grid.grid-9x9 .sudoku-cell:nth-child(n + 1):nth-child(-n + 81):nth-child(27n + 1) ~ .sudoku-cell:nth-child(27n + 27) { border-bottom: 3px solid #2c3e50; }
        .sudoku-grid.grid-9x9 .sudoku-cell:nth-child(n + 1):nth-child(-n + 81):nth-child(9n + 1) ~ .sudoku-cell:nth-child(9n + 9) { border-bottom: 2px solid #6b7280; }

        /* Specific borders for 6x6 grid */
        .sudoku-grid.grid-6x6 .sudoku-cell:nth-child(3n) { border-right: 2px solid #6b7280; }
        .sudoku-grid.grid-6x6 .sudoku-cell:nth-child(6n) { border-right: 3px solid #2c3e50; }
        .sudoku-grid.grid-6x6 .sudoku-cell:nth-child(n):nth-child(3n+1) { border-left: 2px solid #6b7280; }
        .sudoku-grid.grid-6x6 .sudoku-cell:nth-child(n):nth-child(6n+1) { border-left: 3px solid #2c3e50; }
        .sudoku-grid.grid-6x6 .sudoku-cell:nth-child(n + 1):nth-child(-n + 12) { border-top: 3px solid #2c3e50; }
        .sudoku-grid.grid-6x6 .sudoku-cell:nth-child(n + 13):nth-child(-n + 24) { border-top: 2px solid #6b7280; }
        .sudoku-grid.grid-6x6 .sudoku-cell:nth-child(n + 25):nth-child(-n + 36) { border-top: 2px solid #6b7280; }
        .sudoku-grid.grid-6x6 .sudoku-cell:nth-child(n + 1):nth-child(-n + 36):nth-child(12n + 1) ~ .sudoku-cell:nth-child(12n + 12) { border-bottom: 3px solid #2c3e50; }
        .sudoku-grid.grid-6x6 .sudoku-cell:nth-child(n + 1):nth-child(-n + 36):nth-child(6n + 1) ~ .sudoku-cell:nth-child(6n + 6) { border-bottom: 2px solid #6b7280; }


        .button {
            padding: 12px 25px;
            border-radius: 10px; /* Slightly more rounded buttons */
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            background-image: linear-gradient(to right, #6366f1, #8b5cf6); /* Gradient background */
            color: white;
            border: none;
        }
        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.15);
            opacity: 0.9;
        }
        .button-secondary {
            background-image: linear-gradient(to right, #4f46e5, #7c3aed); /* Different gradient for secondary */
        }
        .button-danger {
            background-image: linear-gradient(to right, #ef4444, #dc2626); /* Red gradient for danger */
        }
        .button:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        .message-box {
            background-color: #ecfdf5; /* Light green for success */
            border: 1px solid #a7f3d0;
            color: #065f46;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            display: none; /* Hidden by default */
        }
        .message-box.error {
            background-color: #fee2e2; /* Light red for error */
            border-color: #fca5a5;
            color: #991b1b;
        }
        .message-box.show {
            display: block;
        }
        .input-group {
            display: flex;
            gap: 10px;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
        }
        .input-group input[type="file"] {
            display: none; /* Hide default file input */
        }
        .input-group .custom-file-upload {
            border: 1px solid #ccc;
            display: inline-block;
            padding: 6px 12px;
            cursor: pointer;
            border-radius: 8px;
            background-color: #f0f4f8;
            color: #374151;
            transition: background-color 0.2s;
        }
        .input-group .custom-file-upload:hover {
            background-color: #e2e8f0;
        }
        #videoElement {
            width: 100%;
            max-width: 400px;
            height: auto;
            border-radius: 12px;
            margin: 20px auto;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            background-color: #000; /* Black background for video area */
        }
        #canvasElement {
            display: none; /* Hidden by default */
        }
        #qrCodeScanner {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }
        .hidden {
            display: none !important;
        }
    </style>
    <!-- Include jsQR library for QR code scanning -->
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>

    <!-- Sudoku scripts (assumed to be available in the same environment) -->
    <script src="sudoku.js"></script>
    <script src="sudoku6x6.js"></script>
</head>
<body>
    <div class="container">
        <h1>Sudoku Companion</h1>

        <!-- QR Code Scanner Section -->
        <div id="qrCodeScanner">
            <video id="videoElement" autoplay playsinline></video>
            <canvas id="canvasElement" class="hidden"></canvas>
            <div class="input-group">
                <button id="startScanButton" class="button">Start QR Scan</button>
                <button id="stopScanButton" class="button button-danger hidden">Stop Scan</button>
                <label for="fileInput" class="custom-file-upload">
                    Upload QR Image
                </label>
                <input type="file" id="fileInput" accept="image/*">
            </div>
        </div>

        <!-- Puzzle Display Section -->
        <div id="puzzleDisplay" class="hidden">
            <p class="text-lg font-semibold text-gray-700 mb-4" id="puzzleInfo"></p>
            <div id="sudokuGrid" class="sudoku-grid">
                <!-- Sudoku cells will be dynamically generated here -->
            </div>
            <div class="input-group">
                <button id="checkButton" class="button button-secondary">Check Solution</button>
                <button id="solveButton" class="button button-secondary">Solve Puzzle</button>
                <button id="clearButton" class="button button-danger">Clear Board</button>
            </div>
        </div>

        <!-- Message Box for feedback -->
        <div id="messageBox" class="message-box"></div>
    </div>

    <script>
        // DOM elements
        const videoElement = document.getElementById('videoElement');
        const canvasElement = document.getElementById('canvasElement');
        const canvasContext = canvasElement.getContext('2d');
        const startScanButton = document.getElementById('startScanButton');
        const stopScanButton = document.getElementById('stopScanButton');
        const fileInput = document.getElementById('fileInput');
        const qrCodeScannerDiv = document.getElementById('qrCodeScanner');
        const puzzleDisplayDiv = document.getElementById('puzzleDisplay');
        const sudokuGridDiv = document.getElementById('sudokuGrid');
        const puzzleInfo = document.getElementById('puzzleInfo');
        const checkButton = document.getElementById('checkButton');
        const solveButton = document.getElementById('solveButton');
        const clearButton = document.getElementById('clearButton');
        const messageBox = document.getElementById('messageBox');

        let sudoku9x9; // Declare but don't initialize here
        let sudoku6x6; // Declare but don't initialize here

        let currentStream; // To hold the camera stream
        let scanInterval; // To hold the interval for scanning QR codes
        let currentPuzzle = null; // Stores the active puzzle data
        let currentPuzzleType = null; // '9x9' or '6x6'
        let initialPuzzleState = []; // To store the original puzzle for clearing

        // --- Message Box Functions ---
        /**
         * Displays a message in the message box.
         * @param {string} message - The message to display.
         * @param {boolean} isError - True if it's an error message, false for success.
         */
        function showMessage(message, isError = false) {
            messageBox.textContent = message;
            messageBox.classList.remove('show', 'error');
            if (isError) {
                messageBox.classList.add('error');
            }
            messageBox.classList.add('show');
            // Hide after 5 seconds
            setTimeout(() => {
                messageBox.classList.remove('show');
            }, 5000);
        }

        // --- QR Code Scanning Functions ---
        /**
         * Starts the camera and begins scanning for QR codes.
         */
        async function startScanner() {
            try {
                // Request camera access
                const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
                videoElement.srcObject = stream;
                currentStream = stream;

                // Ensure video is playing before drawing to canvas
                videoElement.onloadedmetadata = () => {
                    videoElement.play();
                    // Set canvas dimensions to match video
                    canvasElement.width = videoElement.videoWidth;
                    canvasElement.height = videoElement.videoHeight;
                    startScanInterval();
                };

                startScanButton.classList.add('hidden');
                stopScanButton.classList.remove('hidden');
                showMessage('Camera started. Scanning for QR codes...', false);

            } catch (err) {
                console.error("Error accessing camera:", err);
                showMessage('Could not start camera. Please ensure camera access is granted.', true);
            }
        }

        /**
         * Stops the camera stream and scanning interval.
         */
        function stopScanner() {
            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
                videoElement.srcObject = null;
                currentStream = null;
            }
            if (scanInterval) {
                clearInterval(scanInterval);
                scanInterval = null;
            }
            startScanButton.classList.remove('hidden');
            stopScanButton.classList.add('hidden');
            showMessage('QR scan stopped.', false);
        }

        /**
         * Initiates the interval for continuously scanning for QR codes from the video feed.
         */
        function startScanInterval() {
            if (scanInterval) clearInterval(scanInterval); // Clear any existing interval

            scanInterval = setInterval(() => {
                if (videoElement.readyState === videoElement.HAVE_ENOUGH_DATA) {
                    canvasContext.drawImage(videoElement, 0, 0, canvasElement.width, canvasElement.height);
                    const imageData = canvasContext.getImageData(0, 0, canvasElement.width, canvasElement.height);
                    const code = jsQR(imageData.data, imageData.width, imageData.height, {
                        inversionAttempts: "dontInvert",
                    });

                    if (code) {
                        console.log("QR Code detected:", code.data);
                        handleQRCodeData(code.data);
                        stopScanner(); // Stop scanning once a QR code is found
                    }
                }
            }, 100); // Scan every 100ms
        }

        /**
         * Handles QR code data, parsing it into Sudoku puzzles.
         * @param {string} qrData - The data string from the QR code.
         */
        function handleQRCodeData(qrData) {
            try {
                const puzzlesData = qrData.split('|');
                if (puzzlesData.length === 0) {
                    showMessage('No Sudoku puzzles found in QR code data.', true);
                    return;
                }

                // For simplicity, let's just load the first puzzle found.
                // In a real app, you might want a list to choose from.
                const firstPuzzleString = puzzlesData[0];
                loadPuzzle(firstPuzzleString);
                showMessage('Sudoku puzzle loaded from QR code!', false);

            } catch (error) {
                console.error("Error processing QR code data:", error);
                showMessage('Error processing QR code data. Invalid format.', true);
            }
        }

        /**
         * Handles file input for QR code images.
         * @param {Event} event - The file input change event.
         */
        fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    canvasElement.width = img.width;
                    canvasElement.height = img.height;
                    canvasContext.drawImage(img, 0, 0, img.width, img.height);
                    const imageData = canvasContext.getImageData(0, 0, img.width, img.height);
                    const code = jsQR(imageData.data, imageData.width, imageData.height, {
                        inversionAttempts: "dontInvert",
                    });

                    if (code) {
                        console.log("QR Code detected from image:", code.data);
                        handleQRCodeData(code.data);
                    } else {
                        showMessage('No QR code found in the uploaded image.', true);
                    }
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        });

        // --- Sudoku Game Logic Functions ---
        /**
         * Loads and displays a Sudoku puzzle on the grid.
         * @param {string} puzzleString - The Sudoku puzzle in string format.
         */
        function loadPuzzle(puzzleString) {
            let board;
            if (puzzleString.length === 81) { // 9x9 Sudoku
                currentPuzzleType = '9x9';
                board = sudoku9x9.convertToMatrix(puzzleString);
                puzzleInfo.textContent = '9x9 Sudoku Puzzle';
                sudokuGridDiv.classList.remove('grid-6x6');
                sudokuGridDiv.classList.add('grid-9x9');
            } else if (puzzleString.length === 36) { // 6x6 Sudoku
                currentPuzzleType = '6x6';
                board = sudoku6x6.convertToArray(puzzleString);
                puzzleInfo.textContent = '6x6 Sudoku Puzzle';
                sudokuGridDiv.classList.remove('grid-9x9');
                sudokuGridDiv.classList.add('grid-6x6');
            } else {
                showMessage('Invalid Sudoku puzzle string length.', true);
                return;
            }

            currentPuzzle = board;
            initialPuzzleState = JSON.parse(JSON.stringify(board)); // Deep copy for clearing
            renderSudokuGrid(board);

            qrCodeScannerDiv.classList.add('hidden');
            puzzleDisplayDiv.classList.remove('hidden');
        }

        /**
         * Renders the Sudoku grid based on the provided board matrix.
         * @param {Array<Array<number>>} board - The Sudoku board as a 2D array.
         */
        function renderSudokuGrid(board) {
            sudokuGridDiv.innerHTML = ''; // Clear previous grid

            const size = board.length;
            const cellSize = 100 / size; // Calculate cell size dynamically for responsiveness

            for (let r = 0; r < size; r++) {
                for (let c = 0; c < size; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('sudoku-cell');
                    cell.style.width = `${cellSize}%`;
                    cell.style.height = `${cellSize}%`;

                    const value = board[r][c];
                    if (value !== 0) {
                        cell.textContent = value;
                        cell.classList.add('fixed'); // Fixed numbers from the puzzle
                    } else {
                        const input = document.createElement('input');
                        input.type = 'number';
                        input.min = '1';
                        input.max = currentPuzzleType === '9x9' ? '9' : '6';
                        input.maxLength = '1';
                        input.dataset.row = r;
                        input.dataset.col = c;
                        input.addEventListener('input', handleCellInput);
                        cell.appendChild(input);
                    }
                    sudokuGridDiv.appendChild(cell);
                }
            }
        }

        /**
         * Handles input changes in Sudoku cells.
         * @param {Event} event - The input event.
         */
        function handleCellInput(event) {
            let value = event.target.value;
            const row = parseInt(event.target.dataset.row);
            const col = parseInt(event.target.dataset.col);

            // Ensure only single digit and within valid range
            if (value.length > 1) {
                value = value.charAt(0);
            }
            const num = parseInt(value);
            const maxVal = currentPuzzleType === '9x9' ? 9 : 6;

            if (isNaN(num) || num < 1 || num > maxVal) {
                event.target.value = ''; // Clear invalid input
                currentPuzzle[row][col] = 0;
            } else {
                event.target.value = num;
                currentPuzzle[row][col] = num;
            }
        }

        /**
         * Checks the current state of the Sudoku puzzle.
         */
        function checkSolution() {
            // Create a copy of the current puzzle state to solve
            let puzzleCopy = currentPuzzle.map(row => row.slice());
            let solution;

            try {
                if (currentPuzzleType === '9x9') {
                    solution = sudoku9x9.solveMatrix(puzzleCopy);
                } else if (currentPuzzleType === '6x6') {
                    solution = sudoku6x6.solveFromArray(puzzleCopy);
                }
            } catch (e) {
                showMessage('Error solving puzzle for checking: ' + e.message, true);
                return;
            }

            if (!solution) {
                showMessage('This puzzle does not seem to have a solution.', true);
                return;
            }

            let isCorrect = true;
            for (let r = 0; r < currentPuzzle.length; r++) {
                for (let c = 0; c < currentPuzzle[r].length; c++) {
                    // Compare user's input with the solved puzzle
                    if (currentPuzzle[r][c] !== solution[r][c]) {
                        isCorrect = false;
                        // Optionally, highlight incorrect cells
                        // const cellElement = sudokuGridDiv.children[r * currentPuzzle.length + c];
                        // if (!cellElement.classList.contains('fixed')) {
                        //     cellElement.style.backgroundColor = '#fecaca'; // Light red
                        // }
                    }
                }
            }

            if (isCorrect) {
                showMessage('Congratulations! Your solution is correct!', false);
            } else {
                showMessage('Your solution is incorrect. Keep trying!', true);
            }
        }

        /**
         * Solves the current Sudoku puzzle and displays the solution.
         */
        function solvePuzzle() {
            let solvedBoard;
            let puzzleToSolve = initialPuzzleState.map(row => row.slice()); // Solve from initial state

            try {
                if (currentPuzzleType === '9x9') {
                    solvedBoard = sudoku9x9.solveMatrix(puzzleToSolve);
                } else if (currentPuzzleType === '6x6') {
                    solvedBoard = sudoku6x6.solveFromArray(puzzleToSolve);
                }

                if (solvedBoard) {
                    currentPuzzle = solvedBoard; // Update current puzzle with solution
                    renderSudokuGrid(solvedBoard); // Render the solved grid
                    showMessage('Puzzle solved!', false);
                } else {
                    showMessage('Could not find a solution for this puzzle.', true);
                }
            } catch (e) {
                console.error("Error solving puzzle:", e);
                showMessage('Error solving puzzle: ' + e.message, true);
            }
        }

        /**
         * Clears all user-entered numbers from the board, reverting to the initial state.
         */
        function clearBoard() {
            if (currentPuzzle) {
                currentPuzzle = JSON.parse(JSON.stringify(initialPuzzleState)); // Revert to initial state
                renderSudokuGrid(currentPuzzle);
                showMessage('Board cleared!', false);
            }
        }

        // --- Event Listeners ---
        startScanButton.addEventListener('click', startScanner);
        stopScanButton.addEventListener('click', stopScanner);
        checkButton.addEventListener('click', checkSolution);
        solveButton.addEventListener('click', solvePuzzle);
        clearButton.addEventListener('click', clearBoard);

        // Initial setup on page load
        window.onload = () => {
            // Initialize Sudoku objects here, after all scripts are loaded
            sudoku9x9 = new Sudoku();
            sudoku6x6 = new Sudoku6x6();

            // You might want to automatically start the scanner or show instructions
            // For now, it waits for user interaction.
            showMessage('Click "Start QR Scan" to begin, or "Upload QR Image" to load a puzzle.', false);
        };
    </script>
</body>
</html>
