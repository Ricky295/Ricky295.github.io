<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sudoku Flux Player</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;600;800&display=swap');
        
        body {
            font-family: 'Plus Jakarta Sans', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #f8fafc;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 1rem;
        }

        .sudoku-container {
            width: 100%;
            max-width: 450px;
            background: #4f46e5;
            padding: 2px;
            border-radius: 12px;
            box-shadow: 0 25px 60px rgba(79, 70, 229, 0.3);
            display: grid;
            gap: 1px;
        }

        .cell {
            background: #1e293b;
            aspect-ratio: 1 / 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(1rem, 5vw, 1.5rem);
            font-weight: 800;
            cursor: pointer;
            transition: all 0.15s ease;
            user-select: none;
            border-radius: 2px;
        }

        .cell:hover:not(.fixed) { 
            background: #334155; 
            transform: scale(0.95);
        }
        .cell.selected { 
            background: #6366f1 !important; 
            color: white;
            box-shadow: 0 0 20px rgba(99, 102, 241, 0.5);
        }
        .cell.fixed { 
            background: #0f172a; 
            color: #94a3b8; 
            cursor: default; 
        }
        .cell.error { 
            color: #f87171;
            animation: shake 0.3s;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        /* 9x9: Thick borders after columns 3 and 6 */
        .grid-9 .cell:nth-child(9n+3),
        .grid-9 .cell:nth-child(9n+6) { border-right: 3px solid #4f46e5; }
        
        /* 9x9: Thick borders after rows 3 and 6 */
        .grid-9 .cell:nth-child(n+19):nth-child(-n+27),
        .grid-9 .cell:nth-child(n+46):nth-child(-n+54) { border-bottom: 3px solid #4f46e5; }

        .grid-6 .cell:nth-child(2n):not(:nth-child(6n)) { border-right: 3px solid #4f46e5; }
        .grid-6 .cell:nth-child(n+7):nth-child(-n+12),
        .grid-6 .cell:nth-child(n+19):nth-child(-n+24) { border-bottom: 3px solid #4f46e5; }

        .numpad-btn {
            background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
            border: 2px solid rgba(99, 102, 241, 0.3);
            border-radius: 12px;
            height: 50px;
            font-weight: 800;
            transition: all 0.2s ease;
            color: #f8fafc;
        }
        .numpad-btn:hover {
            border-color: #6366f1;
            background: linear-gradient(135deg, #334155 0%, #475569 100%);
        }
        .numpad-btn:active { 
            transform: scale(0.92); 
            background: #6366f1;
        }

        .gradient-text {
            background: linear-gradient(135deg, #6366f1 0%, #a855f7 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
    </style>
</head>
<body>

    <header class="w-full max-w-md flex justify-between items-center mb-8">
        <div>
            <h1 class="text-3xl font-extrabold tracking-tight text-white">
                Sudoku <span class="gradient-text">Flux</span>
            </h1>
            <div class="flex gap-2 items-center mt-1">
                <span id="puzzle-label" class="text-xs font-bold text-slate-400 uppercase">Puzzle 1</span>
                <span id="difficulty-badge" class="bg-indigo-500/20 text-indigo-300 text-[10px] px-2 py-0.5 rounded-full border border-indigo-500/30 font-bold">
                    Calculating...
                </span>
            </div>
        </div>
        <div class="flex gap-2">
            <button onclick="changePuzzle(-1)" class="p-2 rounded-full bg-slate-800 hover:bg-indigo-600 transition">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path d="M15 19l-7-7 7-7" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
            </button>
            <button onclick="changePuzzle(1)" class="p-2 rounded-full bg-slate-800 hover:bg-indigo-600 transition">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path d="M9 5l7 7-7 7" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
            </button>
        </div>
    </header>

    <div id="grid" class="sudoku-container mb-8"></div>

    <div class="w-full max-w-md space-y-4">
        <div id="numpad" class="grid grid-cols-5 gap-2"></div>
        <div class="flex gap-2">
            <button onclick="clearCell()" class="flex-1 py-4 rounded-2xl bg-slate-800 font-bold text-slate-400 hover:text-white hover:bg-slate-700 transition">
                Clear
            </button>
            <button onclick="checkPuzzle()" class="flex-1 py-4 rounded-2xl bg-gradient-to-r from-indigo-600 to-purple-600 font-bold hover:from-indigo-500 hover:to-purple-500 transition shadow-lg shadow-indigo-500/30">
                Verify
            </button>
        </div>
    </div>

    <div id="toast" class="fixed bottom-8 bg-white text-slate-900 px-6 py-3 rounded-full font-bold shadow-2xl opacity-0 transition-all pointer-events-none"></div>

    <script>
        // Inline newsudoku.js (9x9)
        const Sudoku = (() => {
            function convertToMatrix(sudokuString) {
                if (sudokuString.length !== 81) throw new Error("Must be 81 chars");
                const matrix = [];
                for (let i = 0; i < 9; i++) {
                    const row = Array.from(sudokuString.substring(i * 9, (i + 1) * 9), c => parseInt(c));
                    matrix.push(row);
                }
                return matrix;
            }

            function deepCopyBoard(board) {
                return board.map(row => [...row]);
            }

            function getPossibleValues(board, row, col) {
                if (board[row][col] !== 0) return [];
                const used = new Set();
                for (let c = 0; c < 9; c++) used.add(board[row][c]);
                for (let r = 0; r < 9; r++) used.add(board[r][col]);
                const startRow = Math.floor(row / 3) * 3;
                const startCol = Math.floor(col / 3) * 3;
                for (let r = startRow; r < startRow + 3; r++) {
                    for (let c = startCol; c < startCol + 3; c++) {
                        used.add(board[r][c]);
                    }
                }
                const possible = [];
                for (let num = 1; num <= 9; num++) {
                    if (!used.has(num)) possible.push(num);
                }
                return possible;
            }

            function solveWithSingles(sudoku, returnDifficulty = false) {
                const puzzle = deepCopyBoard(sudoku);
                const initialEmptyCells = puzzle.flat().filter(x => x === 0).length;
                
                if (initialEmptyCells === 0) return returnDifficulty ? 0.0 : puzzle;

                const possibilities = Array(9).fill(null).map(() => 
                    Array(9).fill(null).map(() => new Set())
                );
                
                let emptyCellsCount = 0;
                for (let r = 0; r < 9; r++) {
                    for (let c = 0; c < 9; c++) {
                        if (puzzle[r][c] === 0) {
                            possibilities[r][c] = new Set(getPossibleValues(puzzle, r, c));
                            if (possibilities[r][c].size === 0) {
                                return returnDifficulty ? -0.2 : sudoku;
                            }
                            emptyCellsCount++;
                        }
                    }
                }

                return returnDifficulty ? (emptyCellsCount / 81) : puzzle;
            }

            return { convertToMatrix, solveWithSingles };
        })();

        // Inline newsudoku6x6.js
        const Sudoku6x6 = (() => {
            function convertToMatrix(sudokuString) {
                if (sudokuString.length !== 36) throw new Error("Must be 36 chars");
                const matrix = [];
                for (let i = 0; i < 6; i++) {
                    const row = Array.from(sudokuString.substring(i * 6, (i + 1) * 6), c => parseInt(c));
                    matrix.push(row);
                }
                return matrix;
            }

            function deepCopyBoard(board) {
                return board.map(row => [...row]);
            }

            function getPossibleValues(board, row, col) {
                if (board[row][col] !== 0) return [];
                const used = new Set();
                for (let c = 0; c < 6; c++) used.add(board[row][c]);
                for (let r = 0; r < 6; r++) used.add(board[r][col]);
                const startRow = Math.floor(row / 2) * 2;
                const startCol = Math.floor(col / 2) * 2;
                for (let r = startRow; r < startRow + 2; r++) {
                    for (let c = startCol; c < startCol + 2; c++) {
                        used.add(board[r][c]);
                    }
                }
                const possible = [];
                for (let num = 1; num <= 6; num++) {
                    if (!used.has(num)) possible.push(num);
                }
                return possible;
            }

            function solveWithSingles(sudoku, returnDifficulty = false) {
                const puzzle = deepCopyBoard(sudoku);
                const initialEmptyCells = puzzle.flat().filter(x => x === 0).length;
                
                if (initialEmptyCells === 0) return returnDifficulty ? 0.0 : puzzle;

                const possibilities = Array(6).fill(null).map(() => 
                    Array(6).fill(null).map(() => new Set())
                );
                
                let emptyCellsCount = 0;
                for (let r = 0; r < 6; r++) {
                    for (let c = 0; c < 6; c++) {
                        if (puzzle[r][c] === 0) {
                            possibilities[r][c] = new Set(getPossibleValues(puzzle, r, c));
                            if (possibilities[r][c].size === 0) {
                                return returnDifficulty ? -0.2 : sudoku;
                            }
                            emptyCellsCount++;
                        }
                    }
                }

                return returnDifficulty ? (emptyCellsCount / 36) : puzzle;
            }

            return { convertToMatrix, solveWithSingles };
        })();

        // Main App
        let puzzles = [];
        let currentIndex = 0;
        let selectedIdx = null;
        let currentGrid = [];
        let currentSize = 9;

        window.onload = () => {
            const params = new URLSearchParams(window.location.search);
            let raw = params.get('puzzles');
            if (!raw) return showToast("No puzzles found in URL.");

            try { 
                if (!raw.includes(',')) raw = atob(raw); 
            } catch(e) {}

            puzzles = raw.split(',').filter(s => s.length === 81 || s.length === 36);
            if (puzzles.length) loadPuzzle(0);
        };

        function loadPuzzle(idx) {
            currentIndex = idx;
            const str = puzzles[idx];
            currentSize = str.length === 81 ? 9 : 6;
            
            currentGrid = str.split('').map(v => ({
                val: parseInt(v),
                isFixed: v !== '0',
                userInput: 0
            }));

            renderGrid(currentSize);
            updateInfo(currentSize, str);
        }

        function renderGrid(size) {
            const container = document.getElementById('grid');
            container.className = `sudoku-container grid-${size}`;
            container.style.gridTemplateColumns = `repeat(${size}, 1fr)`;
            container.innerHTML = '';

            currentGrid.forEach((cell, i) => {
                const div = document.createElement('div');
                div.className = `cell ${cell.isFixed ? 'fixed' : ''}`;
                div.textContent = cell.isFixed ? cell.val : '';
                div.onclick = () => selectCell(i, div);
                container.appendChild(div);
            });

            const pad = document.getElementById('numpad');
            pad.innerHTML = '';
            for (let i = 1; i <= size; i++) {
                const btn = document.createElement('button');
                btn.className = 'numpad-btn';
                btn.textContent = i;
                btn.onclick = () => enterNumber(i);
                pad.appendChild(btn);
            }
        }

        function selectCell(idx, el) {
            if (currentGrid[idx].isFixed) return;
            document.querySelectorAll('.cell').forEach(c => c.classList.remove('selected'));
            el.classList.add('selected');
            selectedIdx = idx;
        }

        function enterNumber(num) {
            if (selectedIdx === null) return;
            if (currentGrid[selectedIdx].isFixed) return;
            
            currentGrid[selectedIdx].userInput = num;
            const cells = document.querySelectorAll('.cell');
            cells[selectedIdx].textContent = num;
            cells[selectedIdx].classList.remove('error');
        }

        function clearCell() {
            if (selectedIdx === null) return;
            if (currentGrid[selectedIdx].isFixed) return;
            
            currentGrid[selectedIdx].userInput = 0;
            const cells = document.querySelectorAll('.cell');
            cells[selectedIdx].textContent = '';
            cells[selectedIdx].classList.remove('error');
        }

        function updateInfo(size, puzzleStr) {
            document.getElementById('puzzle-label').textContent = 
                `Puzzle ${currentIndex + 1} of ${puzzles.length} (${size}x${size})`;
            
            // Calculate actual difficulty using the solver
            setTimeout(() => {
                try {
                    let difficulty;
                    if (size === 9) {
                        const matrix = Sudoku.convertToMatrix(puzzleStr);
                        difficulty = Sudoku.solveWithSingles(matrix, true);
                    } else {
                        const matrix = Sudoku6x6.convertToMatrix(puzzleStr);
                        difficulty = Sudoku6x6.solveWithSingles(matrix, true);
                    }
                    
                    const percent = Math.max(1, Math.min(100, (difficulty * 100).toFixed(1)));
                    document.getElementById('difficulty-badge').textContent = `${percent}% Difficulty`;
                } catch (e) {
                    document.getElementById('difficulty-badge').textContent = 'Unknown Difficulty';
                }
            }, 100);
            
            selectedIdx = null;
        }

        function changePuzzle(dir) {
            let next = currentIndex + dir;
            if (next < 0) next = puzzles.length - 1;
            if (next >= puzzles.length) next = 0;
            loadPuzzle(next);
        }

        function checkPuzzle() {
            const values = currentGrid.map(c => c.isFixed ? c.val : c.userInput);
            
            if (values.includes(0)) return showToast("⚠️ Finish the puzzle first!");

            let hasErrors = false;
            const cells = document.querySelectorAll('.cell');
            
            // Check rows
            for (let i = 0; i < currentSize; i++) {
                const row = [];
                for (let j = 0; j < currentSize; j++) {
                    row.push(values[i * currentSize + j]);
                }
                if (new Set(row).size !== currentSize) {
                    hasErrors = true;
                    for (let j = 0; j < currentSize; j++) {
                        if (!currentGrid[i * currentSize + j].isFixed) {
                            cells[i * currentSize + j].classList.add('error');
                        }
                    }
                }
            }
            
            // Check columns
            for (let j = 0; j < currentSize; j++) {
                const col = [];
                for (let i = 0; i < currentSize; i++) {
                    col.push(values[i * currentSize + j]);
                }
                if (new Set(col).size !== currentSize) {
                    hasErrors = true;
                    for (let i = 0; i < currentSize; i++) {
                        if (!currentGrid[i * currentSize + j].isFixed) {
                            cells[i * currentSize + j].classList.add('error');
                        }
                    }
                }
            }

            showToast(hasErrors ? "❌ There are mistakes!" : "✅ Perfect! You solved it!");
        }

        function showToast(msg) {
            const t = document.getElementById('toast');
            t.textContent = msg;
            t.style.opacity = '1';
            t.style.transform = 'translateY(-20px)';
            setTimeout(() => {
                t.style.opacity = '0';
                t.style.transform = 'translateY(0)';
            }, 3000);
        }

        document.addEventListener('keydown', (e) => {
            const num = parseInt(e.key);
            if (num >= 1 && num <= currentSize) enterNumber(num);
            if (e.key === 'Backspace' || e.key === 'Delete') clearCell();
            
            // Arrow key navigation
            if (selectedIdx !== null && ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                e.preventDefault();
                const row = Math.floor(selectedIdx / currentSize);
                const col = selectedIdx % currentSize;
                let newRow = row, newCol = col;
                
                if (e.key === 'ArrowUp') newRow = Math.max(0, row - 1);
                if (e.key === 'ArrowDown') newRow = Math.min(currentSize - 1, row + 1);
                if (e.key === 'ArrowLeft') newCol = Math.max(0, col - 1);
                if (e.key === 'ArrowRight') newCol = Math.min(currentSize - 1, col + 1);
                
                const newIdx = newRow * currentSize + newCol;
                const cells = document.querySelectorAll('.cell');
                selectCell(newIdx, cells[newIdx]);
            }
        });
    </script>
</body>
</html>
